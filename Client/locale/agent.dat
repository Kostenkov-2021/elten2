$LOAD_PATH<<"."
$VERBOSE=nil
module JSON
VERSION         = '2.1.0'
VERSION_ARRAY   = VERSION.split(/\./).map { |x| x.to_i }
VERSION_MAJOR   = VERSION_ARRAY[0]
VERSION_MINOR   = VERSION_ARRAY[1]
VERSION_BUILD   = VERSION_ARRAY[2]
end
class OpenStruct
def initialize(hash=nil)
@table = {}
if hash
hash.each_pair do |k, v|
k = k.to_sym
@table[k] = v
end
end
end
def initialize_copy(orig)
super
@table = @table.dup
end
def to_h(&block)
if block_given?
@table.to_h(&block)
else
@table.dup
end
end
def each_pair
return to_enum(__method__) { @table.size } unless block_given?
@table.each_pair{|p| yield p}
self
end
def marshal_dump
@table
end
def marshal_load(x)
@table = x
end
def modifiable?
begin
@modifiable = true
rescue
exception_class = defined?(FrozenError) ? FrozenError : RuntimeError
raise exception_class, "can't modify frozen #{self.class}", caller(3)
end
@table
end
private :modifiable?
alias modifiable modifiable?
protected :modifiable
def new_ostruct_member!(name)
name = name.to_sym
unless singleton_class.method_defined?(name)
define_singleton_method(name) { @table[name] }
define_singleton_method("#{name}=") {|x| modifiable?[name] = x}
end
name
end
private :new_ostruct_member!
alias new_ostruct_member new_ostruct_member!
protected :new_ostruct_member
def freeze
@table.each_key {|key| new_ostruct_member!(key)}
super
end
def respond_to_missing?(mid, include_private = false)
mname = mid.to_s.chomp("=").to_sym
@table&.key?(mname) || super
end
def method_missing(mid, *args)
len = args.length
if mname = mid[/.*(?==\z)/m]
if len != 1
raise ArgumentError, "wrong number of arguments (#{len} for 1)", caller(1)
end
modifiable?[new_ostruct_member!(mname)] = args[0]
elsif len == 0 # and /\A[a-z_]\w*\z/ =~ mid #
if @table.key?(mid)
new_ostruct_member!(mid) unless frozen?
@table[mid]
end
else
begin
super
rescue NoMethodError => err
err.backtrace.shift
raise
end
end
end
def [](name)
@table[name.to_sym]
end
def []=(name, value)
modifiable?[new_ostruct_member!(name)] = value
end
def dig(name, *names)
begin
name = name.to_sym
rescue NoMethodError
raise TypeError, "#{name} is not a symbol nor a string"
end
@table.dig(name, *names)
end
def delete_field(name)
sym = name.to_sym
begin
singleton_class.remove_method(sym, "#{sym}=")
rescue NameError
end
@table.delete(sym) do
raise NameError.new("no field `#{sym}' in #{self}", sym)
end
end
InspectKey = :__inspect_key__
def inspect
ids = (Thread.current[InspectKey] ||= [])
if ids.include?(object_id)
detail = ' ...'
else
ids << object_id
begin
detail = @table.map do |key, value|
" #{key}=#{value.inspect}"
end.join(',')
ensure
ids.pop
end
end
['#<', self.class, detail, '>'].join
end
alias :to_s :inspect
attr_reader :table
protected :table
alias table! table
def ==(other)
return false unless other.kind_of?(OpenStruct)
@table == other.table!
end
def eql?(other)
return false unless other.kind_of?(OpenStruct)
@table.eql?(other.table!)
end
def hash
@table.hash
end
end
module JSON
class GenericObject < OpenStruct
class << self
alias [] new
def json_creatable?
@json_creatable
end
attr_writer :json_creatable
def json_create(data)
data = data.dup
data.delete JSON.create_id
self[data]
end
def from_hash(object)
case
when object.respond_to?(:to_hash)
result = new
object.to_hash.each do |key, value|
result[key] = from_hash(value)
end
result
when object.respond_to?(:to_ary)
object.to_ary.map { |a| from_hash(a) }
else
object
end
end
def load(source, proc = nil, opts = {})
result = ::JSON.load(source, proc, opts.merge(:object_class => self))
result.nil? ? new : result
end
def dump(obj, *args)
::JSON.dump(obj, *args)
end
end
self.json_creatable = false
def to_hash
table
end
def [](name)
__send__(name)
end unless method_defined?(:[])
def []=(name, value)
__send__("#{name}=", value)
end unless method_defined?(:[]=)
def |(other)
self.class[other.to_hash.merge(to_hash)]
end
def as_json(*)
{ JSON.create_id => self.class.name }.merge to_hash
end
def to_json(*a)
as_json.to_json(*a)
end
end
end
module JSON
class << self
def [](object, opts = {})
if object.respond_to? :to_str
JSON.parse(object.to_str, opts)
else
JSON.generate(object, opts)
end
end
attr_reader :parser
def parser=(parser)
@parser = parser
remove_const :Parser if const_defined?(:Parser, false)
const_set :Parser, parser
end
def deep_const_get(path)
path.to_s.split(/::/).inject(Object) do |p, c|
case
when c.empty?                  then p
when p.const_defined?(c, true) then p.const_get(c)
else
begin
p.const_missing(c)
rescue NameError => e
raise ArgumentError, "can't get const #{path}: #{e}"
end
end
end
end
def generator=(generator)
old, $VERBOSE = $VERBOSE, nil
@generator = generator
generator_methods = generator::GeneratorMethods
for const in generator_methods.constants
klass = deep_const_get(const)
modul = generator_methods.const_get(const)
klass.class_eval do
instance_methods(false).each do |m|
m.to_s == 'to_json' and remove_method m
end
include modul
end
end
self.state = generator::State
const_set :State, self.state
const_set :SAFE_STATE_PROTOTYPE, State.new
const_set :FAST_STATE_PROTOTYPE, State.new(
:indent         => '',
:space          => '',
:object_nl      => "",
:array_nl       => "",
:max_nesting    => false
)
const_set :PRETTY_STATE_PROTOTYPE, State.new(
:indent         => '  ',
:space          => ' ',
:object_nl      => "\n",
:array_nl       => "\n"
)
ensure
$VERBOSE = old
end
attr_reader :generator
attr_accessor :state
attr_accessor :create_id
end
self.create_id = 'json_class'
NaN           = 0.0/0
Infinity      = 1.0/0
MinusInfinity = -Infinity
class JSONError < StandardError
def self.wrap(exception)
obj = new("Wrapped(#{exception.class}): #{exception.message.inspect}")
obj.set_backtrace exception.backtrace
obj
end
end
class ParserError < JSONError; end
class NestingError < ParserError; end
class CircularDatastructure < NestingError; end
class GeneratorError < JSONError; end
UnparserError = GeneratorError
class MissingUnicodeSupport < JSONError; end
module_function
def parse(source, opts = {})
Parser.new(source, opts).parse
end
def parse!(source, opts = {})
opts = {
:max_nesting  => false,
:allow_nan    => true
}.merge(opts)
Parser.new(source, opts).parse
end
def generate(obj, opts = nil)
if State === opts
state, opts = opts, nil
else
state = SAFE_STATE_PROTOTYPE.dup
end
if opts
if opts.respond_to? :to_hash
opts = opts.to_hash
elsif opts.respond_to? :to_h
opts = opts.to_h
else
raise TypeError, "can't convert #{opts.class} into Hash"
end
state = state.configure(opts)
end
state.generate(obj)
end
alias unparse generate
module_function :unparse
def fast_generate(obj, opts = nil)
if State === opts
state, opts = opts, nil
else
state = FAST_STATE_PROTOTYPE.dup
end
if opts
if opts.respond_to? :to_hash
opts = opts.to_hash
elsif opts.respond_to? :to_h
opts = opts.to_h
else
raise TypeError, "can't convert #{opts.class} into Hash"
end
state.configure(opts)
end
state.generate(obj)
end
alias fast_unparse fast_generate
module_function :fast_unparse
def pretty_generate(obj, opts = nil)
if State === opts
state, opts = opts, nil
else
state = PRETTY_STATE_PROTOTYPE.dup
end
if opts
if opts.respond_to? :to_hash
opts = opts.to_hash
elsif opts.respond_to? :to_h
opts = opts.to_h
else
raise TypeError, "can't convert #{opts.class} into Hash"
end
state.configure(opts)
end
state.generate(obj)
end
alias pretty_unparse pretty_generate
module_function :pretty_unparse
class << self
attr_accessor :load_default_options
end
self.load_default_options = {
:max_nesting      => false,
:allow_nan        => true,
:allow_blank       => true,
:create_additions => true,
}
def load(source, proc = nil, options = {})
opts = load_default_options.merge options
if source.respond_to? :to_str
source = source.to_str
elsif source.respond_to? :to_io
source = source.to_io.read
elsif source.respond_to?(:read)
source = source.read
end
if opts[:allow_blank] && (source.nil? || source.empty?)
source = 'null'
end
result = parse(source, opts)
recurse_proc(result, &proc) if proc
result
end
def recurse_proc(result, &proc)
case result
when Array
result.each { |x| recurse_proc x, &proc }
proc.call result
when Hash
result.each { |x, y| recurse_proc x, &proc; recurse_proc y, &proc }
proc.call result
else
proc.call result
end
end
alias restore load
module_function :restore
class << self
attr_accessor :dump_default_options
end
self.dump_default_options = {
:max_nesting => false,
:allow_nan   => true,
}
def dump(obj, anIO = nil, limit = nil)
if anIO and limit.nil?
anIO = anIO.to_io if anIO.respond_to?(:to_io)
unless anIO.respond_to?(:write)
limit = anIO
anIO = nil
end
end
opts = JSON.dump_default_options
opts = opts.merge(:max_nesting => limit) if limit
result = generate(obj, opts)
if anIO
anIO.write result
anIO
else
result
end
rescue JSON::NestingError
raise ArgumentError, "exceed depth limit"
end
def self.iconv(to, from, string)
string.encode(to, from)
end
end
module ::Kernel
private
def j(*objs)
objs.each do |obj|
puts JSON::generate(obj, :allow_nan => true, :max_nesting => false)
end
nil
end
def jj(*objs)
objs.each do |obj|
puts JSON::pretty_generate(obj, :allow_nan => true, :max_nesting => false)
end
nil
end
def JSON(object, *args)
if object.respond_to? :to_str
JSON.parse(object.to_str, args.first)
else
JSON.generate(object, args.first)
end
end
end
class ::Class
def json_creatable?
respond_to?(:json_create)
end
end
require("./strscan")
module JSON
module Pure
class Parser < StringScanner
STRING                = /" ((?:[^\x0-\x1f"\\] |
\\["\\\/bfnrt] |
\\u[0-9a-fA-F]{4} |
\\[\x20-\x21\x23-\x2e\x30-\x5b\x5d-\x61\x63-\x65\x67-\x6d\x6f-\x71\x73\x75-\xff])*)
"/nx
INTEGER               = /(-?0|-?[1-9]\d*)/
FLOAT                 = /(-?
(?:0|[1-9]\d*)
(?:
\.\d+(?i:e[+-]?\d+) |
\.\d+ |
(?i:e[+-]?\d+)
)
)/x
NAN                   = /NaN/
INFINITY              = /Infinity/
MINUS_INFINITY        = /-Infinity/
OBJECT_OPEN           = /\{/
OBJECT_CLOSE          = /\}/
ARRAY_OPEN            = /\[/
ARRAY_CLOSE           = /\]/
PAIR_DELIMITER        = /:/
COLLECTION_DELIMITER  = /,/
TRUE                  = /true/
FALSE                 = /false/
NULL                  = /null/
IGNORE                = %r(
(?:
//[^\n\r]*[\n\r]| # line comments
/\*               # c-style comments
(?:
[^*/]|        # normal chars
/[^*]|        # slashes that do not start a nested comment
\*[^/]|       # asterisks that do not end this comment
/(?=\*/)      # single slash before this comment's end
)*
\*/               # the End of this comment
|[ \t\r\n]+       # whitespaces: space, horicontal tab, lf, cr
)+
)mx
UNPARSED = Object.new.freeze
def initialize(source, opts = {})
opts ||= {}
source = convert_encoding source
super source
if !opts.key?(:max_nesting) # defaults to 100
@max_nesting = 100
elsif opts[:max_nesting]
@max_nesting = opts[:max_nesting]
else
@max_nesting = 0
end
@allow_nan = !!opts[:allow_nan]
@symbolize_names = !!opts[:symbolize_names]
if opts.key?(:create_additions)
@create_additions = !!opts[:create_additions]
else
@create_additions = false
end
@symbolize_names && @create_additions and raise ArgumentError,
'options :symbolize_names and :create_additions cannot be used '\
'in conjunction'
@create_id = @create_additions ? JSON.create_id : nil
@object_class = opts[:object_class] || Hash
@array_class  = opts[:array_class] || Array
@decimal_class = opts[:decimal_class]
@match_string = opts[:match_string]
end
alias source string
def reset
super
@current_nesting = 0
end
def parse
reset
obj = nil
while !eos? && skip(IGNORE) do end
if eos?
raise ParserError, "source is not valid JSON!"
else
obj = parse_value
UNPARSED.equal?(obj) and raise ParserError,
"source is not valid JSON!"
end
while !eos? && skip(IGNORE) do end
eos? or raise ParserError, "source is not valid JSON!"
obj
end
private
def convert_encoding(source)
if source.respond_to?(:to_str)
source = source.to_str
else
raise TypeError,
"#{source.inspect} is not like a string"
end
if source.encoding != ::Encoding::ASCII_8BIT
source = source.encode(::Encoding::UTF_8)
source.force_encoding(::Encoding::ASCII_8BIT)
end
source
end
UNESCAPE_MAP = Hash.new { |h, k| h[k] = k.chr }
UNESCAPE_MAP.update({
?"  => '"',
?\\ => '\\',
?/  => '/',
?b  => "\b",
?f  => "\f",
?n  => "\n",
?r  => "\r",
?t  => "\t",
?u  => nil,
})
EMPTY_8BIT_STRING = ''
if ::String.method_defined?(:encode)
EMPTY_8BIT_STRING.force_encoding Encoding::ASCII_8BIT
end
def parse_string
if scan(STRING)
return '' if self[1].empty?
string = self[1].gsub(%r((?:\\[\\bfnrt"/]|(?:\\u(?:[A-Fa-f\d]{4}))+|\\[\x20-\xff]))n) do |c|
if u = UNESCAPE_MAP[$&[1]]
u
else # \uXXXX
bytes = EMPTY_8BIT_STRING.dup
i = 0
while c[6 * i] == ?\\ && c[6 * i + 1] == ?u
bytes << c[6 * i + 2, 2].to_i(16) << c[6 * i + 4, 2].to_i(16)
i += 1
end
JSON.iconv('utf-8', 'utf-16be', bytes)
end
end
if string.respond_to?(:force_encoding)
string.force_encoding(::Encoding::UTF_8)
end
if @create_additions and @match_string
for (regexp, klass) in @match_string
klass.json_creatable? or next
string =~ regexp and return klass.json_create(string)
end
end
string
else
UNPARSED
end
rescue => e
raise ParserError, "Caught #{e.class} at '#{peek(20)}': #{e}"
end
def parse_value
case
when scan(FLOAT)
@decimal_class && @decimal_class.new(self[1]) || Float(self[1])
when scan(INTEGER)
Integer(self[1])
when scan(TRUE)
true
when scan(FALSE)
false
when scan(NULL)
nil
when !UNPARSED.equal?(string = parse_string)
string
when scan(ARRAY_OPEN)
@current_nesting += 1
ary = parse_array
@current_nesting -= 1
ary
when scan(OBJECT_OPEN)
@current_nesting += 1
obj = parse_object
@current_nesting -= 1
obj
when @allow_nan && scan(NAN)
NaN
when @allow_nan && scan(INFINITY)
Infinity
when @allow_nan && scan(MINUS_INFINITY)
MinusInfinity
else
UNPARSED
end
end
def parse_array
raise NestingError, "nesting of #@current_nesting is too deep" if
@max_nesting.nonzero? && @current_nesting > @max_nesting
result = @array_class.new
delim = false
until eos?
case
when !UNPARSED.equal?(value = parse_value)
delim = false
result << value
skip(IGNORE)
if scan(COLLECTION_DELIMITER)
delim = true
elsif match?(ARRAY_CLOSE)
;
else
raise ParserError, "expected ',' or ']' in array at '#{peek(20)}'!"
end
when scan(ARRAY_CLOSE)
if delim
raise ParserError, "expected next element in array at '#{peek(20)}'!"
end
break
when skip(IGNORE)
;
else
raise ParserError, "unexpected token in array at '#{peek(20)}'!"
end
end
result
end
def parse_object
raise NestingError, "nesting of #@current_nesting is too deep" if
@max_nesting.nonzero? && @current_nesting > @max_nesting
result = @object_class.new
delim = false
until eos?
case
when !UNPARSED.equal?(string = parse_string)
skip(IGNORE)
unless scan(PAIR_DELIMITER)
raise ParserError, "expected ':' in object at '#{peek(20)}'!"
end
skip(IGNORE)
unless UNPARSED.equal?(value = parse_value)
result[@symbolize_names ? string.to_sym : string] = value
delim = false
skip(IGNORE)
if scan(COLLECTION_DELIMITER)
delim = true
elsif match?(OBJECT_CLOSE)
;
else
raise ParserError, "expected ',' or '}' in object at '#{peek(20)}'!"
end
else
raise ParserError, "expected value in object at '#{peek(20)}'!"
end
when scan(OBJECT_CLOSE)
if delim
raise ParserError, "expected next name, value pair in object at '#{peek(20)}'!"
end
if @create_additions and klassname = result[@create_id]
klass = JSON.deep_const_get klassname
break unless klass and klass.json_creatable?
result = klass.json_create(result)
end
break
when skip(IGNORE)
;
else
raise ParserError, "unexpected token in object at '#{peek(20)}'!"
end
end
result
end
end
end
end
module JSON
module Pure
class Parser < StringScanner
STRING                = /" ((?:[^\x0-\x1f"\\] |
\\["\\\/bfnrt] |
\\u[0-9a-fA-F]{4} |
\\[\x20-\x21\x23-\x2e\x30-\x5b\x5d-\x61\x63-\x65\x67-\x6d\x6f-\x71\x73\x75-\xff])*)
"/nx
INTEGER               = /(-?0|-?[1-9]\d*)/
FLOAT                 = /(-?
(?:0|[1-9]\d*)
(?:
\.\d+(?i:e[+-]?\d+) |
\.\d+ |
(?i:e[+-]?\d+)
)
)/x
NAN                   = /NaN/
INFINITY              = /Infinity/
MINUS_INFINITY        = /-Infinity/
OBJECT_OPEN           = /\{/
OBJECT_CLOSE          = /\}/
ARRAY_OPEN            = /\[/
ARRAY_CLOSE           = /\]/
PAIR_DELIMITER        = /:/
COLLECTION_DELIMITER  = /,/
TRUE                  = /true/
FALSE                 = /false/
NULL                  = /null/
IGNORE                = %r(
(?:
//[^\n\r]*[\n\r]| # line comments
/\*               # c-style comments
(?:
[^*/]|        # normal chars
/[^*]|        # slashes that do not start a nested comment
\*[^/]|       # asterisks that do not end this comment
/(?=\*/)      # single slash before this comment's end
)*
\*/               # the End of this comment
|[ \t\r\n]+       # whitespaces: space, horicontal tab, lf, cr
)+
)mx
UNPARSED = Object.new.freeze
def initialize(source, opts = {})
opts ||= {}
source = convert_encoding source
super source
if !opts.key?(:max_nesting) # defaults to 100
@max_nesting = 100
elsif opts[:max_nesting]
@max_nesting = opts[:max_nesting]
else
@max_nesting = 0
end
@allow_nan = !!opts[:allow_nan]
@symbolize_names = !!opts[:symbolize_names]
if opts.key?(:create_additions)
@create_additions = !!opts[:create_additions]
else
@create_additions = false
end
@symbolize_names && @create_additions and raise ArgumentError,
'options :symbolize_names and :create_additions cannot be used '\
'in conjunction'
@create_id = @create_additions ? JSON.create_id : nil
@object_class = opts[:object_class] || Hash
@array_class  = opts[:array_class] || Array
@decimal_class = opts[:decimal_class]
@match_string = opts[:match_string]
end
alias source string
def reset
super
@current_nesting = 0
end
def parse
reset
obj = nil
while !eos? && skip(IGNORE) do end
if eos?
raise ParserError, "source is not valid JSON!"
else
obj = parse_value
UNPARSED.equal?(obj) and raise ParserError,
"source is not valid JSON!"
end
while !eos? && skip(IGNORE) do end
eos? or raise ParserError, "source is not valid JSON!"
obj
end
private
def convert_encoding(source)
if source.respond_to?(:to_str)
source = source.to_str
else
raise TypeError,
"#{source.inspect} is not like a string"
end
if source.encoding != ::Encoding::ASCII_8BIT
source = source.encode(::Encoding::UTF_8)
source.force_encoding(::Encoding::ASCII_8BIT)
end
source
end
UNESCAPE_MAP = Hash.new { |h, k| h[k] = k.chr }
UNESCAPE_MAP.update({
?"  => '"',
?\\ => '\\',
?/  => '/',
?b  => "\b",
?f  => "\f",
?n  => "\n",
?r  => "\r",
?t  => "\t",
?u  => nil,
})
EMPTY_8BIT_STRING = ''
if ::String.method_defined?(:encode)
EMPTY_8BIT_STRING.force_encoding Encoding::ASCII_8BIT
end
def parse_string
if scan(STRING)
return '' if self[1].empty?
string = self[1].gsub(%r((?:\\[\\bfnrt"/]|(?:\\u(?:[A-Fa-f\d]{4}))+|\\[\x20-\xff]))n) do |c|
if u = UNESCAPE_MAP[$&[1]]
u
else # \uXXXX
bytes = EMPTY_8BIT_STRING.dup
i = 0
while c[6 * i] == ?\\ && c[6 * i + 1] == ?u
bytes << c[6 * i + 2, 2].to_i(16) << c[6 * i + 4, 2].to_i(16)
i += 1
end
JSON.iconv('utf-8', 'utf-16be', bytes)
end
end
if string.respond_to?(:force_encoding)
string.force_encoding(::Encoding::UTF_8)
end
if @create_additions and @match_string
for (regexp, klass) in @match_string
klass.json_creatable? or next
string =~ regexp and return klass.json_create(string)
end
end
string
else
UNPARSED
end
rescue => e
raise ParserError, "Caught #{e.class} at '#{peek(20)}': #{e}"
end
def parse_value
case
when scan(FLOAT)
@decimal_class && @decimal_class.new(self[1]) || Float(self[1])
when scan(INTEGER)
Integer(self[1])
when scan(TRUE)
true
when scan(FALSE)
false
when scan(NULL)
nil
when !UNPARSED.equal?(string = parse_string)
string
when scan(ARRAY_OPEN)
@current_nesting += 1
ary = parse_array
@current_nesting -= 1
ary
when scan(OBJECT_OPEN)
@current_nesting += 1
obj = parse_object
@current_nesting -= 1
obj
when @allow_nan && scan(NAN)
NaN
when @allow_nan && scan(INFINITY)
Infinity
when @allow_nan && scan(MINUS_INFINITY)
MinusInfinity
else
UNPARSED
end
end
def parse_array
raise NestingError, "nesting of #@current_nesting is too deep" if
@max_nesting.nonzero? && @current_nesting > @max_nesting
result = @array_class.new
delim = false
until eos?
case
when !UNPARSED.equal?(value = parse_value)
delim = false
result << value
skip(IGNORE)
if scan(COLLECTION_DELIMITER)
delim = true
elsif match?(ARRAY_CLOSE)
;
else
raise ParserError, "expected ',' or ']' in array at '#{peek(20)}'!"
end
when scan(ARRAY_CLOSE)
if delim
raise ParserError, "expected next element in array at '#{peek(20)}'!"
end
break
when skip(IGNORE)
;
else
raise ParserError, "unexpected token in array at '#{peek(20)}'!"
end
end
result
end
def parse_object
raise NestingError, "nesting of #@current_nesting is too deep" if
@max_nesting.nonzero? && @current_nesting > @max_nesting
result = @object_class.new
delim = false
until eos?
case
when !UNPARSED.equal?(string = parse_string)
skip(IGNORE)
unless scan(PAIR_DELIMITER)
raise ParserError, "expected ':' in object at '#{peek(20)}'!"
end
skip(IGNORE)
unless UNPARSED.equal?(value = parse_value)
result[@symbolize_names ? string.to_sym : string] = value
delim = false
skip(IGNORE)
if scan(COLLECTION_DELIMITER)
delim = true
elsif match?(OBJECT_CLOSE)
;
else
raise ParserError, "expected ',' or '}' in object at '#{peek(20)}'!"
end
else
raise ParserError, "expected value in object at '#{peek(20)}'!"
end
when scan(OBJECT_CLOSE)
if delim
raise ParserError, "expected next name, value pair in object at '#{peek(20)}'!"
end
if @create_additions and klassname = result[@create_id]
klass = JSON.deep_const_get klassname
break unless klass and klass.json_creatable?
result = klass.json_create(result)
end
break
when skip(IGNORE)
;
else
raise ParserError, "unexpected token in object at '#{peek(20)}'!"
end
end
result
end
end
end
end
module JSON
MAP = {
"\x0" => '\u0000',
"\x1" => '\u0001',
"\x2" => '\u0002',
"\x3" => '\u0003',
"\x4" => '\u0004',
"\x5" => '\u0005',
"\x6" => '\u0006',
"\x7" => '\u0007',
"\b"  =>  '\b',
"\t"  =>  '\t',
"\n"  =>  '\n',
"\xb" => '\u000b',
"\f"  =>  '\f',
"\r"  =>  '\r',
"\xe" => '\u000e',
"\xf" => '\u000f',
"\x10" => '\u0010',
"\x11" => '\u0011',
"\x12" => '\u0012',
"\x13" => '\u0013',
"\x14" => '\u0014',
"\x15" => '\u0015',
"\x16" => '\u0016',
"\x17" => '\u0017',
"\x18" => '\u0018',
"\x19" => '\u0019',
"\x1a" => '\u001a',
"\x1b" => '\u001b',
"\x1c" => '\u001c',
"\x1d" => '\u001d',
"\x1e" => '\u001e',
"\x1f" => '\u001f',
'"'   =>  '\"',
'\\'  =>  '\\\\',
}
def utf8_to_json(string)
string = string.dup
string.force_encoding(::Encoding::ASCII_8BIT)
string.gsub!(/["\\\x0-\x1f]/) { MAP[$&] }
string.force_encoding(::Encoding::UTF_8)
string
end
def utf8_to_json_ascii(string)
string = string.dup
string.force_encoding(::Encoding::ASCII_8BIT)
string.gsub!(/["\\\x0-\x1f]/n) { MAP[$&] }
string.gsub!(/(
(?:
[\xc2-\xdf][\x80-\xbf]    |
[\xe0-\xef][\x80-\xbf]{2} |
[\xf0-\xf4][\x80-\xbf]{3}
)+ |
[\x80-\xc1\xf5-\xff]       # invalid
)/nx) { |c|
c.size == 1 and raise GeneratorError, "invalid utf8 byte: '#{c}'"
s = JSON.iconv('utf-16be', 'utf-8', c).unpack('H*')[0]
s.force_encoding(::Encoding::ASCII_8BIT)
s.gsub!(/.{4}/n, '\\\\u\&')
s.force_encoding(::Encoding::UTF_8)
}
string.force_encoding(::Encoding::UTF_8)
string
rescue => e
raise GeneratorError.wrap(e)
end
def valid_utf8?(string)
encoding = string.encoding
(encoding == Encoding::UTF_8 || encoding == Encoding::ASCII) &&
string.valid_encoding?
end
module_function :utf8_to_json, :utf8_to_json_ascii, :valid_utf8?
module Pure
module Generator
class State
def self.from_state(opts)
case
when self === opts
opts
when opts.respond_to?(:to_hash)
new(opts.to_hash)
when opts.respond_to?(:to_h)
new(opts.to_h)
else
SAFE_STATE_PROTOTYPE.dup
end
end
def initialize(opts = {})
@indent                = ''
@space                 = ''
@space_before          = ''
@object_nl             = ''
@array_nl              = ''
@allow_nan             = false
@ascii_only            = false
@buffer_initial_length = 1024
configure opts
end
attr_accessor :indent
attr_accessor :space
attr_accessor :space_before
attr_accessor :object_nl
attr_accessor :array_nl
attr_accessor :max_nesting
attr_reader :buffer_initial_length
def buffer_initial_length=(length)
if length > 0
@buffer_initial_length = length
end
end
attr_accessor :depth
def check_max_nesting
return if @max_nesting.zero?
current_nesting = depth + 1
current_nesting > @max_nesting and
raise NestingError, "nesting of #{current_nesting} is too deep"
end
def check_circular?
!@max_nesting.zero?
end
def allow_nan?
@allow_nan
end
def ascii_only?
@ascii_only
end
def configure(opts)
if opts.respond_to?(:to_hash)
opts = opts.to_hash
elsif opts.respond_to?(:to_h)
opts = opts.to_h
else
raise TypeError, "can't convert #{opts.class} into Hash"
end
for key, value in opts
instance_variable_set "@#{key}", value
end
@indent                = opts[:indent] if opts.key?(:indent)
@space                 = opts[:space] if opts.key?(:space)
@space_before          = opts[:space_before] if opts.key?(:space_before)
@object_nl             = opts[:object_nl] if opts.key?(:object_nl)
@array_nl              = opts[:array_nl] if opts.key?(:array_nl)
@allow_nan             = !!opts[:allow_nan] if opts.key?(:allow_nan)
@ascii_only            = opts[:ascii_only] if opts.key?(:ascii_only)
@depth                 = opts[:depth] || 0
@buffer_initial_length ||= opts[:buffer_initial_length]
if !opts.key?(:max_nesting) # defaults to 100
@max_nesting = 100
elsif opts[:max_nesting]
@max_nesting = opts[:max_nesting]
else
@max_nesting = 0
end
self
end
alias merge configure
def to_h
result = {}
for iv in instance_variables
iv = iv.to_s[1..-1]
result[iv.to_sym] = self[iv]
end
result
end
alias to_hash to_h
def generate(obj)
result = obj.to_json(self)
JSON.valid_utf8?(result) or raise GeneratorError,
"source sequence #{result.inspect} is illegal/malformed utf-8"
result
end
def [](name)
if respond_to?(name)
__send__(name)
else
instance_variable_get("@#{name}")
end
end
def []=(name, value)
if respond_to?(name_writer = "#{name}=")
__send__ name_writer, value
else
instance_variable_set "@#{name}", value
end
end
end
module GeneratorMethods
module Object
def to_json(*) to_s.to_json end
end
module Hash
def to_json(state = nil, *)
state = State.from_state(state)
state.check_max_nesting
json_transform(state)
end
private
def json_shift(state)
state.object_nl.empty? or return ''
state.indent * state.depth
end
def json_transform(state)
delim = ','
delim << state.object_nl
result = '{'
result << state.object_nl
depth = state.depth += 1
first = true
indent = !state.object_nl.empty?
each { |key,value|
result << delim unless first
result << state.indent * depth if indent
result << key.to_s.to_json(state)
result << state.space_before
result << ':'
result << state.space
if value.respond_to?(:to_json)
result << value.to_json(state)
else
result << %{"#{String(value)}"}
end
first = false
}
depth = state.depth -= 1
result << state.object_nl
result << state.indent * depth if indent
result << '}'
result
end
end
module Array
def to_json(state = nil, *)
state = State.from_state(state)
state.check_max_nesting
json_transform(state)
end
private
def json_transform(state)
delim = ','
delim << state.array_nl
result = '['
result << state.array_nl
depth = state.depth += 1
first = true
indent = !state.array_nl.empty?
each { |value|
result << delim unless first
result << state.indent * depth if indent
if value.respond_to?(:to_json)
result << value.to_json(state)
else
result << %{"#{String(value)}"}
end
first = false
}
depth = state.depth -= 1
result << state.array_nl
result << state.indent * depth if indent
result << ']'
end
end
module Integer
def to_json(*) to_s end
end
module Float
def to_json(state = nil, *)
state = State.from_state(state)
case
when infinite?
if state.allow_nan?
to_s
else
raise GeneratorError, "#{self} not allowed in JSON"
end
when nan?
if state.allow_nan?
to_s
else
raise GeneratorError, "#{self} not allowed in JSON"
end
else
to_s
end
end
end
module String
def to_json(state = nil, *args)
state = State.from_state(state)
if encoding == ::Encoding::UTF_8
string = self
else
string = encode(::Encoding::UTF_8)
end
if state.ascii_only?
'"' << JSON.utf8_to_json_ascii(string) << '"'
else
'"' << JSON.utf8_to_json(string) << '"'
end
end
module Extend
def json_create(o)
o['raw'].pack('C*')
end
end
def self.included(modul)
modul.extend Extend
end
def to_json_raw_object
{
JSON.create_id  => self.class.name,
'raw'           => self.unpack('C*'),
}
end
def to_json_raw(*args)
to_json_raw_object.to_json(*args)
end
end
module TrueClass
def to_json(*) 'true' end
end
module FalseClass
def to_json(*) 'false' end
end
module NilClass
def to_json(*) 'null' end
end
end
end
end
end
module JSON
MAP = {
"\x0" => '\u0000',
"\x1" => '\u0001',
"\x2" => '\u0002',
"\x3" => '\u0003',
"\x4" => '\u0004',
"\x5" => '\u0005',
"\x6" => '\u0006',
"\x7" => '\u0007',
"\b"  =>  '\b',
"\t"  =>  '\t',
"\n"  =>  '\n',
"\xb" => '\u000b',
"\f"  =>  '\f',
"\r"  =>  '\r',
"\xe" => '\u000e',
"\xf" => '\u000f',
"\x10" => '\u0010',
"\x11" => '\u0011',
"\x12" => '\u0012',
"\x13" => '\u0013',
"\x14" => '\u0014',
"\x15" => '\u0015',
"\x16" => '\u0016',
"\x17" => '\u0017',
"\x18" => '\u0018',
"\x19" => '\u0019',
"\x1a" => '\u001a',
"\x1b" => '\u001b',
"\x1c" => '\u001c',
"\x1d" => '\u001d',
"\x1e" => '\u001e',
"\x1f" => '\u001f',
'"'   =>  '\"',
'\\'  =>  '\\\\',
}
def utf8_to_json(string)
string = string.dup
string.force_encoding(::Encoding::ASCII_8BIT)
string.gsub!(/["\\\x0-\x1f]/) { MAP[$&] }
string.force_encoding(::Encoding::UTF_8)
string
end
def utf8_to_json_ascii(string)
string = string.dup
string.force_encoding(::Encoding::ASCII_8BIT)
string.gsub!(/["\\\x0-\x1f]/n) { MAP[$&] }
string.gsub!(/(
(?:
[\xc2-\xdf][\x80-\xbf]    |
[\xe0-\xef][\x80-\xbf]{2} |
[\xf0-\xf4][\x80-\xbf]{3}
)+ |
[\x80-\xc1\xf5-\xff]       # invalid
)/nx) { |c|
c.size == 1 and raise GeneratorError, "invalid utf8 byte: '#{c}'"
s = JSON.iconv('utf-16be', 'utf-8', c).unpack('H*')[0]
s.force_encoding(::Encoding::ASCII_8BIT)
s.gsub!(/.{4}/n, '\\\\u\&')
s.force_encoding(::Encoding::UTF_8)
}
string.force_encoding(::Encoding::UTF_8)
string
rescue => e
raise GeneratorError.wrap(e)
end
def valid_utf8?(string)
encoding = string.encoding
(encoding == Encoding::UTF_8 || encoding == Encoding::ASCII) &&
string.valid_encoding?
end
module_function :utf8_to_json, :utf8_to_json_ascii, :valid_utf8?
module Pure
module Generator
class State
def self.from_state(opts)
case
when self === opts
opts
when opts.respond_to?(:to_hash)
new(opts.to_hash)
when opts.respond_to?(:to_h)
new(opts.to_h)
else
SAFE_STATE_PROTOTYPE.dup
end
end
def initialize(opts = {})
@indent                = ''
@space                 = ''
@space_before          = ''
@object_nl             = ''
@array_nl              = ''
@allow_nan             = false
@ascii_only            = false
@buffer_initial_length = 1024
configure opts
end
attr_accessor :indent
attr_accessor :space
attr_accessor :space_before
attr_accessor :object_nl
attr_accessor :array_nl
attr_accessor :max_nesting
attr_reader :buffer_initial_length
def buffer_initial_length=(length)
if length > 0
@buffer_initial_length = length
end
end
attr_accessor :depth
def check_max_nesting
return if @max_nesting.zero?
current_nesting = depth + 1
current_nesting > @max_nesting and
raise NestingError, "nesting of #{current_nesting} is too deep"
end
def check_circular?
!@max_nesting.zero?
end
def allow_nan?
@allow_nan
end
def ascii_only?
@ascii_only
end
def configure(opts)
if opts.respond_to?(:to_hash)
opts = opts.to_hash
elsif opts.respond_to?(:to_h)
opts = opts.to_h
else
raise TypeError, "can't convert #{opts.class} into Hash"
end
for key, value in opts
instance_variable_set "@#{key}", value
end
@indent                = opts[:indent] if opts.key?(:indent)
@space                 = opts[:space] if opts.key?(:space)
@space_before          = opts[:space_before] if opts.key?(:space_before)
@object_nl             = opts[:object_nl] if opts.key?(:object_nl)
@array_nl              = opts[:array_nl] if opts.key?(:array_nl)
@allow_nan             = !!opts[:allow_nan] if opts.key?(:allow_nan)
@ascii_only            = opts[:ascii_only] if opts.key?(:ascii_only)
@depth                 = opts[:depth] || 0
@buffer_initial_length ||= opts[:buffer_initial_length]
if !opts.key?(:max_nesting) # defaults to 100
@max_nesting = 100
elsif opts[:max_nesting]
@max_nesting = opts[:max_nesting]
else
@max_nesting = 0
end
self
end
alias merge configure
def to_h
result = {}
for iv in instance_variables
iv = iv.to_s[1..-1]
result[iv.to_sym] = self[iv]
end
result
end
alias to_hash to_h
def generate(obj)
result = obj.to_json(self)
JSON.valid_utf8?(result) or raise GeneratorError,
"source sequence #{result.inspect} is illegal/malformed utf-8"
result
end
def [](name)
if respond_to?(name)
__send__(name)
else
instance_variable_get("@#{name}")
end
end
def []=(name, value)
if respond_to?(name_writer = "#{name}=")
__send__ name_writer, value
else
instance_variable_set "@#{name}", value
end
end
end
module GeneratorMethods
module Object
def to_json(*) to_s.to_json end
end
module Hash
def to_json(state = nil, *)
state = State.from_state(state)
state.check_max_nesting
json_transform(state)
end
private
def json_shift(state)
state.object_nl.empty? or return ''
state.indent * state.depth
end
def json_transform(state)
delim = ','
delim << state.object_nl
result = '{'
result << state.object_nl
depth = state.depth += 1
first = true
indent = !state.object_nl.empty?
each { |key,value|
result << delim unless first
result << state.indent * depth if indent
result << key.to_s.to_json(state)
result << state.space_before
result << ':'
result << state.space
if value.respond_to?(:to_json)
result << value.to_json(state)
else
result << %{"#{String(value)}"}
end
first = false
}
depth = state.depth -= 1
result << state.object_nl
result << state.indent * depth if indent
result << '}'
result
end
end
module Array
def to_json(state = nil, *)
state = State.from_state(state)
state.check_max_nesting
json_transform(state)
end
private
def json_transform(state)
delim = ','
delim << state.array_nl
result = '['
result << state.array_nl
depth = state.depth += 1
first = true
indent = !state.array_nl.empty?
each { |value|
result << delim unless first
result << state.indent * depth if indent
if value.respond_to?(:to_json)
result << value.to_json(state)
else
result << %{"#{String(value)}"}
end
first = false
}
depth = state.depth -= 1
result << state.array_nl
result << state.indent * depth if indent
result << ']'
end
end
module Integer
def to_json(*) to_s end
end
module Float
def to_json(state = nil, *)
state = State.from_state(state)
case
when infinite?
if state.allow_nan?
to_s
else
raise GeneratorError, "#{self} not allowed in JSON"
end
when nan?
if state.allow_nan?
to_s
else
raise GeneratorError, "#{self} not allowed in JSON"
end
else
to_s
end
end
end
module String
def to_json(state = nil, *args)
state = State.from_state(state)
if encoding == ::Encoding::UTF_8
string = self
else
string = encode(::Encoding::UTF_8)
end
if state.ascii_only?
'"' << JSON.utf8_to_json_ascii(string) << '"'
else
'"' << JSON.utf8_to_json(string) << '"'
end
end
module Extend
def json_create(o)
o['raw'].pack('C*')
end
end
def self.included(modul)
modul.extend Extend
end
def to_json_raw_object
{
JSON.create_id  => self.class.name,
'raw'           => self.unpack('C*'),
}
end
def to_json_raw(*args)
to_json_raw_object.to_json(*args)
end
end
module TrueClass
def to_json(*) 'true' end
end
module FalseClass
def to_json(*) 'false' end
end
module NilClass
def to_json(*) 'null' end
end
end
end
end
end
module JSON
module Pure


$DEBUG and warn "Using Pure library for JSON."
JSON.parser = Parser
JSON.generator = Generator
end
JSON_LOADED = true unless defined?(::JSON::JSON_LOADED)
end
module JSON
module Pure


$DEBUG and warn "Using Pure library for JSON."
JSON.parser = Parser
JSON.generator = Generator
end
JSON_LOADED = true unless defined?(::JSON::JSON_LOADED)
end
require("./digest")
module Digest
REQUIRE_MUTEX = Thread::Mutex.new
def self.const_missing(name)
case name
when :SHA256, :SHA384, :SHA512
lib = 'digest/sha2.so'
else
lib = File.join('digest', name.to_s.downcase)
end
begin

rescue LoadError
raise LoadError, "library not found for class Digest::#{name} -- #{lib}", caller(1)
end
unless Digest.const_defined?(name)
raise NameError, "uninitialized constant Digest::#{name}", caller(1)
end
Digest.const_get(name)
end
class ::Digest::Class
def self.file(name, *args)
new(*args).file(name)
end
def self.base64digest(str, *args)
[digest(str, *args)].pack('m0')
end
end
module Instance
def file(name)
File.open(name, "rb") {|f|
buf = ""
while f.read(16384, buf)
update buf
end
}
self
end
def base64digest(str = nil)
[str ? digest(str) : digest].pack('m0')
end
def base64digest!
[digest!].pack('m0')
end
end
end
def Digest(name)
const = name.to_sym
Digest::REQUIRE_MUTEX.synchronize {
Digest.const_missing(const)
}
rescue LoadError
if Digest.const_defined?(const)
Digest.const_get(const)
else
raise
end
end
require("./sha1")
require("./sha2")
#--
#++
module Digest
class SHA2 < Digest::Class
def initialize(bitlen = 256)
case bitlen
when 256
@sha2 = Digest::SHA256.new
when 384
@sha2 = Digest::SHA384.new
when 512
@sha2 = Digest::SHA512.new
else
raise ArgumentError, "unsupported bit length: %s" % bitlen.inspect
end
@bitlen = bitlen
end
def reset
@sha2.reset
self
end
def update(str)
@sha2.update(str)
self
end
alias << update
def finish
@sha2.digest!
end
private :finish
def block_length
@sha2.block_length
end
def digest_length
@sha2.digest_length
end
def initialize_copy(other)
@sha2 = other.instance_eval { @sha2.clone }
end
def inspect
"#<%s:%d %s>" % [self.class.name, @bitlen, hexdigest]
end
end
end
require("./md5")
require("./rmd160")
require("./bubblebabble")
module NetHttp2
module Callbacks
def on(event, &block)
raise ArgumentError, 'on event must provide a block' unless block_given?
@callback_events        ||= {}
@callback_events[event] ||= []
@callback_events[event] << block
end
def emit(event, arg)
return unless @callback_events && @callback_events[event]
@callback_events[event].each { |b| b.call(arg) }
end
def callback_events
@callback_events || {}
end
end
end
require("./socket")
require("./wait")
class Addrinfo
def family_addrinfo(*args)
if args.empty?
raise ArgumentError, "no address specified"
elsif Addrinfo === args.first
raise ArgumentError, "too many arguments" if args.length != 1
addrinfo = args.first
if (self.pfamily != addrinfo.pfamily) ||
(self.socktype != addrinfo.socktype)
raise ArgumentError, "Addrinfo type mismatch"
end
addrinfo
elsif self.ip?
raise ArgumentError, "IP address needs host and port but #{args.length} arguments given" if args.length != 2
host, port = args
Addrinfo.getaddrinfo(host, port, self.pfamily, self.socktype, self.protocol)[0]
elsif self.unix?
raise ArgumentError, "UNIX socket needs single path argument but #{args.length} arguments given" if args.length != 1
path, = args
Addrinfo.unix(path)
else
raise ArgumentError, "unexpected family"
end
end
def connect_internal(local_addrinfo, timeout=nil) # :yields: socket
sock = Socket.new(self.pfamily, self.socktype, self.protocol)
begin
sock.ipv6only! if self.ipv6?
sock.bind local_addrinfo if local_addrinfo
if timeout
case sock.connect_nonblock(self, exception: false)
when 0 # success or EISCONN, other errors raise
break
when :wait_writable
sock.wait_writable(timeout) or
raise Errno::ETIMEDOUT, 'user specified timeout'
end while true
else
sock.connect(self)
end
rescue Exception
sock.close
raise
end
if block_given?
begin
yield sock
ensure
sock.close
end
else
sock
end
end
protected :connect_internal
def connect_from(*args, timeout: nil, &block)
connect_internal(family_addrinfo(*args), timeout, &block)
end
def connect(timeout: nil, &block)
connect_internal(nil, timeout, &block)
end
def connect_to(*args, timeout: nil, &block)
remote_addrinfo = family_addrinfo(*args)
remote_addrinfo.connect_internal(self, timeout, &block)
end
def bind
sock = Socket.new(self.pfamily, self.socktype, self.protocol)
begin
sock.ipv6only! if self.ipv6?
sock.setsockopt(:SOCKET, :REUSEADDR, 1)
sock.bind(self)
rescue Exception
sock.close
raise
end
if block_given?
begin
yield sock
ensure
sock.close
end
else
sock
end
end
def listen(backlog=Socket::SOMAXCONN)
sock = Socket.new(self.pfamily, self.socktype, self.protocol)
begin
sock.ipv6only! if self.ipv6?
sock.setsockopt(:SOCKET, :REUSEADDR, 1)
sock.bind(self)
sock.listen(backlog)
rescue Exception
sock.close
raise
end
if block_given?
begin
yield sock
ensure
sock.close
end
else
sock
end
end
def self.foreach(nodename, service, family=nil, socktype=nil, protocol=nil, flags=nil, &block)
Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol, flags).each(&block)
end
end
class BasicSocket < IO
def connect_address
addr = local_address
afamily = addr.afamily
if afamily == Socket::AF_INET
raise SocketError, "unbound IPv4 socket" if addr.ip_port == 0
if addr.ip_address == "0.0.0.0"
addr = Addrinfo.new(["AF_INET", addr.ip_port, nil, "127.0.0.1"], addr.pfamily, addr.socktype, addr.protocol)
end
elsif defined?(Socket::AF_INET6) && afamily == Socket::AF_INET6
raise SocketError, "unbound IPv6 socket" if addr.ip_port == 0
if addr.ip_address == "::"
addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
elsif addr.ip_address == "0.0.0.0" # MacOS X 10.4 returns "a.b.c.d" for IPv4-mapped IPv6 address.
addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
elsif addr.ip_address == "::ffff:0.0.0.0" # MacOS X 10.6 returns "::ffff:a.b.c.d" for IPv4-mapped IPv6 address.
addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
end
elsif defined?(Socket::AF_UNIX) && afamily == Socket::AF_UNIX
raise SocketError, "unbound Unix socket" if addr.unix_path == ""
end
addr
end
def sendmsg(mesg, flags = 0, dest_sockaddr = nil, *controls)
__sendmsg(mesg, flags, dest_sockaddr, controls)
end
def sendmsg_nonblock(mesg, flags = 0, dest_sockaddr = nil, *controls,
exception: true)
__sendmsg_nonblock(mesg, flags, dest_sockaddr, controls, exception)
end
def recv_nonblock(len, flag = 0, str = nil, exception: true)
__recv_nonblock(len, flag, str, exception)
end
def recvmsg(dlen = nil, flags = 0, clen = nil, scm_rights: false)
__recvmsg(dlen, flags, clen, scm_rights)
end
def recvmsg_nonblock(dlen = nil, flags = 0, clen = nil,
scm_rights: false, exception: true)
__recvmsg_nonblock(dlen, flags, clen, scm_rights, exception)
end
if RUBY_PLATFORM =~ /linux/ && Socket.const_defined?(:MSG_DONTWAIT)
def read_nonblock(len, str = nil, exception: true)
__read_nonblock(len, str, exception)
end
def write_nonblock(buf, exception: true)
__write_nonblock(buf, exception)
end
end
end
class Socket < BasicSocket
def ipv6only!
if defined? Socket::IPV6_V6ONLY
self.setsockopt(:IPV6, :V6ONLY, 1)
end
end
def recvfrom_nonblock(len, flag = 0, str = nil, exception: true)
__recvfrom_nonblock(len, flag, str, exception)
end
def accept_nonblock(exception: true)
__accept_nonblock(exception)
end
def self.tcp(host, port, local_host = nil, local_port = nil, connect_timeout: nil) # :yield: socket
last_error = nil
ret = nil
local_addr_list = nil
if local_host != nil || local_port != nil
local_addr_list = Addrinfo.getaddrinfo(local_host, local_port, nil, :STREAM, nil)
end
Addrinfo.foreach(host, port, nil, :STREAM) {|ai|
if local_addr_list
local_addr = local_addr_list.find {|local_ai| local_ai.afamily == ai.afamily }
next unless local_addr
else
local_addr = nil
end
begin
sock = local_addr ?
ai.connect_from(local_addr, timeout: connect_timeout) :
ai.connect(timeout: connect_timeout)
rescue SystemCallError
last_error = $!
next
end
ret = sock
break
}
unless ret
if last_error
raise last_error
else
raise SocketError, "no appropriate local address"
end
end
if block_given?
begin
yield ret
ensure
ret.close
end
else
ret
end
end
def self.ip_sockets_port0(ai_list, reuseaddr)
sockets = []
begin
sockets.clear
port = nil
ai_list.each {|ai|
begin
s = Socket.new(ai.pfamily, ai.socktype, ai.protocol)
rescue SystemCallError
next
end
sockets << s
s.ipv6only! if ai.ipv6?
if reuseaddr
s.setsockopt(:SOCKET, :REUSEADDR, 1)
end
unless port
s.bind(ai)
port = s.local_address.ip_port
else
s.bind(ai.family_addrinfo(ai.ip_address, port))
end
}
rescue Errno::EADDRINUSE
sockets.each(&:close)
retry
rescue Exception
sockets.each(&:close)
raise
end
sockets
end
class << self
private :ip_sockets_port0
end
def self.tcp_server_sockets_port0(host)
ai_list = Addrinfo.getaddrinfo(host, 0, nil, :STREAM, nil, Socket::AI_PASSIVE)
sockets = ip_sockets_port0(ai_list, true)
begin
sockets.each {|s|
s.listen(Socket::SOMAXCONN)
}
rescue Exception
sockets.each(&:close)
raise
end
sockets
end
class << self
private :tcp_server_sockets_port0
end
def self.tcp_server_sockets(host=nil, port)
if port == 0
sockets = tcp_server_sockets_port0(host)
else
last_error = nil
sockets = []
begin
Addrinfo.foreach(host, port, nil, :STREAM, nil, Socket::AI_PASSIVE) {|ai|
begin
s = ai.listen
rescue SystemCallError
last_error = $!
next
end
sockets << s
}
if sockets.empty?
raise last_error
end
rescue Exception
sockets.each(&:close)
raise
end
end
if block_given?
begin
yield sockets
ensure
sockets.each(&:close)
end
else
sockets
end
end
def self.accept_loop(*sockets) # :yield: socket, client_addrinfo
sockets.flatten!(1)
if sockets.empty?
raise ArgumentError, "no sockets"
end
loop {
readable, _, _ = IO.select(sockets)
readable.each {|r|
sock, addr = r.accept_nonblock(exception: false)
next if sock == :wait_readable
yield sock, addr
}
}
end
def self.tcp_server_loop(host=nil, port, &b) # :yield: socket, client_addrinfo
tcp_server_sockets(host, port) {|sockets|
accept_loop(sockets, &b)
}
end
def self.udp_server_sockets(host=nil, port)
last_error = nil
sockets = []
ipv6_recvpktinfo = nil
if defined? Socket::AncillaryData
if defined? Socket::IPV6_RECVPKTINFO # RFC 3542
ipv6_recvpktinfo = Socket::IPV6_RECVPKTINFO
elsif defined? Socket::IPV6_PKTINFO # RFC 2292
ipv6_recvpktinfo = Socket::IPV6_PKTINFO
end
end
local_addrs = Socket.ip_address_list
ip_list = []
Addrinfo.foreach(host, port, nil, :DGRAM, nil, Socket::AI_PASSIVE) {|ai|
if ai.ipv4? && ai.ip_address == "0.0.0.0"
local_addrs.each {|a|
next unless a.ipv4?
ip_list << Addrinfo.new(a.to_sockaddr, :INET, :DGRAM, 0);
}
elsif ai.ipv6? && ai.ip_address == "::" && !ipv6_recvpktinfo
local_addrs.each {|a|
next unless a.ipv6?
ip_list << Addrinfo.new(a.to_sockaddr, :INET6, :DGRAM, 0);
}
else
ip_list << ai
end
}
ip_list.uniq!(&:to_sockaddr)
if port == 0
sockets = ip_sockets_port0(ip_list, false)
else
ip_list.each {|ip|
ai = Addrinfo.udp(ip.ip_address, port)
begin
s = ai.bind
rescue SystemCallError
last_error = $!
next
end
sockets << s
}
if sockets.empty?
raise last_error
end
end
sockets.each {|s|
ai = s.local_address
if ipv6_recvpktinfo && ai.ipv6? && ai.ip_address == "::"
s.setsockopt(:IPV6, ipv6_recvpktinfo, 1)
end
}
if block_given?
begin
yield sockets
ensure
sockets.each(&:close) if sockets
end
else
sockets
end
end
def self.udp_server_recv(sockets)
sockets.each {|r|
msg, sender_addrinfo, _, *controls = r.recvmsg_nonblock(exception: false)
next if msg == :wait_readable
ai = r.local_address
if ai.ipv6? and pktinfo = controls.find {|c| c.cmsg_is?(:IPV6, :PKTINFO) }
ai = Addrinfo.udp(pktinfo.ipv6_pktinfo_addr.ip_address, ai.ip_port)
yield msg, UDPSource.new(sender_addrinfo, ai) {|reply_msg|
r.sendmsg reply_msg, 0, sender_addrinfo, pktinfo
}
else
yield msg, UDPSource.new(sender_addrinfo, ai) {|reply_msg|
r.send reply_msg, 0, sender_addrinfo
}
end
}
end
def self.udp_server_loop_on(sockets, &b) # :yield: msg, msg_src
loop {
readable, _, _ = IO.select(sockets)
udp_server_recv(readable, &b)
}
end
def self.udp_server_loop(host=nil, port, &b) # :yield: message, message_source
udp_server_sockets(host, port) {|sockets|
udp_server_loop_on(sockets, &b)
}
end
class UDPSource
def initialize(remote_address, local_address, &reply_proc)
@remote_address = remote_address
@local_address = local_address
@reply_proc = reply_proc
end
attr_reader :remote_address
attr_reader :local_address
def inspect
"\#<#{self.class}: #{@remote_address.inspect_sockaddr} to #{@local_address.inspect_sockaddr}>".dup
end
def reply(msg)
@reply_proc.call msg
end
end
def self.unix(path) # :yield: socket
addr = Addrinfo.unix(path)
sock = addr.connect
if block_given?
begin
yield sock
ensure
sock.close
end
else
sock
end
end
def self.unix_server_socket(path)
unless unix_socket_abstract_name?(path)
begin
st = File.lstat(path)
rescue Errno::ENOENT
end
if st&.socket? && st.owned?
File.unlink path
end
end
s = Addrinfo.unix(path).listen
if block_given?
begin
yield s
ensure
s.close
unless unix_socket_abstract_name?(path)
File.unlink path
end
end
else
s
end
end
class << self
private
def unix_socket_abstract_name?(path)
/linux/ =~ RUBY_PLATFORM && /\A(\0|\z)/ =~ path
end
end
def self.unix_server_loop(path, &b) # :yield: socket, client_addrinfo
unix_server_socket(path) {|serv|
accept_loop(serv, &b)
}
end
def connect_nonblock(addr, exception: true)
__connect_nonblock(addr, exception)
end
end
class UDPSocket < IPSocket
def recvfrom_nonblock(len, flag = 0, outbuf = nil, exception: true)
__recvfrom_nonblock(len, flag, outbuf, exception)
end
end
class TCPServer < TCPSocket
def accept_nonblock(exception: true)
__accept_nonblock(exception)
end
end
class UNIXServer < UNIXSocket
def accept_nonblock(exception: true)
__accept_nonblock(exception)
end
end if defined?(UNIXSocket)
require("./openssl")
#--
#++
module OpenSSL
class BN
include Comparable
def pretty_print(q)
q.object_group(self) {
q.text ' '
q.text to_i.to_s
}
end
end # BN
end # OpenSSL
##
#--
#++
class Integer
def to_bn
OpenSSL::BN::new(self)
end
end # Integer
#--
#++
module OpenSSL::PKey
if defined?(EC)
class EC::Point
def to_bn(conversion_form = group.point_conversion_form)
OpenSSL::BN.new(to_octet_string(conversion_form), 2)
end
end
end
end
#--
#++
module OpenSSL
class Cipher
%w(AES CAST5 BF DES IDEA RC2 RC4 RC5).each{|name|
klass = Class.new(Cipher){
define_method(:initialize){|*args|
cipher_name = args.inject(name){|n, arg| "#{n}-#{arg}" }
super(cipher_name.downcase)
}
}
const_set(name, klass)
}
%w(128 192 256).each{|keylen|
klass = Class.new(Cipher){
define_method(:initialize){|mode = "CBC"|
super("aes-#{keylen}-#{mode}".downcase)
}
}
const_set("AES#{keylen}", klass)
}
def random_key
str = OpenSSL::Random.random_bytes(self.key_len)
self.key = str
end
def random_iv
str = OpenSSL::Random.random_bytes(self.iv_len)
self.iv = str
end
class Cipher < Cipher; end
deprecate_constant :Cipher
end # Cipher
end # OpenSSL
require("./stringio")
=begin
= Ruby-space definitions that completes C-space funcs for Config
= Info
Copyright (C) 2010  Hiroshi Nakamura <nahi@ruby-lang.org>
= Licence
This program is licensed under the same licence as Ruby.
(See the file 'LICENCE'.)
=end
module OpenSSL
##
class Config
include Enumerable
class << self
##
def parse(string)
c = new()
parse_config(StringIO.new(string)).each do |section, hash|
c[section] = hash
end
c
end
##
alias load new
##
def parse_config(io)
begin
parse_config_lines(io)
rescue ConfigError => e
e.message.replace("error in line #{io.lineno}: " + e.message)
raise
end
end
def get_key_string(data, section, key)
if v = data[section] && data[section][key]
return v
elsif section == 'ENV'
if v = ENV[key]
return v
end
end
if v = data['default'] && data['default'][key]
return v
end
end
private
def parse_config_lines(io)
section = 'default'
data = {section => {}}
while definition = get_definition(io)
definition = clear_comments(definition)
next if definition.empty?
if definition[0] == ?[
if /\[([^\]]*)\]/ =~ definition
section = $1.strip
data[section] ||= {}
else
raise ConfigError, "missing close square bracket"
end
else
if /\A([^:\s]*)(?:::([^:\s]*))?\s*=(.*)\z/ =~ definition
if $2
section = $1
key = $2
else
key = $1
end
value = unescape_value(data, section, $3)
(data[section] ||= {})[key] = value.strip
else
raise ConfigError, "missing equal sign"
end
end
end
data
end
QUOTE_REGEXP_SQ = /\A([^'\\]*(?:\\.[^'\\]*)*)'/
QUOTE_REGEXP_DQ = /\A([^"\\]*(?:""[^"\\]*|\\.[^"\\]*)*)"/
ESCAPE_MAP = {
"r" => "\r",
"n" => "\n",
"b" => "\b",
"t" => "\t",
}
def unescape_value(data, section, value)
scanned = []
while m = value.match(/['"\\$]/)
scanned << m.pre_match
c = m[0]
value = m.post_match
case c
when "'"
if m = value.match(QUOTE_REGEXP_SQ)
scanned << m[1].gsub(/\\(.)/, '\\1')
value = m.post_match
else
break
end
when '"'
if m = value.match(QUOTE_REGEXP_DQ)
scanned << m[1].gsub(/""/, '').gsub(/\\(.)/, '\\1')
value = m.post_match
else
break
end
when "\\"
c = value.slice!(0, 1)
scanned << (ESCAPE_MAP[c] || c)
when "$"
ref, value = extract_reference(value)
refsec = section
if ref.index('::')
refsec, ref = ref.split('::', 2)
end
if v = get_key_string(data, refsec, ref)
scanned << v
else
raise ConfigError, "variable has no value"
end
else
raise 'must not reaced'
end
end
scanned << value
scanned.join
end
def extract_reference(value)
rest = ''
if m = value.match(/\(([^)]*)\)|\{([^}]*)\}/)
value = m[1] || m[2]
rest = m.post_match
elsif [?(, ?{].include?(value[0])
raise ConfigError, "no close brace"
end
if m = value.match(/[a-zA-Z0-9_]*(?:::[a-zA-Z0-9_]*)?/)
return m[0], m.post_match + rest
else
raise
end
end
def clear_comments(line)
if m = line.match(/\A([\t\n\f ]*);.*\z/)
return m[1]
end
scanned = []
while m = line.match(/[#'"\\]/)
scanned << m.pre_match
c = m[0]
line = m.post_match
case c
when '#'
line = nil
break
when "'", '"'
regexp = (c == "'") ? QUOTE_REGEXP_SQ : QUOTE_REGEXP_DQ
scanned << c
if m = line.match(regexp)
scanned << m[0]
line = m.post_match
else
scanned << line
line = nil
break
end
when "\\"
scanned << c
scanned << line.slice!(0, 1)
else
raise 'must not reaced'
end
end
scanned << line
scanned.join
end
def get_definition(io)
if line = get_line(io)
while /[^\\]\\\z/ =~ line
if extra = get_line(io)
line += extra
else
break
end
end
return line.strip
end
end
def get_line(io)
if line = io.gets
line.gsub(/[\r\n]*/, '')
end
end
end
##
def initialize(filename = nil)
@data = {}
if filename
File.open(filename.to_s) do |file|
Config.parse_config(file).each do |section, hash|
self[section] = hash
end
end
end
end
##
def get_value(section, key)
if section.nil?
raise TypeError.new('nil not allowed')
end
section = 'default' if section.empty?
get_key_string(section, key)
end
##
def value(arg1, arg2 = nil)
warn('Config#value is deprecated; use Config#get_value')
if arg2.nil?
section, key = 'default', arg1
else
section, key = arg1, arg2
end
section ||= 'default'
section = 'default' if section.empty?
get_key_string(section, key)
end
##
def add_value(section, key, value)
check_modify
(@data[section] ||= {})[key] = value
end
##
def [](section)
@data[section] || {}
end
##
def section(name)
warn('Config#section is deprecated; use Config#[]')
@data[name] || {}
end
##
def []=(section, pairs)
check_modify
@data[section] ||= {}
pairs.each do |key, value|
self.add_value(section, key, value)
end
end
##
def sections
@data.keys
end
##
def to_s
ary = []
@data.keys.sort.each do |section|
ary << "[ #{section} ]\n"
@data[section].keys.each do |key|
ary << "#{key}=#{@data[section][key]}\n"
end
ary << "\n"
end
ary.join
end
##
def each
@data.each do |section, hash|
hash.each do |key, value|
yield [section, key, value]
end
end
end
##
def inspect
"#<#{self.class.name} sections=#{sections.inspect}>"
end
protected
def data
@data
end
private
def initialize_copy(other)
@data = other.data.dup
end
def check_modify
raise TypeError.new("Insecure: can't modify OpenSSL config") if frozen?
end
def get_key_string(section, key)
Config.get_key_string(@data, section, key)
end
end
end
#--
#++
module OpenSSL
class Digest
alg = %w(MD2 MD4 MD5 MDC2 RIPEMD160 SHA1 SHA224 SHA256 SHA384 SHA512)
if OPENSSL_VERSION_NUMBER < 0x10100000
alg += %w(DSS DSS1 SHA)
end
def self.digest(name, data)
super(data, name)
end
alg.each{|name|
klass = Class.new(self) {
define_method(:initialize, ->(data = nil) {super(name, data)})
}
singleton = (class << klass; self; end)
singleton.class_eval{
define_method(:digest){|data| new.digest(data) }
define_method(:hexdigest){|data| new.hexdigest(data) }
}
const_set(name, klass)
}
class Digest < Digest; end
deprecate_constant :Digest
end # Digest
def Digest(name)
OpenSSL::Digest.const_get(name)
end
module_function :Digest
end # OpenSSL
#--
#++
module OpenSSL
module X509
class ExtensionFactory
def create_extension(*arg)
if arg.size > 1
create_ext(*arg)
else
send("create_ext_from_"+arg[0].class.name.downcase, arg[0])
end
end
def create_ext_from_array(ary)
raise ExtensionError, "unexpected array form" if ary.size > 3
create_ext(ary[0], ary[1], ary[2])
end
def create_ext_from_string(str) # "oid = critical, value"
oid, value = str.split(/=/, 2)
oid.strip!
value.strip!
create_ext(oid, value)
end
def create_ext_from_hash(hash)
create_ext(hash["oid"], hash["value"], hash["critical"])
end
end
class Extension
def ==(other)
return false unless Extension === other
to_der == other.to_der
end
def to_s # "oid = critical, value"
str = self.oid
str << " = "
str << "critical, " if self.critical?
str << self.value.gsub(/\n/, ", ")
end
def to_h # {"oid"=>sn|ln, "value"=>value, "critical"=>true|false}
{"oid"=>self.oid,"value"=>self.value,"critical"=>self.critical?}
end
def to_a
[ self.oid, self.value, self.critical? ]
end
end
class Name
module RFC2253DN
Special = ',=+<>#;'
HexChar = /[0-9a-fA-F]/
HexPair = /#{HexChar}#{HexChar}/
HexString = /#{HexPair}+/
Pair = /\\(?:[#{Special}]|\\|"|#{HexPair})/
StringChar = /[^\\"#{Special}]/
QuoteChar = /[^\\"]/
AttributeType = /[a-zA-Z][0-9a-zA-Z]*|[0-9]+(?:\.[0-9]+)*/
AttributeValue = /
(?!["#])((?:#{StringChar}|#{Pair})*)|
\#(#{HexString})|
"((?:#{QuoteChar}|#{Pair})*)"
/x
TypeAndValue = /\A(#{AttributeType})=#{AttributeValue}/
module_function
def expand_pair(str)
return nil unless str
return str.gsub(Pair){
pair = $&
case pair.size
when 2 then pair[1,1]
when 3 then Integer("0x#{pair[1,2]}").chr
else raise OpenSSL::X509::NameError, "invalid pair: #{str}"
end
}
end
def expand_hexstring(str)
return nil unless str
der = str.gsub(HexPair){$&.to_i(16).chr }
a1 = OpenSSL::ASN1.decode(der)
return a1.value, a1.tag
end
def expand_value(str1, str2, str3)
value = expand_pair(str1)
value, tag = expand_hexstring(str2) unless value
value = expand_pair(str3) unless value
return value, tag
end
def scan(dn)
str = dn
ary = []
while true
if md = TypeAndValue.match(str)
remain = md.post_match
type = md[1]
value, tag = expand_value(md[2], md[3], md[4]) rescue nil
if value
type_and_value = [type, value]
type_and_value.push(tag) if tag
ary.unshift(type_and_value)
if remain.length > 2 && remain[0] == ?,
str = remain[1..-1]
next
elsif remain.length > 2 && remain[0] == ?+
raise OpenSSL::X509::NameError,
"multi-valued RDN is not supported: #{dn}"
elsif remain.empty?
break
end
end
end
msg_dn = dn[0, dn.length - str.length] + " =>" + str
raise OpenSSL::X509::NameError, "malformed RDN: #{msg_dn}"
end
return ary
end
end
class << self
def parse_rfc2253(str, template=OBJECT_TYPE_TEMPLATE)
ary = OpenSSL::X509::Name::RFC2253DN.scan(str)
self.new(ary, template)
end
def parse_openssl(str, template=OBJECT_TYPE_TEMPLATE)
if str.start_with?("/")
ary = str[1..-1].split("/").map { |i| i.split("=", 2) }
else
ary = str.split(",").map { |i| i.strip.split("=", 2) }
end
self.new(ary, template)
end
alias parse parse_openssl
end
def pretty_print(q)
q.object_group(self) {
q.text ' '
q.text to_s(OpenSSL::X509::Name::RFC2253)
}
end
end
class Attribute
def ==(other)
return false unless Attribute === other
to_der == other.to_der
end
end
class StoreContext
def cleanup
warn "(#{caller.first}) OpenSSL::X509::StoreContext#cleanup is deprecated with no replacement" if $VERBOSE
end
end
class Certificate
def pretty_print(q)
q.object_group(self) {
q.breakable
q.text 'subject='; q.pp self.subject; q.text ','; q.breakable
q.text 'issuer='; q.pp self.issuer; q.text ','; q.breakable
q.text 'serial='; q.pp self.serial; q.text ','; q.breakable
q.text 'not_before='; q.pp self.not_before; q.text ','; q.breakable
q.text 'not_after='; q.pp self.not_after
}
end
end
class CRL
def ==(other)
return false unless CRL === other
to_der == other.to_der
end
end
class Revoked
def ==(other)
return false unless Revoked === other
to_der == other.to_der
end
end
class Request
def ==(other)
return false unless Request === other
to_der == other.to_der
end
end
end
end
#--
#= Info
#= Licence
#++
##
module OpenSSL::Buffering
include Enumerable
##
attr_accessor :sync
##
BLOCK_SIZE = 1024*16
##
def initialize(*)
super
@eof = false
@rbuffer = ""
@sync = @io.sync
end
private
##
def fill_rbuff
begin
@rbuffer << self.sysread(BLOCK_SIZE)
rescue Errno::EAGAIN
retry
rescue EOFError
@eof = true
end
end
##
def consume_rbuff(size=nil)
if @rbuffer.empty?
nil
else
size = @rbuffer.size unless size
ret = @rbuffer[0, size]
@rbuffer[0, size] = ""
ret
end
end
public
##
def read(size=nil, buf=nil)
if size == 0
if buf
buf.clear
return buf
else
return ""
end
end
until @eof
break if size && size <= @rbuffer.size
fill_rbuff
end
ret = consume_rbuff(size) || ""
if buf
buf.replace(ret)
ret = buf
end
(size && ret.empty?) ? nil : ret
end
##
def readpartial(maxlen, buf=nil)
if maxlen == 0
if buf
buf.clear
return buf
else
return ""
end
end
if @rbuffer.empty?
begin
return sysread(maxlen, buf)
rescue Errno::EAGAIN
retry
end
end
ret = consume_rbuff(maxlen)
if buf
buf.replace(ret)
ret = buf
end
ret
end
##
def read_nonblock(maxlen, buf=nil, exception: true)
if maxlen == 0
if buf
buf.clear
return buf
else
return ""
end
end
if @rbuffer.empty?
return sysread_nonblock(maxlen, buf, exception: exception)
end
ret = consume_rbuff(maxlen)
if buf
buf.replace(ret)
ret = buf
end
ret
end
##
def gets(eol=$/, limit=nil)
idx = @rbuffer.index(eol)
until @eof
break if idx
fill_rbuff
idx = @rbuffer.index(eol)
end
if eol.is_a?(Regexp)
size = idx ? idx+$&.size : nil
else
size = idx ? idx+eol.size : nil
end
if size && limit && limit >= 0
size = [size, limit].min
end
consume_rbuff(size)
end
##
def each(eol=$/)
while line = self.gets(eol)
yield line
end
end
alias each_line each
##
def readlines(eol=$/)
ary = []
while line = self.gets(eol)
ary << line
end
ary
end
##
def readline(eol=$/)
raise EOFError if eof?
gets(eol)
end
##
def getc
read(1)
end
##
def each_byte # :yields: byte
while c = getc
yield(c.ord)
end
end
##
def readchar
raise EOFError if eof?
getc
end
##
def ungetc(c)
@rbuffer[0,0] = c.chr
end
##
def eof?
fill_rbuff if !@eof && @rbuffer.empty?
@eof && @rbuffer.empty?
end
alias eof eof?
private
##
def do_write(s)
@wbuffer = "" unless defined? @wbuffer
@wbuffer << s
@wbuffer.force_encoding(Encoding::BINARY)
@sync ||= false
if @sync or @wbuffer.size > BLOCK_SIZE
until @wbuffer.empty?
begin
nwrote = syswrite(@wbuffer)
rescue Errno::EAGAIN
retry
end
@wbuffer[0, nwrote] = ""
end
end
end
public
##
def write(*s)
s.inject(0) do |written, str|
do_write(str)
written + str.bytesize
end
end
##
def write_nonblock(s, exception: true)
flush
syswrite_nonblock(s, exception: exception)
end
##
def <<(s)
do_write(s)
self
end
##
def puts(*args)
s = ""
if args.empty?
s << "\n"
end
args.each{|arg|
s << arg.to_s
s.sub!(/(?<!\n)\z/, "\n")
}
do_write(s)
nil
end
##
def print(*args)
s = ""
args.each{ |arg| s << arg.to_s }
do_write(s)
nil
end
##
def printf(s, *args)
do_write(s % args)
nil
end
##
def flush
osync = @sync
@sync = true
do_write ""
return self
ensure
@sync = osync
end
##
def close
flush rescue nil
sysclose
end
end
require("./nonblock")
class IPAddr
IN4MASK = 0xffffffff
IN6MASK = 0xffffffffffffffffffffffffffffffff
IN6FORMAT = (["%.4x"] * 8).join(':')
RE_IPV4ADDRLIKE = %r{
\A
(\d+) \. (\d+) \. (\d+) \. (\d+)
\z
}x
RE_IPV6ADDRLIKE_FULL = %r{
\A
(?:
(?: [\da-f]{1,4} : ){7} [\da-f]{1,4}
|
( (?: [\da-f]{1,4} : ){6} )
(\d+) \. (\d+) \. (\d+) \. (\d+)
)
\z
}xi
RE_IPV6ADDRLIKE_COMPRESSED = %r{
\A
( (?: (?: [\da-f]{1,4} : )* [\da-f]{1,4} )? )
::
( (?:
( (?: [\da-f]{1,4} : )* )
(?:
[\da-f]{1,4}
|
(\d+) \. (\d+) \. (\d+) \. (\d+)
)
)? )
\z
}xi
class Error < ArgumentError; end
class InvalidAddressError < Error; end
class AddressFamilyError < Error; end
class InvalidPrefixError < InvalidAddressError; end
attr_reader :family
def self.new_ntoh(addr)
return new(ntop(addr))
end
def self.ntop(addr)
case addr.size
when 4
s = addr.unpack('C4').join('.')
when 16
s = IN6FORMAT % addr.unpack('n8')
else
raise AddressFamilyError, "unsupported address family"
end
return s
end
def &(other)
return self.clone.set(@addr & coerce_other(other).to_i)
end
def |(other)
return self.clone.set(@addr | coerce_other(other).to_i)
end
def >>(num)
return self.clone.set(@addr >> num)
end
def <<(num)
return self.clone.set(addr_mask(@addr << num))
end
def ~
return self.clone.set(addr_mask(~@addr))
end
def ==(other)
other = coerce_other(other)
rescue
false
else
@family == other.family && @addr == other.to_i
end
def mask(prefixlen)
return self.clone.mask!(prefixlen)
end
def include?(other)
other = coerce_other(other)
if ipv4_mapped?
if (@mask_addr >> 32) != 0xffffffffffffffffffffffff
return false
end
mask_addr = (@mask_addr & IN4MASK)
addr = (@addr & IN4MASK)
family = Socket::AF_INET
else
mask_addr = @mask_addr
addr = @addr
family = @family
end
if other.ipv4_mapped?
other_addr = (other.to_i & IN4MASK)
other_family = Socket::AF_INET
else
other_addr = other.to_i
other_family = other.family
end
if family != other_family
return false
end
return ((addr & mask_addr) == (other_addr & mask_addr))
end
alias === include?
def to_i
return @addr
end
def to_s
str = to_string
return str if ipv4?
str.gsub!(/\b0{1,3}([\da-f]+)\b/i, '\1')
loop do
break if str.sub!(/\A0:0:0:0:0:0:0:0\z/, '::')
break if str.sub!(/\b0:0:0:0:0:0:0\b/, ':')
break if str.sub!(/\b0:0:0:0:0:0\b/, ':')
break if str.sub!(/\b0:0:0:0:0\b/, ':')
break if str.sub!(/\b0:0:0:0\b/, ':')
break if str.sub!(/\b0:0:0\b/, ':')
break if str.sub!(/\b0:0\b/, ':')
break
end
str.sub!(/:{3,}/, '::')
if /\A::(ffff:)?([\da-f]{1,4}):([\da-f]{1,4})\z/i =~ str
str = sprintf('::%s%d.%d.%d.%d', $1, $2.hex / 256, $2.hex % 256, $3.hex / 256, $3.hex % 256)
end
str
end
def to_string
return _to_string(@addr)
end
def hton
case @family
when Socket::AF_INET
return [@addr].pack('N')
when Socket::AF_INET6
return (0..7).map { |i|
(@addr >> (112 - 16 * i)) & 0xffff
}.pack('n8')
else
raise AddressFamilyError, "unsupported address family"
end
end
def ipv4?
return @family == Socket::AF_INET
end
def ipv6?
return @family == Socket::AF_INET6
end
def loopback?
case @family
when Socket::AF_INET
@addr & 0xff000000 == 0x7f000000
when Socket::AF_INET6
@addr == 1
else
raise AddressFamilyError, "unsupported address family"
end
end
def private?
case @family
when Socket::AF_INET
@addr & 0xff000000 == 0x0a000000 ||    # 10.0.0.0/8
@addr & 0xfff00000 == 0xac100000 ||  # 172.16.0.0/12
@addr & 0xffff0000 == 0xc0a80000     # 192.168.0.0/16
when Socket::AF_INET6
@addr & 0xfe00_0000_0000_0000_0000_0000_0000_0000 == 0xfc00_0000_0000_0000_0000_0000_0000_0000
else
raise AddressFamilyError, "unsupported address family"
end
end
def link_local?
case @family
when Socket::AF_INET
@addr & 0xffff0000 == 0xa9fe0000 # 169.254.0.0/16
when Socket::AF_INET6
@addr & 0xffc0_0000_0000_0000_0000_0000_0000_0000 == 0xfe80_0000_0000_0000_0000_0000_0000_0000
else
raise AddressFamilyError, "unsupported address family"
end
end
def ipv4_mapped?
return ipv6? && (@addr >> 32) == 0xffff
end
def ipv4_compat?
warn "IPAddr\##{__callee__} is obsolete", uplevel: 1 if $VERBOSE
_ipv4_compat?
end
def _ipv4_compat?
if !ipv6? || (@addr >> 32) != 0
return false
end
a = (@addr & IN4MASK)
return a != 0 && a != 1
end
private :_ipv4_compat?
def ipv4_mapped
if !ipv4?
raise InvalidAddressError, "not an IPv4 address"
end
return self.clone.set(@addr | 0xffff00000000, Socket::AF_INET6)
end
def ipv4_compat
warn "IPAddr\##{__callee__} is obsolete", uplevel: 1 if $VERBOSE
if !ipv4?
raise InvalidAddressError, "not an IPv4 address"
end
return self.clone.set(@addr, Socket::AF_INET6)
end
def native
if !ipv4_mapped? && !_ipv4_compat?
return self
end
return self.clone.set(@addr & IN4MASK, Socket::AF_INET)
end
def reverse
case @family
when Socket::AF_INET
return _reverse + ".in-addr.arpa"
when Socket::AF_INET6
return ip6_arpa
else
raise AddressFamilyError, "unsupported address family"
end
end
def ip6_arpa
if !ipv6?
raise InvalidAddressError, "not an IPv6 address"
end
return _reverse + ".ip6.arpa"
end
def ip6_int
if !ipv6?
raise InvalidAddressError, "not an IPv6 address"
end
return _reverse + ".ip6.int"
end
def succ
return self.clone.set(@addr + 1, @family)
end
def <=>(other)
other = coerce_other(other)
rescue
nil
else
@addr <=> other.to_i if other.family == @family
end
include Comparable
def eql?(other)
return self.class == other.class && self.hash == other.hash && self == other
end
def hash
return ([@addr, @mask_addr].hash << 1) | (ipv4? ? 0 : 1)
end
def to_range
begin_addr = (@addr & @mask_addr)
case @family
when Socket::AF_INET
end_addr = (@addr | (IN4MASK ^ @mask_addr))
when Socket::AF_INET6
end_addr = (@addr | (IN6MASK ^ @mask_addr))
else
raise AddressFamilyError, "unsupported address family"
end
return clone.set(begin_addr, @family)..clone.set(end_addr, @family)
end
def prefix
case @family
when Socket::AF_INET
n = IN4MASK ^ @mask_addr
i = 32
when Socket::AF_INET6
n = IN6MASK ^ @mask_addr
i = 128
else
raise AddressFamilyError, "unsupported address family"
end
while n.positive?
n >>= 1
i -= 1
end
i
end
def prefix=(prefix)
case prefix
when Integer
mask!(prefix)
else
raise InvalidPrefixError, "prefix must be an integer"
end
end
def inspect
case @family
when Socket::AF_INET
af = "IPv4"
when Socket::AF_INET6
af = "IPv6"
else
raise AddressFamilyError, "unsupported address family"
end
return sprintf("#<%s: %s:%s/%s>", self.class.name,
af, _to_string(@addr), _to_string(@mask_addr))
end
protected
def set(addr, *family)
case family[0] ? family[0] : @family
when Socket::AF_INET
if addr < 0 || addr > IN4MASK
raise InvalidAddressError, "invalid address"
end
when Socket::AF_INET6
if addr < 0 || addr > IN6MASK
raise InvalidAddressError, "invalid address"
end
else
raise AddressFamilyError, "unsupported address family"
end
@addr = addr
if family[0]
@family = family[0]
end
return self
end
def mask!(mask)
case mask
when String
if mask =~ /\A\d+\z/
prefixlen = mask.to_i
else
m = IPAddr.new(mask)
if m.family != @family
raise InvalidPrefixError, "address family is not same"
end
@mask_addr = m.to_i
n = @mask_addr ^ m.instance_variable_get(:@mask_addr)
unless ((n + 1) & n).zero?
raise InvalidPrefixError, "invalid mask #{mask}"
end
@addr &= @mask_addr
return self
end
else
prefixlen = mask
end
case @family
when Socket::AF_INET
if prefixlen < 0 || prefixlen > 32
raise InvalidPrefixError, "invalid length"
end
masklen = 32 - prefixlen
@mask_addr = ((IN4MASK >> masklen) << masklen)
when Socket::AF_INET6
if prefixlen < 0 || prefixlen > 128
raise InvalidPrefixError, "invalid length"
end
masklen = 128 - prefixlen
@mask_addr = ((IN6MASK >> masklen) << masklen)
else
raise AddressFamilyError, "unsupported address family"
end
@addr = ((@addr >> masklen) << masklen)
return self
end
private
def initialize(addr = '::', family = Socket::AF_UNSPEC)
if !addr.kind_of?(String)
case family
when Socket::AF_INET, Socket::AF_INET6
set(addr.to_i, family)
@mask_addr = (family == Socket::AF_INET) ? IN4MASK : IN6MASK
return
when Socket::AF_UNSPEC
raise AddressFamilyError, "address family must be specified"
else
raise AddressFamilyError, "unsupported address family: #{family}"
end
end
prefix, prefixlen = addr.split('/')
if prefix =~ /\A\[(.*)\]\z/i
prefix = $1
family = Socket::AF_INET6
end
@addr = @family = nil
if family == Socket::AF_UNSPEC || family == Socket::AF_INET
@addr = in_addr(prefix)
if @addr
@family = Socket::AF_INET
end
end
if !@addr && (family == Socket::AF_UNSPEC || family == Socket::AF_INET6)
@addr = in6_addr(prefix)
@family = Socket::AF_INET6
end
if family != Socket::AF_UNSPEC && @family != family
raise AddressFamilyError, "address family mismatch"
end
if prefixlen
mask!(prefixlen)
else
@mask_addr = (@family == Socket::AF_INET) ? IN4MASK : IN6MASK
end
rescue InvalidAddressError => e
raise e.class, "#{e.message}: #{addr}"
end
def coerce_other(other)
case other
when IPAddr
other
when String
self.class.new(other)
else
self.class.new(other, @family)
end
end
def in_addr(addr)
case addr
when Array
octets = addr
else
m = RE_IPV4ADDRLIKE.match(addr) or return nil
octets = m.captures
end
octets.inject(0) { |i, s|
(n = s.to_i) < 256 or raise InvalidAddressError, "invalid address"
s.match(/\A0./) and raise InvalidAddressError, "zero-filled number in IPv4 address is ambiguous"
i << 8 | n
}
end
def in6_addr(left)
case left
when RE_IPV6ADDRLIKE_FULL
if $2
addr = in_addr($~[2,4])
left = $1 + ':'
else
addr = 0
end
right = ''
when RE_IPV6ADDRLIKE_COMPRESSED
if $4
left.count(':') <= 6 or raise InvalidAddressError, "invalid address"
addr = in_addr($~[4,4])
left = $1
right = $3 + '0:0'
else
left.count(':') <= ($1.empty? || $2.empty? ? 8 : 7) or
raise InvalidAddressError, "invalid address"
left = $1
right = $2
addr = 0
end
else
raise InvalidAddressError, "invalid address"
end
l = left.split(':')
r = right.split(':')
rest = 8 - l.size - r.size
if rest < 0
return nil
end
(l + Array.new(rest, '0') + r).inject(0) { |i, s|
i << 16 | s.hex
} | addr
end
def addr_mask(addr)
case @family
when Socket::AF_INET
return addr & IN4MASK
when Socket::AF_INET6
return addr & IN6MASK
else
raise AddressFamilyError, "unsupported address family"
end
end
def _reverse
case @family
when Socket::AF_INET
return (0..3).map { |i|
(@addr >> (8 * i)) & 0xff
}.join('.')
when Socket::AF_INET6
return ("%.32x" % @addr).reverse!.gsub!(/.(?!$)/, '\&.')
else
raise AddressFamilyError, "unsupported address family"
end
end
def _to_string(addr)
case @family
when Socket::AF_INET
return (0..3).map { |i|
(addr >> (24 - 8 * i)) & 0xff
}.join('.')
when Socket::AF_INET6
return (("%.32x" % addr).gsub!(/.{4}(?!$)/, '\&:'))
else
raise AddressFamilyError, "unsupported address family"
end
end
end
unless Socket.const_defined? :AF_INET6
class Socket < BasicSocket
AF_INET6 = Object.new
end
class << IPSocket
private
def valid_v6?(addr)
case addr
when IPAddr::RE_IPV6ADDRLIKE_FULL
if $2
$~[2,4].all? {|i| i.to_i < 256 }
else
true
end
when IPAddr::RE_IPV6ADDRLIKE_COMPRESSED
if $4
addr.count(':') <= 6 && $~[4,4].all? {|i| i.to_i < 256}
else
addr.count(':') <= 7
end
else
false
end
end
alias getaddress_orig getaddress
public
def getaddress(s)
if valid_v6?(s)
s
else
getaddress_orig(s)
end
end
end
end
=begin
= Info
'OpenSSL for Ruby 2' project
Copyright (C) 2001 GOTOU YUUZOU <gotoyuzo@notwork.org>
All rights reserved.
= Licence
This program is licensed under the same licence as Ruby.
(See the file 'LICENCE'.)
=end
module OpenSSL
module SSL
class SSLContext
DEFAULT_PARAMS = {
:min_version => OpenSSL::SSL::TLS1_VERSION,
:verify_mode => OpenSSL::SSL::VERIFY_PEER,
:verify_hostname => true,
:options => -> {
opts = OpenSSL::SSL::OP_ALL
opts &= ~OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS
opts |= OpenSSL::SSL::OP_NO_COMPRESSION
opts
}.call
}
if defined?(OpenSSL::PKey::DH)
DEFAULT_2048 = OpenSSL::PKey::DH.new <<-_end_of_pem_
-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEA7E6kBrYiyvmKAMzQ7i8WvwVk9Y/+f8S7sCTN712KkK3cqd1jhJDY
JbrYeNV3kUIKhPxWHhObHKpD1R84UpL+s2b55+iMd6GmL7OYmNIT/FccKhTcveab
VBmZT86BZKYyf45hUF9FOuUM9xPzuK3Vd8oJQvfYMCd7LPC0taAEljQLR4Edf8E6
YoaOffgTf5qxiwkjnlVZQc3whgnEt9FpVMvQ9eknyeGB5KHfayAc3+hUAvI3/Cr3
1bNveX5wInh5GDx1FGhKBZ+s1H+aedudCm7sCgRwv8lKWYGiHzObSma8A86KG+MD
7Lo5JquQ3DlBodj3IDyPrxIv96lvRPFtAwIBAg==
-----END DH PARAMETERS-----
_end_of_pem_
private_constant :DEFAULT_2048
DEFAULT_TMP_DH_CALLBACK = lambda { |ctx, is_export, keylen|
warn "using default DH parameters." if $VERBOSE
DEFAULT_2048
}
end
if !(OpenSSL::OPENSSL_VERSION.start_with?("OpenSSL") &&
OpenSSL::OPENSSL_VERSION_NUMBER >= 0x10100000)
DEFAULT_PARAMS.merge!(
ciphers: %w{
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES256-GCM-SHA384
ECDHE-RSA-AES256-GCM-SHA384
DHE-RSA-AES128-GCM-SHA256
DHE-DSS-AES128-GCM-SHA256
DHE-RSA-AES256-GCM-SHA384
DHE-DSS-AES256-GCM-SHA384
ECDHE-ECDSA-AES128-SHA256
ECDHE-RSA-AES128-SHA256
ECDHE-ECDSA-AES128-SHA
ECDHE-RSA-AES128-SHA
ECDHE-ECDSA-AES256-SHA384
ECDHE-RSA-AES256-SHA384
ECDHE-ECDSA-AES256-SHA
ECDHE-RSA-AES256-SHA
DHE-RSA-AES128-SHA256
DHE-RSA-AES256-SHA256
DHE-RSA-AES128-SHA
DHE-RSA-AES256-SHA
DHE-DSS-AES128-SHA256
DHE-DSS-AES256-SHA256
DHE-DSS-AES128-SHA
DHE-DSS-AES256-SHA
AES128-GCM-SHA256
AES256-GCM-SHA384
AES128-SHA256
AES256-SHA256
AES128-SHA
AES256-SHA
}.join(":"),
)
end
DEFAULT_CERT_STORE = OpenSSL::X509::Store.new
DEFAULT_CERT_STORE.set_default_paths
DEFAULT_CERT_STORE.flags = OpenSSL::X509::V_FLAG_CRL_CHECK_ALL
attr_accessor :tmp_dh_callback
attr_accessor :servername_cb
def initialize(version = nil)
self.options |= OpenSSL::SSL::OP_ALL
self.ssl_version = version if version
end
##
def set_params(params={})
params = DEFAULT_PARAMS.merge(params)
self.options = params.delete(:options) # set before min_version/max_version
params.each{|name, value| self.__send__("#{name}=", value) }
if self.verify_mode != OpenSSL::SSL::VERIFY_NONE
unless self.ca_file or self.ca_path or self.cert_store
self.cert_store = DEFAULT_CERT_STORE
end
end
return params
end
def min_version=(version)
set_minmax_proto_version(version, @max_proto_version ||= nil)
@min_proto_version = version
end
def max_version=(version)
set_minmax_proto_version(@min_proto_version ||= nil, version)
@max_proto_version = version
end
def ssl_version=(meth)
meth = meth.to_s if meth.is_a?(Symbol)
if /(?<type>_client|_server)\z/ =~ meth
meth = $`
if $VERBOSE
warn "#{caller(1, 1)[0]}: method type #{type.inspect} is ignored"
end
end
version = METHODS_MAP[meth.intern] or
raise ArgumentError, "unknown SSL method `%s'" % meth
set_minmax_proto_version(version, version)
@min_proto_version = @max_proto_version = version
end
METHODS_MAP = {
SSLv23: 0,
SSLv2: OpenSSL::SSL::SSL2_VERSION,
SSLv3: OpenSSL::SSL::SSL3_VERSION,
TLSv1: OpenSSL::SSL::TLS1_VERSION,
TLSv1_1: OpenSSL::SSL::TLS1_1_VERSION,
TLSv1_2: OpenSSL::SSL::TLS1_2_VERSION,
}.freeze
private_constant :METHODS_MAP
METHODS = METHODS_MAP.flat_map { |name,|
[name, :"#{name}_client", :"#{name}_server"]
}.freeze
deprecate_constant :METHODS
end
module SocketForwarder
def addr
to_io.addr
end
def peeraddr
to_io.peeraddr
end
def setsockopt(level, optname, optval)
to_io.setsockopt(level, optname, optval)
end
def getsockopt(level, optname)
to_io.getsockopt(level, optname)
end
def fcntl(*args)
to_io.fcntl(*args)
end
def closed?
to_io.closed?
end
def do_not_reverse_lookup=(flag)
to_io.do_not_reverse_lookup = flag
end
end
def verify_certificate_identity(cert, hostname)
should_verify_common_name = true
cert.extensions.each{|ext|
next if ext.oid != "subjectAltName"
ostr = OpenSSL::ASN1.decode(ext.to_der).value.last
sequence = OpenSSL::ASN1.decode(ostr.value)
sequence.value.each{|san|
case san.tag
when 2 # dNSName in GeneralName (RFC5280)
should_verify_common_name = false
return true if verify_hostname(hostname, san.value)
when 7 # iPAddress in GeneralName (RFC5280)
should_verify_common_name = false
if san.value.size == 4 || san.value.size == 16
begin
return true if san.value == IPAddr.new(hostname).hton
rescue IPAddr::InvalidAddressError
end
end
end
}
}
if should_verify_common_name
cert.subject.to_a.each{|oid, value|
if oid == "CN"
return true if verify_hostname(hostname, value)
end
}
end
return false
end
module_function :verify_certificate_identity
def verify_hostname(hostname, san)
return false unless san.ascii_only?
return false unless hostname.ascii_only?
san_parts = san.downcase.split(".")
return san == hostname if san_parts.size < 2
host_parts = hostname.downcase.split(".")
return false unless san_parts.size == host_parts.size
return false unless verify_wildcard(host_parts.shift, san_parts.shift)
san_parts.join(".") == host_parts.join(".")
end
module_function :verify_hostname
def verify_wildcard(domain_component, san_component)
parts = san_component.split("*", -1)
return false if parts.size > 2
return san_component == domain_component if parts.size == 1
return false if domain_component.start_with?("xn--") && san_component != "*"
parts[0].length + parts[1].length < domain_component.length &&
domain_component.start_with?(parts[0]) &&
domain_component.end_with?(parts[1])
end
module_function :verify_wildcard
class SSLSocket
include Buffering
include SocketForwarder
attr_reader :hostname
attr_reader :io
alias :to_io :io
attr_reader :context
attr_accessor :sync_close
def sysclose
return if closed?
stop
io.close if sync_close
end
def post_connection_check(hostname)
if peer_cert.nil?
msg = "Peer verification enabled, but no certificate received."
if using_anon_cipher?
msg += " Anonymous cipher suite #{cipher[0]} was negotiated. " \
"Anonymous suites must be disabled to use peer verification."
end
raise SSLError, msg
end
unless OpenSSL::SSL.verify_certificate_identity(peer_cert, hostname)
raise SSLError, "hostname \"#{hostname}\" does not match the server certificate"
end
return true
end
def session
SSL::Session.new(self)
rescue SSL::Session::SessionError
nil
end
private
def using_anon_cipher?
ctx = OpenSSL::SSL::SSLContext.new
ctx.ciphers = "aNULL"
ctx.ciphers.include?(cipher)
end
def client_cert_cb
@context.client_cert_cb
end
def tmp_dh_callback
@context.tmp_dh_callback || OpenSSL::SSL::SSLContext::DEFAULT_TMP_DH_CALLBACK
end
def tmp_ecdh_callback
@context.tmp_ecdh_callback
end
def session_new_cb
@context.session_new_cb
end
def session_get_cb
@context.session_get_cb
end
end
##
class SSLServer
include SocketForwarder
attr_accessor :start_immediately
def initialize(svr, ctx)
@svr = svr
@ctx = ctx
unless ctx.session_id_context
prng = ::Random.new($0.hash)
session_id = prng.bytes(16).unpack('H*')[0]
@ctx.session_id_context = session_id
end
@start_immediately = true
end
def to_io
@svr
end
def listen(backlog=5)
@svr.listen(backlog)
end
def shutdown(how=Socket::SHUT_RDWR)
@svr.shutdown(how)
end
def accept
sock, = @svr.accept
begin
ssl = OpenSSL::SSL::SSLSocket.new(sock, @ctx)
ssl.sync_close = true
ssl.accept if @start_immediately
ssl
rescue Exception => ex
if ssl
ssl.close
else
sock.close
end
raise ex
end
end
def close
@svr.close
end
end
end
end
#--
#++
module OpenSSL
module PKCS5
module_function
def pbkdf2_hmac(pass, salt, iter, keylen, digest)
OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
length: keylen, hash: digest)
end
def pbkdf2_hmac_sha1(pass, salt, iter, keylen)
pbkdf2_hmac(pass, salt, iter, keylen, "sha1")
end
end
end
=begin
= Info
'OpenSSL for Ruby 2' project
Copyright (C) 2002  Michal Rokos <m.rokos@sh.cvut.cz>
All rights reserved.
= Licence
This program is licensed under the same licence as Ruby.
(See the file 'LICENCE'.)
=end
#--
module URI
module RFC2396_REGEXP
module PATTERN
ALPHA = "a-zA-Z"
ALNUM = "#{ALPHA}\\d"
HEX     = "a-fA-F\\d"
ESCAPED = "%[#{HEX}]{2}"
UNRESERVED = "\\-_.!~*'()#{ALNUM}"
RESERVED = ";/?:@&=+$,\\[\\]"
DOMLABEL = "(?:[#{ALNUM}](?:[-#{ALNUM}]*[#{ALNUM}])?)"
TOPLABEL = "(?:[#{ALPHA}](?:[-#{ALNUM}]*[#{ALNUM}])?)"
HOSTNAME = "(?:#{DOMLABEL}\\.)*#{TOPLABEL}\\.?"
end # PATTERN
end # REGEXP
class RFC2396_Parser
include RFC2396_REGEXP
def initialize(opts = {})
@pattern = initialize_pattern(opts)
@pattern.each_value(&:freeze)
@pattern.freeze
@regexp = initialize_regexp(@pattern)
@regexp.each_value(&:freeze)
@regexp.freeze
end
attr_reader :pattern
attr_reader :regexp
def split(uri)
case uri
when ''
when @regexp[:ABS_URI]
scheme, opaque, userinfo, host, port,
registry, path, query, fragment = $~[1..-1]
if !scheme
raise InvalidURIError,
"bad URI(absolute but no scheme): #{uri}"
end
if !opaque && (!path && (!host && !registry))
raise InvalidURIError,
"bad URI(absolute but no path): #{uri}"
end
when @regexp[:REL_URI]
scheme = nil
opaque = nil
userinfo, host, port, registry,
rel_segment, abs_path, query, fragment = $~[1..-1]
if rel_segment && abs_path
path = rel_segment + abs_path
elsif rel_segment
path = rel_segment
elsif abs_path
path = abs_path
end
else
raise InvalidURIError, "bad URI(is not URI?): #{uri}"
end
path = '' if !path && !opaque # (see RFC2396 Section 5.2)
ret = [
scheme,
userinfo, host, port,         # X
registry,                     # X
path,                         # Y
opaque,                       # Y
query,
fragment
]
return ret
end
def parse(uri)
scheme, userinfo, host, port,
registry, path, opaque, query, fragment = self.split(uri)
if scheme && URI.scheme_list.include?(scheme.upcase)
URI.scheme_list[scheme.upcase].new(scheme, userinfo, host, port,
registry, path, opaque, query,
fragment, self)
else
Generic.new(scheme, userinfo, host, port,
registry, path, opaque, query,
fragment, self)
end
end
def join(*uris)
uris[0] = convert_to_uri(uris[0])
uris.inject :merge
end
def extract(str, schemes = nil)
if block_given?
str.scan(make_regexp(schemes)) { yield $& }
nil
else
result = []
str.scan(make_regexp(schemes)) { result.push $& }
result
end
end
def make_regexp(schemes = nil)
unless schemes
@regexp[:ABS_URI_REF]
else
/(?=#{Regexp.union(*schemes)}:)#{@pattern[:X_ABS_URI]}/x
end
end
def escape(str, unsafe = @regexp[:UNSAFE])
unless unsafe.kind_of?(Regexp)
unsafe = Regexp.new("[#{Regexp.quote(unsafe)}]", false)
end
str.gsub(unsafe) do
us = $&
tmp = ''
us.each_byte do |uc|
tmp << sprintf('%%%02X', uc)
end
tmp
end.force_encoding(Encoding::US_ASCII)
end
def unescape(str, escaped = @regexp[:ESCAPED])
enc = str.encoding
enc = Encoding::UTF_8 if enc == Encoding::US_ASCII
str.gsub(escaped) { [$&[1, 2]].pack('H2').force_encoding(enc) }
end
@@to_s = Kernel.instance_method(:to_s)
def inspect
@@to_s.bind(self).call
end
private
def initialize_pattern(opts = {})
ret = {}
ret[:ESCAPED] = escaped = (opts.delete(:ESCAPED) || PATTERN::ESCAPED)
ret[:UNRESERVED] = unreserved = opts.delete(:UNRESERVED) || PATTERN::UNRESERVED
ret[:RESERVED] = reserved = opts.delete(:RESERVED) || PATTERN::RESERVED
ret[:DOMLABEL] = opts.delete(:DOMLABEL) || PATTERN::DOMLABEL
ret[:TOPLABEL] = opts.delete(:TOPLABEL) || PATTERN::TOPLABEL
ret[:HOSTNAME] = hostname = opts.delete(:HOSTNAME)
ret[:URIC] = uric = "(?:[#{unreserved}#{reserved}]|#{escaped})"
ret[:URIC_NO_SLASH] = uric_no_slash = "(?:[#{unreserved};?:@&=+$,]|#{escaped})"
ret[:QUERY] = query = "#{uric}*"
ret[:FRAGMENT] = fragment = "#{uric}*"
unless hostname
ret[:HOSTNAME] = hostname = "(?:[a-zA-Z0-9\\-.]|%\\h\\h)+"
end
ret[:IPV4ADDR] = ipv4addr = "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"
hex4 = "[#{PATTERN::HEX}]{1,4}"
lastpart = "(?:#{hex4}|#{ipv4addr})"
hexseq1 = "(?:#{hex4}:)*#{hex4}"
hexseq2 = "(?:#{hex4}:)*#{lastpart}"
ret[:IPV6ADDR] = ipv6addr = "(?:#{hexseq2}|(?:#{hexseq1})?::(?:#{hexseq2})?)"
ret[:IPV6REF] = ipv6ref = "\\[#{ipv6addr}\\]"
ret[:HOST] = host = "(?:#{hostname}|#{ipv4addr}|#{ipv6ref})"
ret[:PORT] = port = '\d*'
ret[:HOSTPORT] = hostport = "#{host}(?::#{port})?"
ret[:USERINFO] = userinfo = "(?:[#{unreserved};:&=+$,]|#{escaped})*"
pchar = "(?:[#{unreserved}:@&=+$,]|#{escaped})"
param = "#{pchar}*"
segment = "#{pchar}*(?:;#{param})*"
ret[:PATH_SEGMENTS] = path_segments = "#{segment}(?:/#{segment})*"
server = "(?:#{userinfo}@)?#{hostport}"
ret[:REG_NAME] = reg_name = "(?:[#{unreserved}$,;:@&=+]|#{escaped})+"
authority = "(?:#{server}|#{reg_name})"
ret[:REL_SEGMENT] = rel_segment = "(?:[#{unreserved};@&=+$,]|#{escaped})+"
ret[:SCHEME] = scheme = "[#{PATTERN::ALPHA}][\\-+.#{PATTERN::ALPHA}\\d]*"
ret[:ABS_PATH] = abs_path = "/#{path_segments}"
ret[:REL_PATH] = rel_path = "#{rel_segment}(?:#{abs_path})?"
ret[:NET_PATH] = net_path = "//#{authority}(?:#{abs_path})?"
ret[:HIER_PART] = hier_part = "(?:#{net_path}|#{abs_path})(?:\\?(?:#{query}))?"
ret[:OPAQUE_PART] = opaque_part = "#{uric_no_slash}#{uric}*"
ret[:ABS_URI] = abs_uri = "#{scheme}:(?:#{hier_part}|#{opaque_part})"
ret[:REL_URI] = rel_uri = "(?:#{net_path}|#{abs_path}|#{rel_path})(?:\\?#{query})?"
ret[:URI_REF] = "(?:#{abs_uri}|#{rel_uri})?(?:##{fragment})?"
ret[:X_ABS_URI] = "
(#{scheme}):                           (?# 1: scheme)
(?:
(#{opaque_part})                    (?# 2: opaque)
|
(?:(?:
//(?:
(?:(?:(#{userinfo})@)?        (?# 3: userinfo)
(?:(#{host})(?::(\\d*))?))? (?# 4: host, 5: port)
|
(#{reg_name})                 (?# 6: registry)
)
|
(?!//))                           (?# XXX: '//' is the mark for hostport)
(#{abs_path})?                    (?# 7: path)
)(?:\\?(#{query}))?                 (?# 8: query)
)
(?:\\#(#{fragment}))?                  (?# 9: fragment)
"
ret[:X_REL_URI] = "
(?:
(?:
//
(?:
(?:(#{userinfo})@)?       (?# 1: userinfo)
(#{host})?(?::(\\d*))?  (?# 2: host, 3: port)
|
(#{reg_name})             (?# 4: registry)
)
)
|
(#{rel_segment})              (?# 5: rel_segment)
)?
(#{abs_path})?                  (?# 6: abs_path)
(?:\\?(#{query}))?              (?# 7: query)
(?:\\#(#{fragment}))?           (?# 8: fragment)
"
ret
end
def initialize_regexp(pattern)
ret = {}
ret[:ABS_URI] = Regexp.new('\A\s*' + pattern[:X_ABS_URI] + '\s*\z', Regexp::EXTENDED)
ret[:REL_URI] = Regexp.new('\A\s*' + pattern[:X_REL_URI] + '\s*\z', Regexp::EXTENDED)
ret[:URI_REF]     = Regexp.new(pattern[:URI_REF])
ret[:ABS_URI_REF] = Regexp.new(pattern[:X_ABS_URI], Regexp::EXTENDED)
ret[:REL_URI_REF] = Regexp.new(pattern[:X_REL_URI], Regexp::EXTENDED)
ret[:ESCAPED] = Regexp.new(pattern[:ESCAPED])
ret[:UNSAFE]  = Regexp.new("[^#{pattern[:UNRESERVED]}#{pattern[:RESERVED]}]")
ret[:SCHEME]   = Regexp.new("\\A#{pattern[:SCHEME]}\\z")
ret[:USERINFO] = Regexp.new("\\A#{pattern[:USERINFO]}\\z")
ret[:HOST]     = Regexp.new("\\A#{pattern[:HOST]}\\z")
ret[:PORT]     = Regexp.new("\\A#{pattern[:PORT]}\\z")
ret[:OPAQUE]   = Regexp.new("\\A#{pattern[:OPAQUE_PART]}\\z")
ret[:REGISTRY] = Regexp.new("\\A#{pattern[:REG_NAME]}\\z")
ret[:ABS_PATH] = Regexp.new("\\A#{pattern[:ABS_PATH]}\\z")
ret[:REL_PATH] = Regexp.new("\\A#{pattern[:REL_PATH]}\\z")
ret[:QUERY]    = Regexp.new("\\A#{pattern[:QUERY]}\\z")
ret[:FRAGMENT] = Regexp.new("\\A#{pattern[:FRAGMENT]}\\z")
ret
end
def convert_to_uri(uri)
if uri.is_a?(URI::Generic)
uri
elsif uri = String.try_convert(uri)
parse(uri)
else
raise ArgumentError,
"bad argument (expected URI object or URI string)"
end
end
end # class Parser
end # module URI
module URI
class RFC3986_Parser
RFC3986_URI = /\A(?<URI>(?<scheme>[A-Za-z][+\-.0-9A-Za-z]*):(?<hier-part>\/\/(?<authority>(?:(?<userinfo>(?:%\h\h|[!$&-.0-;=A-Z_a-z~])*)@)?(?<host>(?<IP-literal>\[(?:(?<IPv6address>(?:\h{1,4}:){6}(?<ls32>\h{1,4}:\h{1,4}|(?<IPv4address>(?<dec-octet>[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]|\d)\.\g<dec-octet>\.\g<dec-octet>\.\g<dec-octet>))|::(?:\h{1,4}:){5}\g<ls32>|\h{1,4}?::(?:\h{1,4}:){4}\g<ls32>|(?:(?:\h{1,4}:)?\h{1,4})?::(?:\h{1,4}:){3}\g<ls32>|(?:(?:\h{1,4}:){,2}\h{1,4})?::(?:\h{1,4}:){2}\g<ls32>|(?:(?:\h{1,4}:){,3}\h{1,4})?::\h{1,4}:\g<ls32>|(?:(?:\h{1,4}:){,4}\h{1,4})?::\g<ls32>|(?:(?:\h{1,4}:){,5}\h{1,4})?::\h{1,4}|(?:(?:\h{1,4}:){,6}\h{1,4})?::)|(?<IPvFuture>v\h+\.[!$&-.0-;=A-Z_a-z~]+))\])|\g<IPv4address>|(?<reg-name>(?:%\h\h|[!$&-.0-9;=A-Z_a-z~])+))?(?::(?<port>\d*))?)(?<path-abempty>(?:\/(?<segment>(?:%\h\h|[!$&-.0-;=@-Z_a-z~])*))*)|(?<path-absolute>\/(?:(?<segment-nz>(?:%\h\h|[!$&-.0-;=@-Z_a-z~])+)(?:\/\g<segment>)*)?)|(?<path-rootless>\g<segment-nz>(?:\/\g<segment>)*)|(?<path-empty>))(?:\?(?<query>[^#]*))?(?:\#(?<fragment>(?:%\h\h|[!$&-.0-;=@-Z_a-z~\/?])*))?)\z/
RFC3986_relative_ref = /\A(?<relative-ref>(?<relative-part>\/\/(?<authority>(?:(?<userinfo>(?:%\h\h|[!$&-.0-;=A-Z_a-z~])*)@)?(?<host>(?<IP-literal>\[(?<IPv6address>(?:\h{1,4}:){6}(?<ls32>\h{1,4}:\h{1,4}|(?<IPv4address>(?<dec-octet>[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]|\d)\.\g<dec-octet>\.\g<dec-octet>\.\g<dec-octet>))|::(?:\h{1,4}:){5}\g<ls32>|\h{1,4}?::(?:\h{1,4}:){4}\g<ls32>|(?:(?:\h{1,4}:){,1}\h{1,4})?::(?:\h{1,4}:){3}\g<ls32>|(?:(?:\h{1,4}:){,2}\h{1,4})?::(?:\h{1,4}:){2}\g<ls32>|(?:(?:\h{1,4}:){,3}\h{1,4})?::\h{1,4}:\g<ls32>|(?:(?:\h{1,4}:){,4}\h{1,4})?::\g<ls32>|(?:(?:\h{1,4}:){,5}\h{1,4})?::\h{1,4}|(?:(?:\h{1,4}:){,6}\h{1,4})?::)|(?<IPvFuture>v\h+\.[!$&-.0-;=A-Z_a-z~]+)\])|\g<IPv4address>|(?<reg-name>(?:%\h\h|[!$&-.0-9;=A-Z_a-z~])+))?(?::(?<port>\d*))?)(?<path-abempty>(?:\/(?<segment>(?:%\h\h|[!$&-.0-;=@-Z_a-z~])*))*)|(?<path-absolute>\/(?:(?<segment-nz>(?:%\h\h|[!$&-.0-;=@-Z_a-z~])+)(?:\/\g<segment>)*)?)|(?<path-noscheme>(?<segment-nz-nc>(?:%\h\h|[!$&-.0-9;=@-Z_a-z~])+)(?:\/\g<segment>)*)|(?<path-empty>))(?:\?(?<query>[^#]*))?(?:\#(?<fragment>(?:%\h\h|[!$&-.0-;=@-Z_a-z~\/?])*))?)\z/
attr_reader :regexp
def initialize
@regexp = default_regexp.each_value(&:freeze).freeze
end
def split(uri) #:nodoc:
begin
uri = uri.to_str
rescue NoMethodError
raise InvalidURIError, "bad URI(is not URI?): #{uri.inspect}"
end
uri.ascii_only? or
raise InvalidURIError, "URI must be ascii only #{uri.dump}"
if m = RFC3986_URI.match(uri)
query = m["query".freeze]
scheme = m["scheme".freeze]
opaque = m["path-rootless".freeze]
if opaque
opaque << "?#{query}" if query
[ scheme,
nil, # userinfo
nil, # host
nil, # port
nil, # registry
nil, # path
opaque,
nil, # query
m["fragment".freeze]
]
else # normal
[ scheme,
m["userinfo".freeze],
m["host".freeze],
m["port".freeze],
nil, # registry
(m["path-abempty".freeze] ||
m["path-absolute".freeze] ||
m["path-empty".freeze]),
nil, # opaque
query,
m["fragment".freeze]
]
end
elsif m = RFC3986_relative_ref.match(uri)
[ nil, # scheme
m["userinfo".freeze],
m["host".freeze],
m["port".freeze],
nil, # registry,
(m["path-abempty".freeze] ||
m["path-absolute".freeze] ||
m["path-noscheme".freeze] ||
m["path-empty".freeze]),
nil, # opaque
m["query".freeze],
m["fragment".freeze]
]
else
raise InvalidURIError, "bad URI(is not URI?): #{uri.inspect}"
end
end
def parse(uri)
scheme, userinfo, host, port,
registry, path, opaque, query, fragment = self.split(uri)
scheme_list = URI.scheme_list
if scheme && scheme_list.include?(uc = scheme.upcase)
scheme_list[uc].new(scheme, userinfo, host, port,
registry, path, opaque, query,
fragment, self)
else
Generic.new(scheme, userinfo, host, port,
registry, path, opaque, query,
fragment, self)
end
end
def join(*uris)
uris[0] = convert_to_uri(uris[0])
uris.inject :merge
end
@@to_s = Kernel.instance_method(:to_s)
def inspect
@@to_s.bind(self).call
end
private
def default_regexp
{
SCHEME: /\A[A-Za-z][A-Za-z0-9+\-.]*\z/,
USERINFO: /\A(?:%\h\h|[!$&-.0-;=A-Z_a-z~])*\z/,
HOST: /\A(?:(?<IP-literal>\[(?:(?<IPv6address>(?:\h{1,4}:){6}(?<ls32>\h{1,4}:\h{1,4}|(?<IPv4address>(?<dec-octet>[1-9]\d|1\d{2}|2[0-4]\d|25[0-5]|\d)\.\g<dec-octet>\.\g<dec-octet>\.\g<dec-octet>))|::(?:\h{1,4}:){5}\g<ls32>|\h{,4}::(?:\h{1,4}:){4}\g<ls32>|(?:(?:\h{1,4}:)?\h{1,4})?::(?:\h{1,4}:){3}\g<ls32>|(?:(?:\h{1,4}:){,2}\h{1,4})?::(?:\h{1,4}:){2}\g<ls32>|(?:(?:\h{1,4}:){,3}\h{1,4})?::\h{1,4}:\g<ls32>|(?:(?:\h{1,4}:){,4}\h{1,4})?::\g<ls32>|(?:(?:\h{1,4}:){,5}\h{1,4})?::\h{1,4}|(?:(?:\h{1,4}:){,6}\h{1,4})?::)|(?<IPvFuture>v\h+\.[!$&-.0-;=A-Z_a-z~]+))\])|\g<IPv4address>|(?<reg-name>(?:%\h\h|[!$&-.0-9;=A-Z_a-z~])*))\z/,
ABS_PATH: /\A\/(?:%\h\h|[!$&-.0-;=@-Z_a-z~])*(?:\/(?:%\h\h|[!$&-.0-;=@-Z_a-z~])*)*\z/,
REL_PATH: /\A(?:%\h\h|[!$&-.0-;=@-Z_a-z~])+(?:\/(?:%\h\h|[!$&-.0-;=@-Z_a-z~])*)*\z/,
QUERY: /\A(?:%\h\h|[!$&-.0-;=@-Z_a-z~\/?])*\z/,
FRAGMENT: /\A(?:%\h\h|[!$&-.0-;=@-Z_a-z~\/?])*\z/,
OPAQUE: /\A(?:[^\/].*)?\z/,
PORT: /\A[\x09\x0a\x0c\x0d ]*\d*[\x09\x0a\x0c\x0d ]*\z/,
}
end
def convert_to_uri(uri)
if uri.is_a?(URI::Generic)
uri
elsif uri = String.try_convert(uri)
parse(uri)
else
raise ArgumentError,
"bad argument (expected URI object or URI string)"
end
end
end # class Parser
end # module URI
#--
module URI
REGEXP = RFC2396_REGEXP
Parser = RFC2396_Parser
RFC3986_PARSER = RFC3986_Parser.new
DEFAULT_PARSER = Parser.new
DEFAULT_PARSER.pattern.each_pair do |sym, str|
unless REGEXP::PATTERN.const_defined?(sym)
REGEXP::PATTERN.const_set(sym, str)
end
end
DEFAULT_PARSER.regexp.each_pair do |sym, str|
const_set(sym, str)
end
module Util
def make_components_hash(klass, array_hash)
tmp = {}
if array_hash.kind_of?(Array) &&
array_hash.size == klass.component.size - 1
klass.component[1..-1].each_index do |i|
begin
tmp[klass.component[i + 1]] = array_hash[i].clone
rescue TypeError
tmp[klass.component[i + 1]] = array_hash[i]
end
end
elsif array_hash.kind_of?(Hash)
array_hash.each do |key, value|
begin
tmp[key] = value.clone
rescue TypeError
tmp[key] = value
end
end
else
raise ArgumentError,
"expected Array of or Hash of components of #{klass} (#{klass.component[1..-1].join(', ')})"
end
tmp[:scheme] = klass.to_s.sub(/\A.*::/, '').downcase
return tmp
end
module_function :make_components_hash
end
module Escape
def escape(*arg)
warn "URI.escape is obsolete", uplevel: 1 if $VERBOSE
DEFAULT_PARSER.escape(*arg)
end
alias encode escape
def unescape(*arg)
warn "URI.unescape is obsolete", uplevel: 1 if $VERBOSE
DEFAULT_PARSER.unescape(*arg)
end
alias decode unescape
end # module Escape
extend Escape
include REGEXP
@@schemes = {}
def self.scheme_list
@@schemes
end
class Error < StandardError; end
class InvalidURIError < Error; end
class InvalidComponentError < Error; end
class BadURIError < Error; end
def self.split(uri)
RFC3986_PARSER.split(uri)
end
def self.parse(uri)
RFC3986_PARSER.parse(uri)
end
def self.join(*str)
RFC3986_PARSER.join(*str)
end
def self.extract(str, schemes = nil, &block)
warn "URI.extract is obsolete", uplevel: 1 if $VERBOSE
DEFAULT_PARSER.extract(str, schemes, &block)
end
def self.regexp(schemes = nil)
warn "URI.regexp is obsolete", uplevel: 1 if $VERBOSE
DEFAULT_PARSER.make_regexp(schemes)
end
TBLENCWWWCOMP_ = {}
256.times do |i|
TBLENCWWWCOMP_[-i.chr] = -('%%%02X' % i)
end
TBLENCWWWCOMP_[' '] = '+'
TBLENCWWWCOMP_.freeze
TBLDECWWWCOMP_ = {}
256.times do |i|
h, l = i>>4, i&15
TBLDECWWWCOMP_[-('%%%X%X' % [h, l])] = -i.chr
TBLDECWWWCOMP_[-('%%%x%X' % [h, l])] = -i.chr
TBLDECWWWCOMP_[-('%%%X%x' % [h, l])] = -i.chr
TBLDECWWWCOMP_[-('%%%x%x' % [h, l])] = -i.chr
end
TBLDECWWWCOMP_['+'] = ' '
TBLDECWWWCOMP_.freeze
def self.encode_www_form_component(str, enc=nil)
str = str.to_s.dup
if str.encoding != Encoding::ASCII_8BIT
if enc && enc != Encoding::ASCII_8BIT
str.encode!(Encoding::UTF_8, invalid: :replace, undef: :replace)
str.encode!(enc, fallback: ->(x){"&#{x.ord};"})
end
str.force_encoding(Encoding::ASCII_8BIT)
end
str.gsub!(/[^*\-.0-9A-Z_a-z]/, TBLENCWWWCOMP_)
str.force_encoding(Encoding::US_ASCII)
end
def self.decode_www_form_component(str, enc=Encoding::UTF_8)
raise ArgumentError, "invalid %-encoding (#{str})" if /%(?!\h\h)/ =~ str
str.b.gsub(/\+|%\h\h/, TBLDECWWWCOMP_).force_encoding(enc)
end
def self.encode_www_form(enum, enc=nil)
enum.map do |k,v|
if v.nil?
encode_www_form_component(k, enc)
elsif v.respond_to?(:to_ary)
v.to_ary.map do |w|
str = encode_www_form_component(k, enc)
unless w.nil?
str << '='
str << encode_www_form_component(w, enc)
end
end.join('&')
else
str = encode_www_form_component(k, enc)
str << '='
str << encode_www_form_component(v, enc)
end
end.join('&')
end
def self.decode_www_form(str, enc=Encoding::UTF_8, separator: '&', use__charset_: false, isindex: false)
raise ArgumentError, "the input of #{self.name}.#{__method__} must be ASCII only string" unless str.ascii_only?
ary = []
return ary if str.empty?
enc = Encoding.find(enc)
str.b.each_line(separator) do |string|
string.chomp!(separator)
key, sep, val = string.partition('=')
if isindex
if sep.empty?
val = key
key = +''
end
isindex = false
end
if use__charset_ and key == '_charset_' and e = get_encoding(val)
enc = e
use__charset_ = false
end
key.gsub!(/\+|%\h\h/, TBLDECWWWCOMP_)
if val
val.gsub!(/\+|%\h\h/, TBLDECWWWCOMP_)
else
val = +''
end
ary << [key, val]
end
ary.each do |k, v|
k.force_encoding(enc)
k.scrub!
v.force_encoding(enc)
v.scrub!
end
ary
end
private
=begin command for WEB_ENCODINGS_
curl https://encoding.spec.whatwg.org/encodings.json|
ruby -rjson -e 'H={}
h={
"shift_jis"=>"Windows-31J",
"euc-jp"=>"cp51932",
"iso-2022-jp"=>"cp50221",
"x-mac-cyrillic"=>"macCyrillic",
}
JSON($<.read).map{|x|x["encodings"]}.flatten.each{|x|
Encoding.find(n=h.fetch(n=x["name"].downcase,n))rescue next
x["labels"].each{|y|H[y]=n}
}
puts "{"
H.each{|k,v|puts %[  #{k.dump}=>#{v.dump},]}
puts "}"
'
=end
WEB_ENCODINGS_ = {
"unicode-1-1-utf-8"=>"utf-8",
"utf-8"=>"utf-8",
"utf8"=>"utf-8",
"866"=>"ibm866",
"cp866"=>"ibm866",
"csibm866"=>"ibm866",
"ibm866"=>"ibm866",
"csisolatin2"=>"iso-8859-2",
"iso-8859-2"=>"iso-8859-2",
"iso-ir-101"=>"iso-8859-2",
"iso8859-2"=>"iso-8859-2",
"iso88592"=>"iso-8859-2",
"iso_8859-2"=>"iso-8859-2",
"iso_8859-2:1987"=>"iso-8859-2",
"l2"=>"iso-8859-2",
"latin2"=>"iso-8859-2",
"csisolatin3"=>"iso-8859-3",
"iso-8859-3"=>"iso-8859-3",
"iso-ir-109"=>"iso-8859-3",
"iso8859-3"=>"iso-8859-3",
"iso88593"=>"iso-8859-3",
"iso_8859-3"=>"iso-8859-3",
"iso_8859-3:1988"=>"iso-8859-3",
"l3"=>"iso-8859-3",
"latin3"=>"iso-8859-3",
"csisolatin4"=>"iso-8859-4",
"iso-8859-4"=>"iso-8859-4",
"iso-ir-110"=>"iso-8859-4",
"iso8859-4"=>"iso-8859-4",
"iso88594"=>"iso-8859-4",
"iso_8859-4"=>"iso-8859-4",
"iso_8859-4:1988"=>"iso-8859-4",
"l4"=>"iso-8859-4",
"latin4"=>"iso-8859-4",
"csisolatincyrillic"=>"iso-8859-5",
"cyrillic"=>"iso-8859-5",
"iso-8859-5"=>"iso-8859-5",
"iso-ir-144"=>"iso-8859-5",
"iso8859-5"=>"iso-8859-5",
"iso88595"=>"iso-8859-5",
"iso_8859-5"=>"iso-8859-5",
"iso_8859-5:1988"=>"iso-8859-5",
"arabic"=>"iso-8859-6",
"asmo-708"=>"iso-8859-6",
"csiso88596e"=>"iso-8859-6",
"csiso88596i"=>"iso-8859-6",
"csisolatinarabic"=>"iso-8859-6",
"ecma-114"=>"iso-8859-6",
"iso-8859-6"=>"iso-8859-6",
"iso-8859-6-e"=>"iso-8859-6",
"iso-8859-6-i"=>"iso-8859-6",
"iso-ir-127"=>"iso-8859-6",
"iso8859-6"=>"iso-8859-6",
"iso88596"=>"iso-8859-6",
"iso_8859-6"=>"iso-8859-6",
"iso_8859-6:1987"=>"iso-8859-6",
"csisolatingreek"=>"iso-8859-7",
"ecma-118"=>"iso-8859-7",
"elot_928"=>"iso-8859-7",
"greek"=>"iso-8859-7",
"greek8"=>"iso-8859-7",
"iso-8859-7"=>"iso-8859-7",
"iso-ir-126"=>"iso-8859-7",
"iso8859-7"=>"iso-8859-7",
"iso88597"=>"iso-8859-7",
"iso_8859-7"=>"iso-8859-7",
"iso_8859-7:1987"=>"iso-8859-7",
"sun_eu_greek"=>"iso-8859-7",
"csiso88598e"=>"iso-8859-8",
"csisolatinhebrew"=>"iso-8859-8",
"hebrew"=>"iso-8859-8",
"iso-8859-8"=>"iso-8859-8",
"iso-8859-8-e"=>"iso-8859-8",
"iso-ir-138"=>"iso-8859-8",
"iso8859-8"=>"iso-8859-8",
"iso88598"=>"iso-8859-8",
"iso_8859-8"=>"iso-8859-8",
"iso_8859-8:1988"=>"iso-8859-8",
"visual"=>"iso-8859-8",
"csisolatin6"=>"iso-8859-10",
"iso-8859-10"=>"iso-8859-10",
"iso-ir-157"=>"iso-8859-10",
"iso8859-10"=>"iso-8859-10",
"iso885910"=>"iso-8859-10",
"l6"=>"iso-8859-10",
"latin6"=>"iso-8859-10",
"iso-8859-13"=>"iso-8859-13",
"iso8859-13"=>"iso-8859-13",
"iso885913"=>"iso-8859-13",
"iso-8859-14"=>"iso-8859-14",
"iso8859-14"=>"iso-8859-14",
"iso885914"=>"iso-8859-14",
"csisolatin9"=>"iso-8859-15",
"iso-8859-15"=>"iso-8859-15",
"iso8859-15"=>"iso-8859-15",
"iso885915"=>"iso-8859-15",
"iso_8859-15"=>"iso-8859-15",
"l9"=>"iso-8859-15",
"iso-8859-16"=>"iso-8859-16",
"cskoi8r"=>"koi8-r",
"koi"=>"koi8-r",
"koi8"=>"koi8-r",
"koi8-r"=>"koi8-r",
"koi8_r"=>"koi8-r",
"koi8-ru"=>"koi8-u",
"koi8-u"=>"koi8-u",
"dos-874"=>"windows-874",
"iso-8859-11"=>"windows-874",
"iso8859-11"=>"windows-874",
"iso885911"=>"windows-874",
"tis-620"=>"windows-874",
"windows-874"=>"windows-874",
"cp1250"=>"windows-1250",
"windows-1250"=>"windows-1250",
"x-cp1250"=>"windows-1250",
"cp1251"=>"windows-1251",
"windows-1251"=>"windows-1251",
"x-cp1251"=>"windows-1251",
"ansi_x3.4-1968"=>"windows-1252",
"ascii"=>"windows-1252",
"cp1252"=>"windows-1252",
"cp819"=>"windows-1252",
"csisolatin1"=>"windows-1252",
"ibm819"=>"windows-1252",
"iso-8859-1"=>"windows-1252",
"iso-ir-100"=>"windows-1252",
"iso8859-1"=>"windows-1252",
"iso88591"=>"windows-1252",
"iso_8859-1"=>"windows-1252",
"iso_8859-1:1987"=>"windows-1252",
"l1"=>"windows-1252",
"latin1"=>"windows-1252",
"us-ascii"=>"windows-1252",
"windows-1252"=>"windows-1252",
"x-cp1252"=>"windows-1252",
"cp1253"=>"windows-1253",
"windows-1253"=>"windows-1253",
"x-cp1253"=>"windows-1253",
"cp1254"=>"windows-1254",
"csisolatin5"=>"windows-1254",
"iso-8859-9"=>"windows-1254",
"iso-ir-148"=>"windows-1254",
"iso8859-9"=>"windows-1254",
"iso88599"=>"windows-1254",
"iso_8859-9"=>"windows-1254",
"iso_8859-9:1989"=>"windows-1254",
"l5"=>"windows-1254",
"latin5"=>"windows-1254",
"windows-1254"=>"windows-1254",
"x-cp1254"=>"windows-1254",
"cp1255"=>"windows-1255",
"windows-1255"=>"windows-1255",
"x-cp1255"=>"windows-1255",
"cp1256"=>"windows-1256",
"windows-1256"=>"windows-1256",
"x-cp1256"=>"windows-1256",
"cp1257"=>"windows-1257",
"windows-1257"=>"windows-1257",
"x-cp1257"=>"windows-1257",
"cp1258"=>"windows-1258",
"windows-1258"=>"windows-1258",
"x-cp1258"=>"windows-1258",
"x-mac-cyrillic"=>"macCyrillic",
"x-mac-ukrainian"=>"macCyrillic",
"chinese"=>"gbk",
"csgb2312"=>"gbk",
"csiso58gb231280"=>"gbk",
"gb2312"=>"gbk",
"gb_2312"=>"gbk",
"gb_2312-80"=>"gbk",
"gbk"=>"gbk",
"iso-ir-58"=>"gbk",
"x-gbk"=>"gbk",
"gb18030"=>"gb18030",
"big5"=>"big5",
"big5-hkscs"=>"big5",
"cn-big5"=>"big5",
"csbig5"=>"big5",
"x-x-big5"=>"big5",
"cseucpkdfmtjapanese"=>"cp51932",
"euc-jp"=>"cp51932",
"x-euc-jp"=>"cp51932",
"csiso2022jp"=>"cp50221",
"iso-2022-jp"=>"cp50221",
"csshiftjis"=>"Windows-31J",
"ms932"=>"Windows-31J",
"ms_kanji"=>"Windows-31J",
"shift-jis"=>"Windows-31J",
"shift_jis"=>"Windows-31J",
"sjis"=>"Windows-31J",
"windows-31j"=>"Windows-31J",
"x-sjis"=>"Windows-31J",
"cseuckr"=>"euc-kr",
"csksc56011987"=>"euc-kr",
"euc-kr"=>"euc-kr",
"iso-ir-149"=>"euc-kr",
"korean"=>"euc-kr",
"ks_c_5601-1987"=>"euc-kr",
"ks_c_5601-1989"=>"euc-kr",
"ksc5601"=>"euc-kr",
"ksc_5601"=>"euc-kr",
"windows-949"=>"euc-kr",
"utf-16be"=>"utf-16be",
"utf-16"=>"utf-16le",
"utf-16le"=>"utf-16le",
}

def self.get_encoding(label)
Encoding.find(WEB_ENCODINGS_[label.to_str.strip.downcase]) rescue nil
end
end # module URI
module Kernel
def URI(uri)
if uri.is_a?(URI::Generic)
uri
elsif uri = String.try_convert(uri)
URI.parse(uri)
else
raise ArgumentError,
"bad argument (expected URI object or URI string)"
end
end
module_function :URI
end
autoload :IPSocket, 'socket'
autoload :IPAddr, 'ipaddr'
module URI
class Generic
include URI
DEFAULT_PORT = nil
def self.default_port
self::DEFAULT_PORT
end
def default_port
self.class.default_port
end
COMPONENT = [
:scheme,
:userinfo, :host, :port, :registry,
:path, :opaque,
:query,
:fragment
].freeze
def self.component
self::COMPONENT
end
USE_REGISTRY = false
def self.use_registry
self::USE_REGISTRY
end
def self.build2(args)
begin
return self.build(args)
rescue InvalidComponentError
if args.kind_of?(Array)
return self.build(args.collect{|x|
if x.is_a?(String)
DEFAULT_PARSER.escape(x)
else
x
end
})
elsif args.kind_of?(Hash)
tmp = {}
args.each do |key, value|
tmp[key] = if value
DEFAULT_PARSER.escape(value)
else
value
end
end
return self.build(tmp)
end
end
end
def self.build(args)
if args.kind_of?(Array) &&
args.size == ::URI::Generic::COMPONENT.size
tmp = args.dup
elsif args.kind_of?(Hash)
tmp = ::URI::Generic::COMPONENT.collect do |c|
if args.include?(c)
args[c]
else
nil
end
end
else
component = self.class.component rescue ::URI::Generic::COMPONENT
raise ArgumentError,
"expected Array of or Hash of components of #{self.class} (#{component.join(', ')})"
end
tmp << nil
tmp << true
return self.new(*tmp)
end
def initialize(scheme,
userinfo, host, port, registry,
path, opaque,
query,
fragment,
parser = DEFAULT_PARSER,
arg_check = false)
@scheme = nil
@user = nil
@password = nil
@host = nil
@port = nil
@path = nil
@query = nil
@opaque = nil
@fragment = nil
@parser = parser == DEFAULT_PARSER ? nil : parser
if arg_check
self.scheme = scheme
self.userinfo = userinfo
self.hostname = host
self.port = port
self.path = path
self.query = query
self.opaque = opaque
self.fragment = fragment
else
self.set_scheme(scheme)
self.set_userinfo(userinfo)
self.set_host(host)
self.set_port(port)
self.set_path(path)
self.query = query
self.set_opaque(opaque)
self.fragment=(fragment)
end
if registry
raise InvalidURIError,
"the scheme #{@scheme} does not accept registry part: #{registry} (or bad hostname?)"
end
@scheme&.freeze
self.set_path('') if !@path && !@opaque # (see RFC2396 Section 5.2)
self.set_port(self.default_port) if self.default_port && !@port
end
attr_reader :scheme
attr_reader :host
attr_reader :port
def registry
nil
end
attr_reader :path
attr_reader :query
attr_reader :opaque
attr_reader :fragment
def parser
if !defined?(@parser) || !@parser
DEFAULT_PARSER
else
@parser || DEFAULT_PARSER
end
end
def replace!(oth)
if self.class != oth.class
raise ArgumentError, "expected #{self.class} object"
end
component.each do |c|
self.__send__("#{c}=", oth.__send__(c))
end
end
private :replace!
def component
self.class.component
end
def check_scheme(v)
if v && parser.regexp[:SCHEME] !~ v
raise InvalidComponentError,
"bad component(expected scheme component): #{v}"
end
return true
end
private :check_scheme
def set_scheme(v)
@scheme = v&.downcase
end
protected :set_scheme
def scheme=(v)
check_scheme(v)
set_scheme(v)
v
end
def check_userinfo(user, password = nil)
if !password
user, password = split_userinfo(user)
end
check_user(user)
check_password(password, user)
return true
end
private :check_userinfo
def check_user(v)
if @opaque
raise InvalidURIError,
"can not set user with opaque"
end
return v unless v
if parser.regexp[:USERINFO] !~ v
raise InvalidComponentError,
"bad component(expected userinfo component or user component): #{v}"
end
return true
end
private :check_user
def check_password(v, user = @user)
if @opaque
raise InvalidURIError,
"can not set password with opaque"
end
return v unless v
if !user
raise InvalidURIError,
"password component depends user component"
end
if parser.regexp[:USERINFO] !~ v
raise InvalidComponentError,
"bad password component"
end
return true
end
private :check_password
def userinfo=(userinfo)
if userinfo.nil?
return nil
end
check_userinfo(*userinfo)
set_userinfo(*userinfo)
end
def user=(user)
check_user(user)
set_user(user)
end
def password=(password)
check_password(password)
set_password(password)
end
def set_userinfo(user, password = nil)
unless password
user, password = split_userinfo(user)
end
@user     = user
@password = password if password
[@user, @password]
end
protected :set_userinfo
def set_user(v)
set_userinfo(v, @password)
v
end
protected :set_user
def set_password(v)
@password = v
end
protected :set_password
def split_userinfo(ui)
return nil, nil unless ui
user, password = ui.split(':', 2)
return user, password
end
private :split_userinfo
def escape_userpass(v)
parser.escape(v, /[@:\/]/o) # RFC 1738 section 3.1 #/
end
private :escape_userpass
def userinfo
if @user.nil?
nil
elsif @password.nil?
@user
else
@user + ':' + @password
end
end
def user
@user
end
def password
@password
end
def check_host(v)
return v unless v
if @opaque
raise InvalidURIError,
"can not set host with registry or opaque"
elsif parser.regexp[:HOST] !~ v
raise InvalidComponentError,
"bad component(expected host component): #{v}"
end
return true
end
private :check_host
def set_host(v)
@host = v
end
protected :set_host
def host=(v)
check_host(v)
set_host(v)
v
end
def hostname
v = self.host
/\A\[(.*)\]\z/ =~ v ? $1 : v
end
def hostname=(v)
v = "[#{v}]" if /\A\[.*\]\z/ !~ v && /:/ =~ v
self.host = v
end
def check_port(v)
return v unless v
if @opaque
raise InvalidURIError,
"can not set port with registry or opaque"
elsif !v.kind_of?(Integer) && parser.regexp[:PORT] !~ v
raise InvalidComponentError,
"bad component(expected port component): #{v.inspect}"
end
return true
end
private :check_port
def set_port(v)
v = v.empty? ? nil : v.to_i unless !v || v.kind_of?(Integer)
@port = v
end
protected :set_port
def port=(v)
check_port(v)
set_port(v)
port
end
def check_registry(v)
raise InvalidURIError, "can not set registry"
end
private :check_registry
def set_registry(v) #:nodoc:
raise InvalidURIError, "can not set registry"
end
protected :set_registry
def registry=(v)
raise InvalidURIError, "can not set registry"
end
def check_path(v)
if v && @opaque
raise InvalidURIError,
"path conflicts with opaque"
end
if @scheme && @scheme != "ftp"
if v && v != '' && parser.regexp[:ABS_PATH] !~ v
raise InvalidComponentError,
"bad component(expected absolute path component): #{v}"
end
else
if v && v != '' && parser.regexp[:ABS_PATH] !~ v &&
parser.regexp[:REL_PATH] !~ v
raise InvalidComponentError,
"bad component(expected relative path component): #{v}"
end
end
return true
end
private :check_path
def set_path(v)
@path = v
end
protected :set_path
def path=(v)
check_path(v)
set_path(v)
v
end
def query=(v)
return @query = nil unless v
raise InvalidURIError, "query conflicts with opaque" if @opaque
x = v.to_str
v = x.dup if x.equal? v
v.encode!(Encoding::UTF_8) rescue nil
v.delete!("\t\r\n")
v.force_encoding(Encoding::ASCII_8BIT)
v.gsub!(/(?!%\h\h|[!$-&(-;=?-_a-~])./n.freeze){'%%%02X' % $&.ord}
v.force_encoding(Encoding::US_ASCII)
@query = v
end
def check_opaque(v)
return v unless v
if @host || @port || @user || @path  # userinfo = @user + ':' + @password
raise InvalidURIError,
"can not set opaque with host, port, userinfo or path"
elsif v && parser.regexp[:OPAQUE] !~ v
raise InvalidComponentError,
"bad component(expected opaque component): #{v}"
end
return true
end
private :check_opaque
def set_opaque(v)
@opaque = v
end
protected :set_opaque
def opaque=(v)
check_opaque(v)
set_opaque(v)
v
end
def fragment=(v)
return @fragment = nil unless v
x = v.to_str
v = x.dup if x.equal? v
v.encode!(Encoding::UTF_8) rescue nil
v.delete!("\t\r\n")
v.force_encoding(Encoding::ASCII_8BIT)
v.gsub!(/(?!%\h\h|[!-~])./n){'%%%02X' % $&.ord}
v.force_encoding(Encoding::US_ASCII)
@fragment = v
end
def hierarchical?
if @path
true
else
false
end
end
def absolute?
if @scheme
true
else
false
end
end
alias absolute absolute?
def relative?
!absolute?
end
def split_path(path)
path.split("/", -1)
end
private :split_path
def merge_path(base, rel)
base_path = split_path(base)
rel_path  = split_path(rel)
base_path << '' if base_path.last == '..'
while i = base_path.index('..')
base_path.slice!(i - 1, 2)
end
if (first = rel_path.first) and first.empty?
base_path.clear
rel_path.shift
end
rel_path.push('') if rel_path.last == '.' || rel_path.last == '..'
rel_path.delete('.')
tmp = []
rel_path.each do |x|
if x == '..' &&
!(tmp.empty? || tmp.last == '..')
tmp.pop
else
tmp << x
end
end
add_trailer_slash = !tmp.empty?
if base_path.empty?
base_path = [''] # keep '/' for root directory
elsif add_trailer_slash
base_path.pop
end
while x = tmp.shift
if x == '..'
base_path.pop if base_path.size > 1
else
base_path << x
tmp.each {|t| base_path << t}
add_trailer_slash = false
break
end
end
base_path.push('') if add_trailer_slash
return base_path.join('/')
end
private :merge_path
def merge!(oth)
t = merge(oth)
if self == t
nil
else
replace!(t)
self
end
end
def merge(oth)
rel = parser.send(:convert_to_uri, oth)
if rel.absolute?
return rel
end
unless self.absolute?
raise BadURIError, "both URI are relative"
end
base = self.dup
authority = rel.userinfo || rel.host || rel.port
if (rel.path.nil? || rel.path.empty?) && !authority && !rel.query
base.fragment=(rel.fragment) if rel.fragment
return base
end
base.query = nil
base.fragment=(nil)
if !authority
base.set_path(merge_path(base.path, rel.path)) if base.path && rel.path
else
base.set_path(rel.path) if rel.path
end
base.set_userinfo(rel.userinfo) if rel.userinfo
base.set_host(rel.host)         if rel.host
base.set_port(rel.port)         if rel.port
base.query = rel.query       if rel.query
base.fragment=(rel.fragment) if rel.fragment
return base
end # merge
alias + merge
def route_from_path(src, dst)
case dst
when src
return ''
when %r{(?:\A|/)\.\.?(?:/|\z)}
return dst.dup
end
src_path = src.scan(%r{[^/]*/})
dst_path = dst.scan(%r{[^/]*/?})
while !dst_path.empty? && dst_path.first == src_path.first
src_path.shift
dst_path.shift
end
tmp = dst_path.join
if src_path.empty?
if tmp.empty?
return './'
elsif dst_path.first.include?(':') # (see RFC2396 Section 5)
return './' + tmp
else
return tmp
end
end
return '../' * src_path.size + tmp
end
private :route_from_path
def route_from0(oth)
oth = parser.send(:convert_to_uri, oth)
if self.relative?
raise BadURIError,
"relative URI: #{self}"
end
if oth.relative?
raise BadURIError,
"relative URI: #{oth}"
end
if self.scheme != oth.scheme
return self, self.dup
end
rel = URI::Generic.new(nil, # it is relative URI
self.userinfo, self.host, self.port,
nil, self.path, self.opaque,
self.query, self.fragment, parser)
if rel.userinfo != oth.userinfo ||
rel.host.to_s.downcase != oth.host.to_s.downcase ||
rel.port != oth.port
if self.userinfo.nil? && self.host.nil?
return self, self.dup
end
rel.set_port(nil) if rel.port == oth.default_port
return rel, rel
end
rel.set_userinfo(nil)
rel.set_host(nil)
rel.set_port(nil)
if rel.path && rel.path == oth.path
rel.set_path('')
rel.query = nil if rel.query == oth.query
return rel, rel
elsif rel.opaque && rel.opaque == oth.opaque
rel.set_opaque('')
rel.query = nil if rel.query == oth.query
return rel, rel
end
return oth, rel
end
private :route_from0
def route_from(oth)
begin
oth, rel = route_from0(oth)
rescue
raise $!.class, $!.message
end
if oth == rel
return rel
end
rel.set_path(route_from_path(oth.path, self.path))
if rel.path == './' && self.query
rel.set_path('')
end
return rel
end
alias - route_from
def route_to(oth)
parser.send(:convert_to_uri, oth).route_from(self)
end
def normalize
uri = dup
uri.normalize!
uri
end
def normalize!
if path&.empty?
set_path('/')
end
if scheme && scheme != scheme.downcase
set_scheme(self.scheme.downcase)
end
if host && host != host.downcase
set_host(self.host.downcase)
end
end
def to_s
str = ''.dup
if @scheme
str << @scheme
str << ':'
end
if @opaque
str << @opaque
else
if @host || %w[file postgres].include?(@scheme)
str << '//'
end
if self.userinfo
str << self.userinfo
str << '@'
end
if @host
str << @host
end
if @port && @port != self.default_port
str << ':'
str << @port.to_s
end
str << @path
if @query
str << '?'
str << @query
end
end
if @fragment
str << '#'
str << @fragment
end
str
end
def ==(oth)
if self.class == oth.class
self.normalize.component_ary == oth.normalize.component_ary
else
false
end
end
def hash
self.component_ary.hash
end
def eql?(oth)
self.class == oth.class &&
parser == oth.parser &&
self.component_ary.eql?(oth.component_ary)
end
=begin
--- URI::Generic#===(oth)
=end
=begin
=end
def component_ary
component.collect do |x|
self.send(x)
end
end
protected :component_ary
def select(*components)
components.collect do |c|
if component.include?(c)
self.send(c)
else
raise ArgumentError,
"expected of components of #{self.class} (#{self.class.component.join(', ')})"
end
end
end
def inspect
"#<#{self.class} #{self}>"
end
def coerce(oth)
case oth
when String
oth = parser.parse(oth)
else
super
end
return oth, self
end
def find_proxy(env=ENV)
raise BadURIError, "relative URI: #{self}" if self.relative?
name = self.scheme.downcase + '_proxy'
proxy_uri = nil
if name == 'http_proxy' && env.include?('REQUEST_METHOD') # CGI?
pairs = env.reject {|k, v| /\Ahttp_proxy\z/i !~ k }
case pairs.length
when 0 # no proxy setting anyway.
proxy_uri = nil
when 1
k, _ = pairs.shift
if k == 'http_proxy' && env[k.upcase] == nil
proxy_uri = env[name]
else
proxy_uri = nil
end
else # http_proxy is safe to use because ENV is case sensitive.
proxy_uri = env.to_hash[name]
end
if !proxy_uri
proxy_uri = env["CGI_#{name.upcase}"]
end
elsif name == 'http_proxy'
unless proxy_uri = env[name]
if proxy_uri = env[name.upcase]
warn 'The environment variable HTTP_PROXY is discouraged.  Use http_proxy.', uplevel: 1
end
end
else
proxy_uri = env[name] || env[name.upcase]
end
if proxy_uri.nil? || proxy_uri.empty?
return nil
end
if self.hostname
begin
addr = IPSocket.getaddress(self.hostname)
return nil if /\A127\.|\A::1\z/ =~ addr
rescue SocketError
end
end
name = 'no_proxy'
if no_proxy = env[name] || env[name.upcase]
return nil unless URI::Generic.use_proxy?(self.hostname, addr, self.port, no_proxy)
end
URI.parse(proxy_uri)
end
def self.use_proxy?(hostname, addr, port, no_proxy)
hostname = hostname.downcase
dothostname = ".#{hostname}"
no_proxy.scan(/([^:,\s]+)(?::(\d+))?/) {|p_host, p_port|
if !p_port || port == p_port.to_i
if p_host.start_with?('.')
return false if hostname.end_with?(p_host.downcase)
else
return false if dothostname.end_with?(".#{p_host.downcase}")
end
if addr
begin
return false if IPAddr.new(p_host).include?(addr)
rescue IPAddr::InvalidAddressError
next
end
end
end
}
true
end
end
end
module URI
class File < Generic
DEFAULT_PORT = nil
COMPONENT = [
:scheme,
:host,
:path
].freeze
def self.build(args)
tmp = Util::make_components_hash(self, args)
super(tmp)
end
def set_host(v)
v = "" if v.nil? || v == "localhost"
@host = v
end
def set_port(v)
end
def check_userinfo(user)
raise URI::InvalidURIError, "can not set userinfo for file URI"
end
def check_user(user)
raise URI::InvalidURIError, "can not set user for file URI"
end
def check_password(user)
raise URI::InvalidURIError, "can not set password for file URI"
end
def set_userinfo(v)
end
def set_user(v)
end
def set_password(v)
end
end
@@schemes['FILE'] = File
end
module URI
class FTP < Generic
DEFAULT_PORT = 21
COMPONENT = [
:scheme,
:userinfo, :host, :port,
:path, :typecode
].freeze
TYPECODE = ['a', 'i', 'd'].freeze
TYPECODE_PREFIX = ';type='.freeze
def self.new2(user, password, host, port, path,
typecode = nil, arg_check = true)
typecode = nil if typecode.size == 0
if typecode && !TYPECODE.include?(typecode)
raise ArgumentError,
"bad typecode is specified: #{typecode}"
end
self.new('ftp',
[user, password],
host, port, nil,
typecode ? path + TYPECODE_PREFIX + typecode : path,
nil, nil, nil, arg_check)
end
def self.build(args)
if args.kind_of?(Array)
args[3] = '/' + args[3].sub(/^\//, '%2F')
else
args[:path] = '/' + args[:path].sub(/^\//, '%2F')
end
tmp = Util::make_components_hash(self, args)
if tmp[:typecode]
if tmp[:typecode].size == 1
tmp[:typecode] = TYPECODE_PREFIX + tmp[:typecode]
end
tmp[:path] << tmp[:typecode]
end
return super(tmp)
end
def initialize(scheme,
userinfo, host, port, registry,
path, opaque,
query,
fragment,
parser = nil,
arg_check = false)
raise InvalidURIError unless path
path = path.sub(/^\//,'')
path.sub!(/^%2F/,'/')
super(scheme, userinfo, host, port, registry, path, opaque,
query, fragment, parser, arg_check)
@typecode = nil
if tmp = @path.index(TYPECODE_PREFIX)
typecode = @path[tmp + TYPECODE_PREFIX.size..-1]
@path = @path[0..tmp - 1]
if arg_check
self.typecode = typecode
else
self.set_typecode(typecode)
end
end
end
attr_reader :typecode
def check_typecode(v)
if TYPECODE.include?(v)
return true
else
raise InvalidComponentError,
"bad typecode(expected #{TYPECODE.join(', ')}): #{v}"
end
end
private :check_typecode
def set_typecode(v)
@typecode = v
end
protected :set_typecode
def typecode=(typecode)
check_typecode(typecode)
set_typecode(typecode)
typecode
end
def merge(oth)
tmp = super(oth)
if self != tmp
tmp.set_typecode(oth.typecode)
end
return tmp
end
def path
return @path.sub(/^\//,'').sub(/^%2F/,'/')
end
def set_path(v)
super("/" + v.sub(/^\//, "%2F"))
end
protected :set_path
def to_s
save_path = nil
if @typecode
save_path = @path
@path = @path + TYPECODE_PREFIX + @typecode
end
str = super
if @typecode
@path = save_path
end
return str
end
end
@@schemes['FTP'] = FTP
end
module URI
class HTTP < Generic
DEFAULT_PORT = 80
COMPONENT = %i[
scheme
userinfo host port
path
query
fragment
].freeze
def self.build(args)
tmp = Util.make_components_hash(self, args)
super(tmp)
end
def request_uri
return unless @path
url = @query ? "#@path?#@query" : @path.dup
url.start_with?(?/.freeze) ? url : ?/ + url
end
end
@@schemes['HTTP'] = HTTP
end
module URI
class HTTPS < HTTP
DEFAULT_PORT = 443
end
@@schemes['HTTPS'] = HTTPS
end
module URI
#--
#++
class LDAP < Generic
DEFAULT_PORT = 389
COMPONENT = [
:scheme,
:host, :port,
:dn,
:attributes,
:scope,
:filter,
:extensions,
].freeze
SCOPE = [
SCOPE_ONE = 'one',
SCOPE_SUB = 'sub',
SCOPE_BASE = 'base',
].freeze
def self.build(args)
tmp = Util::make_components_hash(self, args)
if tmp[:dn]
tmp[:path] = tmp[:dn]
end
query = []
[:extensions, :filter, :scope, :attributes].collect do |x|
next if !tmp[x] && query.size == 0
query.unshift(tmp[x])
end
tmp[:query] = query.join('?')
return super(tmp)
end
def initialize(*arg)
super(*arg)
if @fragment
raise InvalidURIError, 'bad LDAP URL'
end
parse_dn
parse_query
end
def parse_dn
@dn = @path[1..-1]
end
private :parse_dn
def parse_query
@attributes = nil
@scope      = nil
@filter     = nil
@extensions = nil
if @query
attrs, scope, filter, extensions = @query.split('?')
@attributes = attrs if attrs && attrs.size > 0
@scope      = scope if scope && scope.size > 0
@filter     = filter if filter && filter.size > 0
@extensions = extensions if extensions && extensions.size > 0
end
end
private :parse_query
def build_path_query
@path = '/' + @dn
query = []
[@extensions, @filter, @scope, @attributes].each do |x|
next if !x && query.size == 0
query.unshift(x)
end
@query = query.join('?')
end
private :build_path_query
def dn
@dn
end
def set_dn(val)
@dn = val
build_path_query
@dn
end
protected :set_dn
def dn=(val)
set_dn(val)
val
end
def attributes
@attributes
end
def set_attributes(val)
@attributes = val
build_path_query
@attributes
end
protected :set_attributes
def attributes=(val)
set_attributes(val)
val
end
def scope
@scope
end
def set_scope(val)
@scope = val
build_path_query
@scope
end
protected :set_scope
def scope=(val)
set_scope(val)
val
end
def filter
@filter
end
def set_filter(val)
@filter = val
build_path_query
@filter
end
protected :set_filter
def filter=(val)
set_filter(val)
val
end
def extensions
@extensions
end
def set_extensions(val)
@extensions = val
build_path_query
@extensions
end
protected :set_extensions
def extensions=(val)
set_extensions(val)
val
end
def hierarchical?
false
end
end
@@schemes['LDAP'] = LDAP
end
module URI
class LDAPS < LDAP
DEFAULT_PORT = 636
end
@@schemes['LDAPS'] = LDAPS
end
module URI
class MailTo < Generic
include REGEXP
DEFAULT_PORT = nil
COMPONENT = [ :scheme, :to, :headers ].freeze
HEADER_REGEXP  = /\A(?<hfield>(?:%\h\h|[!$'-.0-;@-Z_a-z~])*=(?:%\h\h|[!$'-.0-;@-Z_a-z~])*)(?:&\g<hfield>)*\z/
EMAIL_REGEXP = /\A[a-zA-Z0-9.!\#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\z/
def self.build(args)
tmp = Util.make_components_hash(self, args)
case tmp[:to]
when Array
tmp[:opaque] = tmp[:to].join(',')
when String
tmp[:opaque] = tmp[:to].dup
else
tmp[:opaque] = ''
end
if tmp[:headers]
query =
case tmp[:headers]
when Array
tmp[:headers].collect { |x|
if x.kind_of?(Array)
x[0] + '=' + x[1..-1].join
else
x.to_s
end
}.join('&')
when Hash
tmp[:headers].collect { |h,v|
h + '=' + v
}.join('&')
else
tmp[:headers].to_s
end
unless query.empty?
tmp[:opaque] << '?' << query
end
end
super(tmp)
end
def initialize(*arg)
super(*arg)
@to = nil
@headers = []
@opaque = "?#{@query}" if @query && !@opaque
unless @opaque
raise InvalidComponentError,
"missing opaque part for mailto URL"
end
to, header = @opaque.split('?', 2)
unless /\A(?:[^@,;]+@[^@,;]+(?:\z|[,;]))*\z/ =~ to
raise InvalidComponentError,
"unrecognised opaque part for mailtoURL: #{@opaque}"
end
if arg[10] # arg_check
self.to = to
self.headers = header
else
set_to(to)
set_headers(header)
end
end
attr_reader :to
attr_reader :headers
def check_to(v)
return true unless v
return true if v.size == 0
v.split(/[,;]/).each do |addr|
if /\A(?:%\h\h|[!$&-.0-;=@-Z_a-z~])*\z/ !~ addr
raise InvalidComponentError,
"an address in 'to' is invalid as URI #{addr.dump}"
end
addr.gsub!(/%\h\h/, URI::TBLDECWWWCOMP_)
if EMAIL_REGEXP !~ addr
raise InvalidComponentError,
"an address in 'to' is invalid as uri-escaped addr-spec #{addr.dump}"
end
end
true
end
private :check_to
def set_to(v)
@to = v
end
protected :set_to
def to=(v)
check_to(v)
set_to(v)
v
end
def check_headers(v)
return true unless v
return true if v.size == 0
if HEADER_REGEXP !~ v
raise InvalidComponentError,
"bad component(expected opaque component): #{v}"
end
true
end
private :check_headers
def set_headers(v)
@headers = []
if v
v.split('&').each do |x|
@headers << x.split(/=/, 2)
end
end
end
protected :set_headers
def headers=(v)
check_headers(v)
set_headers(v)
v
end
def to_s
@scheme + ':' +
if @to
@to
else
''
end +
if @headers.size > 0
'?' + @headers.collect{|x| x.join('=')}.join('&')
else
''
end +
if @fragment
'#' + @fragment
else
''
end
end
def to_mailtext
to = URI.decode_www_form_component(@to)
head = ''
body = ''
@headers.each do |x|
case x[0]
when 'body'
body = URI.decode_www_form_component(x[1])
when 'to'
to << ', ' + URI.decode_www_form_component(x[1])
else
head << URI.decode_www_form_component(x[0]).capitalize + ': ' +
URI.decode_www_form_component(x[1])  + "\n"
end
end
"To: #{to}
#{head}
#{body}
"
end
alias to_rfc822text to_mailtext
end
@@schemes['MAILTO'] = MailTo
end
module URI
VERSION_CODE = '001000'.freeze
VERSION = VERSION_CODE.scan(/../).collect{|n| n.to_i}.join('.').freeze
end
module HTTP2
VERSION = '0.10.1'.freeze
end
module HTTP2
module Error
class Error < StandardError; end
class HandshakeError < Error; end
class ProtocolError < Error; end
class CompressionError < ProtocolError; end
class FlowControlError < ProtocolError; end
class InternalError < ProtocolError; end
class StreamClosed < Error; end
class ConnectionClosed < Error; end
class StreamLimitExceeded < Error; end
end
end
module HTTP2
module Emitter
def add_listener(event, &block)
fail ArgumentError, 'must provide callback' unless block_given?
listeners(event.to_sym).push block
end
alias on add_listener
def once(event, &block)
add_listener(event) do |*args, &callback|
block.call(*args, &callback)
:delete
end
end
def emit(event, *args, &block)
listeners(event).delete_if do |cb|
cb.call(*args, &block) == :delete
end
end
private
def listeners(event)
@listeners ||= Hash.new { |hash, key| hash[key] = [] }
@listeners[event]
end
end
end
module Forwardable
def self._valid_method?(method)
iseq = RubyVM::InstructionSequence.compile("().#{method}", nil, nil, 0, false)
rescue SyntaxError
false
else
iseq.to_a.dig(-1, 1, 1, :mid) == method.to_sym
end
def self._compile_method(src, file, line)
RubyVM::InstructionSequence.compile(src, file, file, line,
trace_instruction: false)
.eval
end
end
module Forwardable

VERSION = "1.2.0"
FORWARDABLE_VERSION = VERSION
@debug = nil
class << self
attr_accessor :debug
end
def instance_delegate(hash)
hash.each do |methods, accessor|
unless defined?(methods.each)
def_instance_delegator(accessor, methods)
else
methods.each {|method| def_instance_delegator(accessor, method)}
end
end
end
def def_instance_delegators(accessor, *methods)
methods.delete("__send__")
methods.delete("__id__")
for method in methods
def_instance_delegator(accessor, method)
end
end
def def_instance_delegator(accessor, method, ali = method)
gen = Forwardable._delegator_method(self, accessor, method, ali)
(Module === self ? self : singleton_class).module_eval(&gen)
end
alias delegate instance_delegate
alias def_delegators def_instance_delegators
alias def_delegator def_instance_delegator

def self._delegator_method(obj, accessor, method, ali)
accessor = accessor.to_s unless Symbol === accessor
if Module === obj ?
obj.method_defined?(accessor) || obj.private_method_defined?(accessor) :
obj.respond_to?(accessor, true)
accessor = "#{accessor}()"
end
method_call = ".__send__(:#{method}, *args, &block)"
if _valid_method?(method)
loc, = caller_locations(2,1)
pre = "_ ="
mesg = "#{Module === obj ? obj : obj.class}\##{ali} at #{loc.path}:#{loc.lineno} forwarding to private method "
method_call = "#{<<-"begin;"}\n#{<<-"end;".chomp}"
begin;
unless defined? _.#{method}
::Kernel.warn #{mesg.dump}"\#{_.class}"'##{method}', uplevel: 1
_#{method_call}
else
_.#{method}(*args, &block)
end
end;
end
_compile_method("#{<<-"begin;"}\n#{<<-"end;"}", __FILE__, __LINE__+1)
begin;
proc do
def #{ali}(*args, &block)
#{pre}
begin
#{accessor}
end#{method_call}
end
end
end;
end
end
module SingleForwardable
def single_delegate(hash)
hash.each do |methods, accessor|
unless defined?(methods.each)
def_single_delegator(accessor, methods)
else
methods.each {|method| def_single_delegator(accessor, method)}
end
end
end
def def_single_delegators(accessor, *methods)
methods.delete("__send__")
methods.delete("__id__")
for method in methods
def_single_delegator(accessor, method)
end
end
def def_single_delegator(accessor, method, ali = method)
gen = Forwardable._delegator_method(self, accessor, method, ali)
instance_eval(&gen)
end
alias delegate single_delegate
alias def_delegators def_single_delegators
alias def_delegator def_single_delegator
end
module HTTP2
class Buffer
extend Forwardable
def_delegators :@buffer, :ord, :encoding, :setbyte, :unpack,
:size, :each_byte, :to_str, :to_s, :length, :inspect,
:[], :[]=, :empty?, :bytesize, :include?
UINT32 = 'N'.freeze
private_constant :UINT32
def initialize(str = '')
str = str.dup if str.frozen?
@buffer = str.force_encoding(Encoding::BINARY)
end
def read(n)
Buffer.new(@buffer.slice!(0, n))
end
def getbyte
read(1).ord
end
def slice!(*args)
Buffer.new(@buffer.slice!(*args))
end
def slice(*args)
Buffer.new(@buffer.slice(*args))
end
def force_encoding(*args)
@buffer = @buffer.force_encoding(*args)
end
def ==(other)
@buffer == other
end
def +(other)
@buffer += other
end
def readbyte(n)
@buffer[n].ord
end
def read_uint32
read(4).unpack(UINT32).first
end
[:<<, :prepend].each do |mutating_method|
define_method(mutating_method) do |string|
string = string.dup if string.frozen?
@buffer.send mutating_method, string.force_encoding(Encoding::BINARY)
self
end
end
end
end
module HTTP2
module FlowBuffer
def buffered_amount
@send_buffer.map { |f| f[:length] }.reduce(:+) || 0
end
private
def update_local_window(frame)
frame_size = frame[:payload].bytesize
frame_size += frame[:padding] || 0
@local_window -= frame_size
end
def calculate_window_update(window_max_size)
error(:flow_control_error) if @local_window < 0
return unless @local_window <= (window_max_size / 2)
window_update(window_max_size - @local_window)
end
def send_data(frame = nil, encode = false)
@send_buffer.push frame unless frame.nil?
while @remote_window > 0 && !@send_buffer.empty?
frame = @send_buffer.shift
sent, frame_size = 0, frame[:payload].bytesize
if frame_size > @remote_window
payload = frame.delete(:payload)
chunk   = frame.dup
frame[:payload] = payload.slice!(0, @remote_window)
chunk[:length]  = payload.bytesize
chunk[:payload] = payload
frame[:flags] -= [:end_stream] if frame[:flags].include? :end_stream
@send_buffer.unshift chunk
sent = @remote_window
else
sent = frame_size
end
manage_state(frame) do
frames = encode ? encode(frame) : [frame]
frames.each { |f| emit(:frame, f) }
@remote_window -= sent
end
end
end
def process_window_update(frame)
return if frame[:ignore]
@remote_window += frame[:increment]
send_data
end
end
end
module HTTP2
module Header
class Huffman
include Error
BITS_AT_ONCE = 4
EOS = 256
private_constant :EOS
def encode(str)
bitstring = str.each_byte.map { |chr| ENCODE_TABLE[chr] }.join
bitstring << '1' * ((8 - bitstring.size) % 8)
[bitstring].pack('B*')
end
def decode(buf)
emit = ''
state = 0 # start state
mask = (1 << BITS_AT_ONCE) - 1
buf.each_byte do |chr|
(8 / BITS_AT_ONCE - 1).downto(0) do |shift|
branch = (chr >> (shift * BITS_AT_ONCE)) & mask
trans = MACHINE[state][branch]
fail CompressionError, 'Huffman decode error (EOS found)' if trans.first == EOS
emit << trans.first.chr if trans.first
state = trans.last
end
end
unless state <= MAX_FINAL_STATE
fail CompressionError, 'Huffman decode error (EOS invalid)'
end
emit.force_encoding(Encoding::BINARY)
end
CODES = [
[0x1ff8, 13],
[0x7fffd8, 23],
[0xfffffe2, 28],
[0xfffffe3, 28],
[0xfffffe4, 28],
[0xfffffe5, 28],
[0xfffffe6, 28],
[0xfffffe7, 28],
[0xfffffe8, 28],
[0xffffea, 24],
[0x3ffffffc, 30],
[0xfffffe9, 28],
[0xfffffea, 28],
[0x3ffffffd, 30],
[0xfffffeb, 28],
[0xfffffec, 28],
[0xfffffed, 28],
[0xfffffee, 28],
[0xfffffef, 28],
[0xffffff0, 28],
[0xffffff1, 28],
[0xffffff2, 28],
[0x3ffffffe, 30],
[0xffffff3, 28],
[0xffffff4, 28],
[0xffffff5, 28],
[0xffffff6, 28],
[0xffffff7, 28],
[0xffffff8, 28],
[0xffffff9, 28],
[0xffffffa, 28],
[0xffffffb, 28],
[0x14,  6],
[0x3f8, 10],
[0x3f9, 10],
[0xffa, 12],
[0x1ff9, 13],
[0x15,  6],
[0xf8,  8],
[0x7fa, 11],
[0x3fa, 10],
[0x3fb, 10],
[0xf9,  8],
[0x7fb, 11],
[0xfa,  8],
[0x16,  6],
[0x17,  6],
[0x18,  6],
[0x0,  5],
[0x1,  5],
[0x2,  5],
[0x19,  6],
[0x1a,  6],
[0x1b,  6],
[0x1c,  6],
[0x1d,  6],
[0x1e,  6],
[0x1f,  6],
[0x5c,  7],
[0xfb,  8],
[0x7ffc, 15],
[0x20,  6],
[0xffb, 12],
[0x3fc, 10],
[0x1ffa, 13],
[0x21,  6],
[0x5d,  7],
[0x5e,  7],
[0x5f,  7],
[0x60,  7],
[0x61,  7],
[0x62,  7],
[0x63,  7],
[0x64,  7],
[0x65,  7],
[0x66,  7],
[0x67,  7],
[0x68,  7],
[0x69,  7],
[0x6a,  7],
[0x6b,  7],
[0x6c,  7],
[0x6d,  7],
[0x6e,  7],
[0x6f,  7],
[0x70,  7],
[0x71,  7],
[0x72,  7],
[0xfc,  8],
[0x73,  7],
[0xfd,  8],
[0x1ffb, 13],
[0x7fff0, 19],
[0x1ffc, 13],
[0x3ffc, 14],
[0x22,  6],
[0x7ffd, 15],
[0x3,  5],
[0x23,  6],
[0x4,  5],
[0x24,  6],
[0x5,  5],
[0x25,  6],
[0x26,  6],
[0x27,  6],
[0x6,  5],
[0x74,  7],
[0x75,  7],
[0x28,  6],
[0x29,  6],
[0x2a,  6],
[0x7,  5],
[0x2b,  6],
[0x76,  7],
[0x2c,  6],
[0x8,  5],
[0x9,  5],
[0x2d,  6],
[0x77,  7],
[0x78,  7],
[0x79,  7],
[0x7a,  7],
[0x7b,  7],
[0x7ffe, 15],
[0x7fc, 11],
[0x3ffd, 14],
[0x1ffd, 13],
[0xffffffc, 28],
[0xfffe6, 20],
[0x3fffd2, 22],
[0xfffe7, 20],
[0xfffe8, 20],
[0x3fffd3, 22],
[0x3fffd4, 22],
[0x3fffd5, 22],
[0x7fffd9, 23],
[0x3fffd6, 22],
[0x7fffda, 23],
[0x7fffdb, 23],
[0x7fffdc, 23],
[0x7fffdd, 23],
[0x7fffde, 23],
[0xffffeb, 24],
[0x7fffdf, 23],
[0xffffec, 24],
[0xffffed, 24],
[0x3fffd7, 22],
[0x7fffe0, 23],
[0xffffee, 24],
[0x7fffe1, 23],
[0x7fffe2, 23],
[0x7fffe3, 23],
[0x7fffe4, 23],
[0x1fffdc, 21],
[0x3fffd8, 22],
[0x7fffe5, 23],
[0x3fffd9, 22],
[0x7fffe6, 23],
[0x7fffe7, 23],
[0xffffef, 24],
[0x3fffda, 22],
[0x1fffdd, 21],
[0xfffe9, 20],
[0x3fffdb, 22],
[0x3fffdc, 22],
[0x7fffe8, 23],
[0x7fffe9, 23],
[0x1fffde, 21],
[0x7fffea, 23],
[0x3fffdd, 22],
[0x3fffde, 22],
[0xfffff0, 24],
[0x1fffdf, 21],
[0x3fffdf, 22],
[0x7fffeb, 23],
[0x7fffec, 23],
[0x1fffe0, 21],
[0x1fffe1, 21],
[0x3fffe0, 22],
[0x1fffe2, 21],
[0x7fffed, 23],
[0x3fffe1, 22],
[0x7fffee, 23],
[0x7fffef, 23],
[0xfffea, 20],
[0x3fffe2, 22],
[0x3fffe3, 22],
[0x3fffe4, 22],
[0x7ffff0, 23],
[0x3fffe5, 22],
[0x3fffe6, 22],
[0x7ffff1, 23],
[0x3ffffe0, 26],
[0x3ffffe1, 26],
[0xfffeb, 20],
[0x7fff1, 19],
[0x3fffe7, 22],
[0x7ffff2, 23],
[0x3fffe8, 22],
[0x1ffffec, 25],
[0x3ffffe2, 26],
[0x3ffffe3, 26],
[0x3ffffe4, 26],
[0x7ffffde, 27],
[0x7ffffdf, 27],
[0x3ffffe5, 26],
[0xfffff1, 24],
[0x1ffffed, 25],
[0x7fff2, 19],
[0x1fffe3, 21],
[0x3ffffe6, 26],
[0x7ffffe0, 27],
[0x7ffffe1, 27],
[0x3ffffe7, 26],
[0x7ffffe2, 27],
[0xfffff2, 24],
[0x1fffe4, 21],
[0x1fffe5, 21],
[0x3ffffe8, 26],
[0x3ffffe9, 26],
[0xffffffd, 28],
[0x7ffffe3, 27],
[0x7ffffe4, 27],
[0x7ffffe5, 27],
[0xfffec, 20],
[0xfffff3, 24],
[0xfffed, 20],
[0x1fffe6, 21],
[0x3fffe9, 22],
[0x1fffe7, 21],
[0x1fffe8, 21],
[0x7ffff3, 23],
[0x3fffea, 22],
[0x3fffeb, 22],
[0x1ffffee, 25],
[0x1ffffef, 25],
[0xfffff4, 24],
[0xfffff5, 24],
[0x3ffffea, 26],
[0x7ffff4, 23],
[0x3ffffeb, 26],
[0x7ffffe6, 27],
[0x3ffffec, 26],
[0x3ffffed, 26],
[0x7ffffe7, 27],
[0x7ffffe8, 27],
[0x7ffffe9, 27],
[0x7ffffea, 27],
[0x7ffffeb, 27],
[0xffffffe, 28],
[0x7ffffec, 27],
[0x7ffffed, 27],
[0x7ffffee, 27],
[0x7ffffef, 27],
[0x7fffff0, 27],
[0x3ffffee, 26],
[0x3fffffff, 30],
].each(&:freeze).freeze
ENCODE_TABLE = CODES.map { |c, l| [c].pack('N').unpack('B*').first[-l..-1] }.each(&:freeze).freeze
end
end
end
module HTTP2
module Header
class Huffman

MAX_FINAL_STATE = 7
MACHINE = [
[[nil, 16], [nil, 76], [nil, 54], [nil, 36], [nil, 30], [nil, 28], [nil, 24], [nil, 221], [nil, 9], [nil, 10], [nil, 11], [nil, 12], [nil, 13], [nil, 14], [nil, 15], [nil, 1]],
[[119, 29], [119, 5], [120, 29], [120, 5], [121, 29], [121, 5], [122, 29], [122, 5], [38, 0], [42, 0], [44, 0], [59, 0], [88, 0], [90, 0], [nil, 31], [nil, 32]],
[[38, 29], [38, 5], [42, 29], [42, 5], [44, 29], [44, 5], [59, 29], [59, 5], [88, 29], [88, 5], [90, 29], [90, 5], [nil, 87], [nil, 88], [nil, 89], [nil, 90]],
[[88, 25], [88, 26], [88, 27], [88, 6], [90, 25], [90, 26], [90, 27], [90, 6], [33, 0], [34, 0], [40, 0], [41, 0], [63, 0], [nil, 84], [nil, 85], [nil, 86]],
[[33, 29], [33, 5], [34, 29], [34, 5], [40, 29], [40, 5], [41, 29], [41, 5], [63, 29], [63, 5], [39, 0], [43, 0], [124, 0], [nil, 81], [nil, 82], [nil, 83]],
[[nil, 61], [nil, 62], [nil, 63], [nil, 64], [nil, 65], [nil, 66], [nil, 67], [nil, 68], [nil, 69], [nil, 70], [nil, 71], [nil, 72], [nil, 73], [nil, 74], [nil, 75], [nil, 2]],
[[nil, 39], [nil, 40], [nil, 41], [nil, 42], [nil, 43], [nil, 44], [nil, 45], [nil, 46], [nil, 47], [nil, 48], [nil, 49], [nil, 50], [nil, 51], [nil, 52], [nil, 53], [nil, 3]],
[[85, 0], [86, 0], [87, 0], [89, 0], [106, 0], [107, 0], [113, 0], [118, 0], [119, 0], [120, 0], [121, 0], [122, 0], [nil, 33], [nil, 34], [nil, 35], [nil, 4]],
[[203, 17], [203, 18], [203, 19], [203, 20], [203, 21], [203, 22], [203, 23], [203, 7], [204, 17], [204, 18], [204, 19], [204, 20], [204, 21], [204, 22], [204, 23], [204, 7]],
[[61, 25], [61, 26], [61, 27], [61, 6], [65, 25], [65, 26], [65, 27], [65, 6], [95, 25], [95, 26], [95, 27], [95, 6], [98, 25], [98, 26], [98, 27], [98, 6]],
[[100, 25], [100, 26], [100, 27], [100, 6], [102, 25], [102, 26], [102, 27], [102, 6], [103, 25], [103, 26], [103, 27], [103, 6], [104, 25], [104, 26], [104, 27], [104, 6]],
[[108, 25], [108, 26], [108, 27], [108, 6], [109, 25], [109, 26], [109, 27], [109, 6], [110, 25], [110, 26], [110, 27], [110, 6], [112, 25], [112, 26], [112, 27], [112, 6]],
[[114, 25], [114, 26], [114, 27], [114, 6], [117, 25], [117, 26], [117, 27], [117, 6], [58, 29], [58, 5], [66, 29], [66, 5], [67, 29], [67, 5], [68, 29], [68, 5]],
[[69, 29], [69, 5], [70, 29], [70, 5], [71, 29], [71, 5], [72, 29], [72, 5], [73, 29], [73, 5], [74, 29], [74, 5], [75, 29], [75, 5], [76, 29], [76, 5]],
[[77, 29], [77, 5], [78, 29], [78, 5], [79, 29], [79, 5], [80, 29], [80, 5], [81, 29], [81, 5], [82, 29], [82, 5], [83, 29], [83, 5], [84, 29], [84, 5]],
[[85, 29], [85, 5], [86, 29], [86, 5], [87, 29], [87, 5], [89, 29], [89, 5], [106, 29], [106, 5], [107, 29], [107, 5], [113, 29], [113, 5], [118, 29], [118, 5]],
[[48, 17], [48, 18], [48, 19], [48, 20], [48, 21], [48, 22], [48, 23], [48, 7], [49, 17], [49, 18], [49, 19], [49, 20], [49, 21], [49, 22], [49, 23], [49, 7]],
[[48, 25], [48, 26], [48, 27], [48, 6], [49, 25], [49, 26], [49, 27], [49, 6], [50, 25], [50, 26], [50, 27], [50, 6], [97, 25], [97, 26], [97, 27], [97, 6]],
[[99, 25], [99, 26], [99, 27], [99, 6], [101, 25], [101, 26], [101, 27], [101, 6], [105, 25], [105, 26], [105, 27], [105, 6], [111, 25], [111, 26], [111, 27], [111, 6]],
[[115, 25], [115, 26], [115, 27], [115, 6], [116, 25], [116, 26], [116, 27], [116, 6], [32, 29], [32, 5], [37, 29], [37, 5], [45, 29], [45, 5], [46, 29], [46, 5]],
[[47, 29], [47, 5], [51, 29], [51, 5], [52, 29], [52, 5], [53, 29], [53, 5], [54, 29], [54, 5], [55, 29], [55, 5], [56, 29], [56, 5], [57, 29], [57, 5]],
[[61, 29], [61, 5], [65, 29], [65, 5], [95, 29], [95, 5], [98, 29], [98, 5], [100, 29], [100, 5], [102, 29], [102, 5], [103, 29], [103, 5], [104, 29], [104, 5]],
[[108, 29], [108, 5], [109, 29], [109, 5], [110, 29], [110, 5], [112, 29], [112, 5], [114, 29], [114, 5], [117, 29], [117, 5], [58, 0], [66, 0], [67, 0], [68, 0]],
[[69, 0], [70, 0], [71, 0], [72, 0], [73, 0], [74, 0], [75, 0], [76, 0], [77, 0], [78, 0], [79, 0], [80, 0], [81, 0], [82, 0], [83, 0], [84, 0]],
[[47, 25], [47, 26], [47, 27], [47, 6], [51, 25], [51, 26], [51, 27], [51, 6], [52, 25], [52, 26], [52, 27], [52, 6], [53, 25], [53, 26], [53, 27], [53, 6]],
[[48, 29], [48, 5], [49, 29], [49, 5], [50, 29], [50, 5], [97, 29], [97, 5], [99, 29], [99, 5], [101, 29], [101, 5], [105, 29], [105, 5], [111, 29], [111, 5]],
[[115, 29], [115, 5], [116, 29], [116, 5], [32, 0], [37, 0], [45, 0], [46, 0], [47, 0], [51, 0], [52, 0], [53, 0], [54, 0], [55, 0], [56, 0], [57, 0]],
[[61, 0], [65, 0], [95, 0], [98, 0], [100, 0], [102, 0], [103, 0], [104, 0], [108, 0], [109, 0], [110, 0], [112, 0], [114, 0], [117, 0], [nil, 37], [nil, 38]],
[[32, 25], [32, 26], [32, 27], [32, 6], [37, 25], [37, 26], [37, 27], [37, 6], [45, 25], [45, 26], [45, 27], [45, 6], [46, 25], [46, 26], [46, 27], [46, 6]],
[[48, 0], [49, 0], [50, 0], [97, 0], [99, 0], [101, 0], [105, 0], [111, 0], [115, 0], [116, 0], [nil, 55], [nil, 56], [nil, 57], [nil, 58], [nil, 59], [nil, 60]],
[[115, 17], [115, 18], [115, 19], [115, 20], [115, 21], [115, 22], [115, 23], [115, 7], [116, 17], [116, 18], [116, 19], [116, 20], [116, 21], [116, 22], [116, 23], [116, 7]],
[[33, 25], [33, 26], [33, 27], [33, 6], [34, 25], [34, 26], [34, 27], [34, 6], [40, 25], [40, 26], [40, 27], [40, 6], [41, 25], [41, 26], [41, 27], [41, 6]],
[[63, 25], [63, 26], [63, 27], [63, 6], [39, 29], [39, 5], [43, 29], [43, 5], [124, 29], [124, 5], [35, 0], [62, 0], [nil, 77], [nil, 78], [nil, 79], [nil, 80]],
[[38, 17], [38, 18], [38, 19], [38, 20], [38, 21], [38, 22], [38, 23], [38, 7], [42, 17], [42, 18], [42, 19], [42, 20], [42, 21], [42, 22], [42, 23], [42, 7]],
[[44, 17], [44, 18], [44, 19], [44, 20], [44, 21], [44, 22], [44, 23], [44, 7], [59, 17], [59, 18], [59, 19], [59, 20], [59, 21], [59, 22], [59, 23], [59, 7]],
[[88, 17], [88, 18], [88, 19], [88, 20], [88, 21], [88, 22], [88, 23], [88, 7], [90, 17], [90, 18], [90, 19], [90, 20], [90, 21], [90, 22], [90, 23], [90, 7]],
[[105, 17], [105, 18], [105, 19], [105, 20], [105, 21], [105, 22], [105, 23], [105, 7], [111, 17], [111, 18], [111, 19], [111, 20], [111, 21], [111, 22], [111, 23], [111, 7]],
[[58, 17], [58, 18], [58, 19], [58, 20], [58, 21], [58, 22], [58, 23], [58, 7], [66, 17], [66, 18], [66, 19], [66, 20], [66, 21], [66, 22], [66, 23], [66, 7]],
[[67, 17], [67, 18], [67, 19], [67, 20], [67, 21], [67, 22], [67, 23], [67, 7], [68, 17], [68, 18], [68, 19], [68, 20], [68, 21], [68, 22], [68, 23], [68, 7]],
[[69, 17], [69, 18], [69, 19], [69, 20], [69, 21], [69, 22], [69, 23], [69, 7], [70, 17], [70, 18], [70, 19], [70, 20], [70, 21], [70, 22], [70, 23], [70, 7]],
[[71, 17], [71, 18], [71, 19], [71, 20], [71, 21], [71, 22], [71, 23], [71, 7], [72, 17], [72, 18], [72, 19], [72, 20], [72, 21], [72, 22], [72, 23], [72, 7]],
[[73, 17], [73, 18], [73, 19], [73, 20], [73, 21], [73, 22], [73, 23], [73, 7], [74, 17], [74, 18], [74, 19], [74, 20], [74, 21], [74, 22], [74, 23], [74, 7]],
[[75, 17], [75, 18], [75, 19], [75, 20], [75, 21], [75, 22], [75, 23], [75, 7], [76, 17], [76, 18], [76, 19], [76, 20], [76, 21], [76, 22], [76, 23], [76, 7]],
[[77, 17], [77, 18], [77, 19], [77, 20], [77, 21], [77, 22], [77, 23], [77, 7], [78, 17], [78, 18], [78, 19], [78, 20], [78, 21], [78, 22], [78, 23], [78, 7]],
[[79, 17], [79, 18], [79, 19], [79, 20], [79, 21], [79, 22], [79, 23], [79, 7], [80, 17], [80, 18], [80, 19], [80, 20], [80, 21], [80, 22], [80, 23], [80, 7]],
[[81, 17], [81, 18], [81, 19], [81, 20], [81, 21], [81, 22], [81, 23], [81, 7], [82, 17], [82, 18], [82, 19], [82, 20], [82, 21], [82, 22], [82, 23], [82, 7]],
[[83, 17], [83, 18], [83, 19], [83, 20], [83, 21], [83, 22], [83, 23], [83, 7], [84, 17], [84, 18], [84, 19], [84, 20], [84, 21], [84, 22], [84, 23], [84, 7]],
[[85, 17], [85, 18], [85, 19], [85, 20], [85, 21], [85, 22], [85, 23], [85, 7], [86, 17], [86, 18], [86, 19], [86, 20], [86, 21], [86, 22], [86, 23], [86, 7]],
[[87, 17], [87, 18], [87, 19], [87, 20], [87, 21], [87, 22], [87, 23], [87, 7], [89, 17], [89, 18], [89, 19], [89, 20], [89, 21], [89, 22], [89, 23], [89, 7]],
[[106, 17], [106, 18], [106, 19], [106, 20], [106, 21], [106, 22], [106, 23], [106, 7], [107, 17], [107, 18], [107, 19], [107, 20], [107, 21], [107, 22], [107, 23], [107, 7]],
[[113, 17], [113, 18], [113, 19], [113, 20], [113, 21], [113, 22], [113, 23], [113, 7], [118, 17], [118, 18], [118, 19], [118, 20], [118, 21], [118, 22], [118, 23], [118, 7]],
[[119, 17], [119, 18], [119, 19], [119, 20], [119, 21], [119, 22], [119, 23], [119, 7], [120, 17], [120, 18], [120, 19], [120, 20], [120, 21], [120, 22], [120, 23], [120, 7]],
[[121, 17], [121, 18], [121, 19], [121, 20], [121, 21], [121, 22], [121, 23], [121, 7], [122, 17], [122, 18], [122, 19], [122, 20], [122, 21], [122, 22], [122, 23], [122, 7]],
[[38, 25], [38, 26], [38, 27], [38, 6], [42, 25], [42, 26], [42, 27], [42, 6], [44, 25], [44, 26], [44, 27], [44, 6], [59, 25], [59, 26], [59, 27], [59, 6]],
[[99, 17], [99, 18], [99, 19], [99, 20], [99, 21], [99, 22], [99, 23], [99, 7], [101, 17], [101, 18], [101, 19], [101, 20], [101, 21], [101, 22], [101, 23], [101, 7]],
[[32, 17], [32, 18], [32, 19], [32, 20], [32, 21], [32, 22], [32, 23], [32, 7], [37, 17], [37, 18], [37, 19], [37, 20], [37, 21], [37, 22], [37, 23], [37, 7]],
[[45, 17], [45, 18], [45, 19], [45, 20], [45, 21], [45, 22], [45, 23], [45, 7], [46, 17], [46, 18], [46, 19], [46, 20], [46, 21], [46, 22], [46, 23], [46, 7]],
[[47, 17], [47, 18], [47, 19], [47, 20], [47, 21], [47, 22], [47, 23], [47, 7], [51, 17], [51, 18], [51, 19], [51, 20], [51, 21], [51, 22], [51, 23], [51, 7]],
[[52, 17], [52, 18], [52, 19], [52, 20], [52, 21], [52, 22], [52, 23], [52, 7], [53, 17], [53, 18], [53, 19], [53, 20], [53, 21], [53, 22], [53, 23], [53, 7]],
[[54, 17], [54, 18], [54, 19], [54, 20], [54, 21], [54, 22], [54, 23], [54, 7], [55, 17], [55, 18], [55, 19], [55, 20], [55, 21], [55, 22], [55, 23], [55, 7]],
[[56, 17], [56, 18], [56, 19], [56, 20], [56, 21], [56, 22], [56, 23], [56, 7], [57, 17], [57, 18], [57, 19], [57, 20], [57, 21], [57, 22], [57, 23], [57, 7]],
[[61, 17], [61, 18], [61, 19], [61, 20], [61, 21], [61, 22], [61, 23], [61, 7], [65, 17], [65, 18], [65, 19], [65, 20], [65, 21], [65, 22], [65, 23], [65, 7]],
[[95, 17], [95, 18], [95, 19], [95, 20], [95, 21], [95, 22], [95, 23], [95, 7], [98, 17], [98, 18], [98, 19], [98, 20], [98, 21], [98, 22], [98, 23], [98, 7]],
[[100, 17], [100, 18], [100, 19], [100, 20], [100, 21], [100, 22], [100, 23], [100, 7], [102, 17], [102, 18], [102, 19], [102, 20], [102, 21], [102, 22], [102, 23], [102, 7]],
[[103, 17], [103, 18], [103, 19], [103, 20], [103, 21], [103, 22], [103, 23], [103, 7], [104, 17], [104, 18], [104, 19], [104, 20], [104, 21], [104, 22], [104, 23], [104, 7]],
[[108, 17], [108, 18], [108, 19], [108, 20], [108, 21], [108, 22], [108, 23], [108, 7], [109, 17], [109, 18], [109, 19], [109, 20], [109, 21], [109, 22], [109, 23], [109, 7]],
[[110, 17], [110, 18], [110, 19], [110, 20], [110, 21], [110, 22], [110, 23], [110, 7], [112, 17], [112, 18], [112, 19], [112, 20], [112, 21], [112, 22], [112, 23], [112, 7]],
[[114, 17], [114, 18], [114, 19], [114, 20], [114, 21], [114, 22], [114, 23], [114, 7], [117, 17], [117, 18], [117, 19], [117, 20], [117, 21], [117, 22], [117, 23], [117, 7]],
[[58, 25], [58, 26], [58, 27], [58, 6], [66, 25], [66, 26], [66, 27], [66, 6], [67, 25], [67, 26], [67, 27], [67, 6], [68, 25], [68, 26], [68, 27], [68, 6]],
[[69, 25], [69, 26], [69, 27], [69, 6], [70, 25], [70, 26], [70, 27], [70, 6], [71, 25], [71, 26], [71, 27], [71, 6], [72, 25], [72, 26], [72, 27], [72, 6]],
[[73, 25], [73, 26], [73, 27], [73, 6], [74, 25], [74, 26], [74, 27], [74, 6], [75, 25], [75, 26], [75, 27], [75, 6], [76, 25], [76, 26], [76, 27], [76, 6]],
[[77, 25], [77, 26], [77, 27], [77, 6], [78, 25], [78, 26], [78, 27], [78, 6], [79, 25], [79, 26], [79, 27], [79, 6], [80, 25], [80, 26], [80, 27], [80, 6]],
[[81, 25], [81, 26], [81, 27], [81, 6], [82, 25], [82, 26], [82, 27], [82, 6], [83, 25], [83, 26], [83, 27], [83, 6], [84, 25], [84, 26], [84, 27], [84, 6]],
[[85, 25], [85, 26], [85, 27], [85, 6], [86, 25], [86, 26], [86, 27], [86, 6], [87, 25], [87, 26], [87, 27], [87, 6], [89, 25], [89, 26], [89, 27], [89, 6]],
[[106, 25], [106, 26], [106, 27], [106, 6], [107, 25], [107, 26], [107, 27], [107, 6], [113, 25], [113, 26], [113, 27], [113, 6], [118, 25], [118, 26], [118, 27], [118, 6]],
[[119, 25], [119, 26], [119, 27], [119, 6], [120, 25], [120, 26], [120, 27], [120, 6], [121, 25], [121, 26], [121, 27], [121, 6], [122, 25], [122, 26], [122, 27], [122, 6]],
[[50, 17], [50, 18], [50, 19], [50, 20], [50, 21], [50, 22], [50, 23], [50, 7], [97, 17], [97, 18], [97, 19], [97, 20], [97, 21], [97, 22], [97, 23], [97, 7]],
[[0, 17], [0, 18], [0, 19], [0, 20], [0, 21], [0, 22], [0, 23], [0, 7], [36, 17], [36, 18], [36, 19], [36, 20], [36, 21], [36, 22], [36, 23], [36, 7]],
[[64, 17], [64, 18], [64, 19], [64, 20], [64, 21], [64, 22], [64, 23], [64, 7], [91, 17], [91, 18], [91, 19], [91, 20], [91, 21], [91, 22], [91, 23], [91, 7]],
[[93, 17], [93, 18], [93, 19], [93, 20], [93, 21], [93, 22], [93, 23], [93, 7], [126, 17], [126, 18], [126, 19], [126, 20], [126, 21], [126, 22], [126, 23], [126, 7]],
[[94, 25], [94, 26], [94, 27], [94, 6], [125, 25], [125, 26], [125, 27], [125, 6], [60, 29], [60, 5], [96, 29], [96, 5], [123, 29], [123, 5], [nil, 91], [nil, 92]],
[[35, 17], [35, 18], [35, 19], [35, 20], [35, 21], [35, 22], [35, 23], [35, 7], [62, 17], [62, 18], [62, 19], [62, 20], [62, 21], [62, 22], [62, 23], [62, 7]],
[[0, 25], [0, 26], [0, 27], [0, 6], [36, 25], [36, 26], [36, 27], [36, 6], [64, 25], [64, 26], [64, 27], [64, 6], [91, 25], [91, 26], [91, 27], [91, 6]],
[[93, 25], [93, 26], [93, 27], [93, 6], [126, 25], [126, 26], [126, 27], [126, 6], [94, 29], [94, 5], [125, 29], [125, 5], [60, 0], [96, 0], [123, 0], [nil, 93]],
[[39, 17], [39, 18], [39, 19], [39, 20], [39, 21], [39, 22], [39, 23], [39, 7], [43, 17], [43, 18], [43, 19], [43, 20], [43, 21], [43, 22], [43, 23], [43, 7]],
[[124, 17], [124, 18], [124, 19], [124, 20], [124, 21], [124, 22], [124, 23], [124, 7], [35, 25], [35, 26], [35, 27], [35, 6], [62, 25], [62, 26], [62, 27], [62, 6]],
[[0, 29], [0, 5], [36, 29], [36, 5], [64, 29], [64, 5], [91, 29], [91, 5], [93, 29], [93, 5], [126, 29], [126, 5], [94, 0], [125, 0], [nil, 94], [nil, 95]],
[[33, 17], [33, 18], [33, 19], [33, 20], [33, 21], [33, 22], [33, 23], [33, 7], [34, 17], [34, 18], [34, 19], [34, 20], [34, 21], [34, 22], [34, 23], [34, 7]],
[[40, 17], [40, 18], [40, 19], [40, 20], [40, 21], [40, 22], [40, 23], [40, 7], [41, 17], [41, 18], [41, 19], [41, 20], [41, 21], [41, 22], [41, 23], [41, 7]],
[[63, 17], [63, 18], [63, 19], [63, 20], [63, 21], [63, 22], [63, 23], [63, 7], [39, 25], [39, 26], [39, 27], [39, 6], [43, 25], [43, 26], [43, 27], [43, 6]],
[[124, 25], [124, 26], [124, 27], [124, 6], [35, 29], [35, 5], [62, 29], [62, 5], [0, 0], [36, 0], [64, 0], [91, 0], [93, 0], [126, 0], [nil, 96], [nil, 97]],
[[92, 29], [92, 5], [195, 29], [195, 5], [208, 29], [208, 5], [128, 0], [130, 0], [131, 0], [162, 0], [184, 0], [194, 0], [224, 0], [226, 0], [nil, 98], [nil, 99]],
[[nil, 100], [nil, 101], [nil, 102], [nil, 103], [nil, 104], [nil, 105], [nil, 106], [nil, 107], [nil, 108], [nil, 109], [nil, 110], [nil, 111], [nil, 112], [nil, 113], [nil, 114], [nil, 115]],
[[92, 0], [195, 0], [208, 0], [nil, 116], [nil, 117], [nil, 118], [nil, 119], [nil, 120], [nil, 121], [nil, 122], [nil, 123], [nil, 124], [nil, 125], [nil, 126], [nil, 127], [nil, 128]],
[[60, 17], [60, 18], [60, 19], [60, 20], [60, 21], [60, 22], [60, 23], [60, 7], [96, 17], [96, 18], [96, 19], [96, 20], [96, 21], [96, 22], [96, 23], [96, 7]],
[[123, 17], [123, 18], [123, 19], [123, 20], [123, 21], [123, 22], [123, 23], [123, 7], [nil, 129], [nil, 130], [nil, 131], [nil, 132], [nil, 133], [nil, 134], [nil, 135], [nil, 136]],
[[94, 17], [94, 18], [94, 19], [94, 20], [94, 21], [94, 22], [94, 23], [94, 7], [125, 17], [125, 18], [125, 19], [125, 20], [125, 21], [125, 22], [125, 23], [125, 7]],
[[60, 25], [60, 26], [60, 27], [60, 6], [96, 25], [96, 26], [96, 27], [96, 6], [123, 25], [123, 26], [123, 27], [123, 6], [nil, 137], [nil, 138], [nil, 139], [nil, 140]],
[[153, 17], [153, 18], [153, 19], [153, 20], [153, 21], [153, 22], [153, 23], [153, 7], [161, 17], [161, 18], [161, 19], [161, 20], [161, 21], [161, 22], [161, 23], [161, 7]],
[[167, 17], [167, 18], [167, 19], [167, 20], [167, 21], [167, 22], [167, 23], [167, 7], [172, 17], [172, 18], [172, 19], [172, 20], [172, 21], [172, 22], [172, 23], [172, 7]],
[[176, 17], [176, 18], [176, 19], [176, 20], [176, 21], [176, 22], [176, 23], [176, 7], [177, 17], [177, 18], [177, 19], [177, 20], [177, 21], [177, 22], [177, 23], [177, 7]],
[[179, 17], [179, 18], [179, 19], [179, 20], [179, 21], [179, 22], [179, 23], [179, 7], [209, 17], [209, 18], [209, 19], [209, 20], [209, 21], [209, 22], [209, 23], [209, 7]],
[[216, 17], [216, 18], [216, 19], [216, 20], [216, 21], [216, 22], [216, 23], [216, 7], [217, 17], [217, 18], [217, 19], [217, 20], [217, 21], [217, 22], [217, 23], [217, 7]],
[[227, 17], [227, 18], [227, 19], [227, 20], [227, 21], [227, 22], [227, 23], [227, 7], [229, 17], [229, 18], [229, 19], [229, 20], [229, 21], [229, 22], [229, 23], [229, 7]],
[[230, 17], [230, 18], [230, 19], [230, 20], [230, 21], [230, 22], [230, 23], [230, 7], [129, 25], [129, 26], [129, 27], [129, 6], [132, 25], [132, 26], [132, 27], [132, 6]],
[[133, 25], [133, 26], [133, 27], [133, 6], [134, 25], [134, 26], [134, 27], [134, 6], [136, 25], [136, 26], [136, 27], [136, 6], [146, 25], [146, 26], [146, 27], [146, 6]],
[[154, 25], [154, 26], [154, 27], [154, 6], [156, 25], [156, 26], [156, 27], [156, 6], [160, 25], [160, 26], [160, 27], [160, 6], [163, 25], [163, 26], [163, 27], [163, 6]],
[[164, 25], [164, 26], [164, 27], [164, 6], [169, 25], [169, 26], [169, 27], [169, 6], [170, 25], [170, 26], [170, 27], [170, 6], [173, 25], [173, 26], [173, 27], [173, 6]],
[[178, 25], [178, 26], [178, 27], [178, 6], [181, 25], [181, 26], [181, 27], [181, 6], [185, 25], [185, 26], [185, 27], [185, 6], [186, 25], [186, 26], [186, 27], [186, 6]],
[[187, 25], [187, 26], [187, 27], [187, 6], [189, 25], [189, 26], [189, 27], [189, 6], [190, 25], [190, 26], [190, 27], [190, 6], [196, 25], [196, 26], [196, 27], [196, 6]],
[[198, 25], [198, 26], [198, 27], [198, 6], [228, 25], [228, 26], [228, 27], [228, 6], [232, 25], [232, 26], [232, 27], [232, 6], [233, 25], [233, 26], [233, 27], [233, 6]],
[[1, 29], [1, 5], [135, 29], [135, 5], [137, 29], [137, 5], [138, 29], [138, 5], [139, 29], [139, 5], [140, 29], [140, 5], [141, 29], [141, 5], [143, 29], [143, 5]],
[[147, 29], [147, 5], [149, 29], [149, 5], [150, 29], [150, 5], [151, 29], [151, 5], [152, 29], [152, 5], [155, 29], [155, 5], [157, 29], [157, 5], [158, 29], [158, 5]],
[[165, 29], [165, 5], [166, 29], [166, 5], [168, 29], [168, 5], [174, 29], [174, 5], [175, 29], [175, 5], [180, 29], [180, 5], [182, 29], [182, 5], [183, 29], [183, 5]],
[[188, 29], [188, 5], [191, 29], [191, 5], [197, 29], [197, 5], [231, 29], [231, 5], [239, 29], [239, 5], [9, 0], [142, 0], [144, 0], [145, 0], [148, 0], [159, 0]],
[[171, 0], [206, 0], [215, 0], [225, 0], [236, 0], [237, 0], [nil, 141], [nil, 142], [nil, 143], [nil, 144], [nil, 145], [nil, 146], [nil, 147], [nil, 148], [nil, 149], [nil, 150]],
[[128, 17], [128, 18], [128, 19], [128, 20], [128, 21], [128, 22], [128, 23], [128, 7], [130, 17], [130, 18], [130, 19], [130, 20], [130, 21], [130, 22], [130, 23], [130, 7]],
[[131, 17], [131, 18], [131, 19], [131, 20], [131, 21], [131, 22], [131, 23], [131, 7], [162, 17], [162, 18], [162, 19], [162, 20], [162, 21], [162, 22], [162, 23], [162, 7]],
[[184, 17], [184, 18], [184, 19], [184, 20], [184, 21], [184, 22], [184, 23], [184, 7], [194, 17], [194, 18], [194, 19], [194, 20], [194, 21], [194, 22], [194, 23], [194, 7]],
[[224, 17], [224, 18], [224, 19], [224, 20], [224, 21], [224, 22], [224, 23], [224, 7], [226, 17], [226, 18], [226, 19], [226, 20], [226, 21], [226, 22], [226, 23], [226, 7]],
[[153, 25], [153, 26], [153, 27], [153, 6], [161, 25], [161, 26], [161, 27], [161, 6], [167, 25], [167, 26], [167, 27], [167, 6], [172, 25], [172, 26], [172, 27], [172, 6]],
[[176, 25], [176, 26], [176, 27], [176, 6], [177, 25], [177, 26], [177, 27], [177, 6], [179, 25], [179, 26], [179, 27], [179, 6], [209, 25], [209, 26], [209, 27], [209, 6]],
[[216, 25], [216, 26], [216, 27], [216, 6], [217, 25], [217, 26], [217, 27], [217, 6], [227, 25], [227, 26], [227, 27], [227, 6], [229, 25], [229, 26], [229, 27], [229, 6]],
[[230, 25], [230, 26], [230, 27], [230, 6], [129, 29], [129, 5], [132, 29], [132, 5], [133, 29], [133, 5], [134, 29], [134, 5], [136, 29], [136, 5], [146, 29], [146, 5]],
[[154, 29], [154, 5], [156, 29], [156, 5], [160, 29], [160, 5], [163, 29], [163, 5], [164, 29], [164, 5], [169, 29], [169, 5], [170, 29], [170, 5], [173, 29], [173, 5]],
[[178, 29], [178, 5], [181, 29], [181, 5], [185, 29], [185, 5], [186, 29], [186, 5], [187, 29], [187, 5], [189, 29], [189, 5], [190, 29], [190, 5], [196, 29], [196, 5]],
[[198, 29], [198, 5], [228, 29], [228, 5], [232, 29], [232, 5], [233, 29], [233, 5], [1, 0], [135, 0], [137, 0], [138, 0], [139, 0], [140, 0], [141, 0], [143, 0]],
[[147, 0], [149, 0], [150, 0], [151, 0], [152, 0], [155, 0], [157, 0], [158, 0], [165, 0], [166, 0], [168, 0], [174, 0], [175, 0], [180, 0], [182, 0], [183, 0]],
[[188, 0], [191, 0], [197, 0], [231, 0], [239, 0], [nil, 151], [nil, 152], [nil, 153], [nil, 154], [nil, 155], [nil, 156], [nil, 157], [nil, 158], [nil, 159], [nil, 160], [nil, 161]],
[[92, 17], [92, 18], [92, 19], [92, 20], [92, 21], [92, 22], [92, 23], [92, 7], [195, 17], [195, 18], [195, 19], [195, 20], [195, 21], [195, 22], [195, 23], [195, 7]],
[[208, 17], [208, 18], [208, 19], [208, 20], [208, 21], [208, 22], [208, 23], [208, 7], [128, 25], [128, 26], [128, 27], [128, 6], [130, 25], [130, 26], [130, 27], [130, 6]],
[[131, 25], [131, 26], [131, 27], [131, 6], [162, 25], [162, 26], [162, 27], [162, 6], [184, 25], [184, 26], [184, 27], [184, 6], [194, 25], [194, 26], [194, 27], [194, 6]],
[[224, 25], [224, 26], [224, 27], [224, 6], [226, 25], [226, 26], [226, 27], [226, 6], [153, 29], [153, 5], [161, 29], [161, 5], [167, 29], [167, 5], [172, 29], [172, 5]],
[[176, 29], [176, 5], [177, 29], [177, 5], [179, 29], [179, 5], [209, 29], [209, 5], [216, 29], [216, 5], [217, 29], [217, 5], [227, 29], [227, 5], [229, 29], [229, 5]],
[[230, 29], [230, 5], [129, 0], [132, 0], [133, 0], [134, 0], [136, 0], [146, 0], [154, 0], [156, 0], [160, 0], [163, 0], [164, 0], [169, 0], [170, 0], [173, 0]],
[[178, 0], [181, 0], [185, 0], [186, 0], [187, 0], [189, 0], [190, 0], [196, 0], [198, 0], [228, 0], [232, 0], [233, 0], [nil, 162], [nil, 163], [nil, 164], [nil, 165]],
[[nil, 166], [nil, 167], [nil, 168], [nil, 169], [nil, 170], [nil, 171], [nil, 172], [nil, 173], [nil, 174], [nil, 175], [nil, 176], [nil, 177], [nil, 178], [nil, 179], [nil, 180], [nil, 181]],
[[92, 25], [92, 26], [92, 27], [92, 6], [195, 25], [195, 26], [195, 27], [195, 6], [208, 25], [208, 26], [208, 27], [208, 6], [128, 29], [128, 5], [130, 29], [130, 5]],
[[131, 29], [131, 5], [162, 29], [162, 5], [184, 29], [184, 5], [194, 29], [194, 5], [224, 29], [224, 5], [226, 29], [226, 5], [153, 0], [161, 0], [167, 0], [172, 0]],
[[176, 0], [177, 0], [179, 0], [209, 0], [216, 0], [217, 0], [227, 0], [229, 0], [230, 0], [nil, 182], [nil, 183], [nil, 184], [nil, 185], [nil, 186], [nil, 187], [nil, 188]],
[[nil, 189], [nil, 190], [nil, 191], [nil, 192], [nil, 193], [nil, 194], [nil, 195], [nil, 196], [nil, 197], [nil, 198], [nil, 199], [nil, 200], [nil, 201], [nil, 202], [nil, 203], [nil, 204]],
[[199, 17], [199, 18], [199, 19], [199, 20], [199, 21], [199, 22], [199, 23], [199, 7], [207, 17], [207, 18], [207, 19], [207, 20], [207, 21], [207, 22], [207, 23], [207, 7]],
[[234, 17], [234, 18], [234, 19], [234, 20], [234, 21], [234, 22], [234, 23], [234, 7], [235, 17], [235, 18], [235, 19], [235, 20], [235, 21], [235, 22], [235, 23], [235, 7]],
[[192, 25], [192, 26], [192, 27], [192, 6], [193, 25], [193, 26], [193, 27], [193, 6], [200, 25], [200, 26], [200, 27], [200, 6], [201, 25], [201, 26], [201, 27], [201, 6]],
[[202, 25], [202, 26], [202, 27], [202, 6], [205, 25], [205, 26], [205, 27], [205, 6], [210, 25], [210, 26], [210, 27], [210, 6], [213, 25], [213, 26], [213, 27], [213, 6]],
[[218, 25], [218, 26], [218, 27], [218, 6], [219, 25], [219, 26], [219, 27], [219, 6], [238, 25], [238, 26], [238, 27], [238, 6], [240, 25], [240, 26], [240, 27], [240, 6]],
[[242, 25], [242, 26], [242, 27], [242, 6], [243, 25], [243, 26], [243, 27], [243, 6], [255, 25], [255, 26], [255, 27], [255, 6], [203, 29], [203, 5], [204, 29], [204, 5]],
[[211, 29], [211, 5], [212, 29], [212, 5], [214, 29], [214, 5], [221, 29], [221, 5], [222, 29], [222, 5], [223, 29], [223, 5], [241, 29], [241, 5], [244, 29], [244, 5]],
[[245, 29], [245, 5], [246, 29], [246, 5], [247, 29], [247, 5], [248, 29], [248, 5], [250, 29], [250, 5], [251, 29], [251, 5], [252, 29], [252, 5], [253, 29], [253, 5]],
[[254, 29], [254, 5], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [7, 0], [8, 0], [11, 0], [12, 0], [14, 0], [15, 0], [16, 0], [17, 0], [18, 0]],
[[19, 0], [20, 0], [21, 0], [23, 0], [24, 0], [25, 0], [26, 0], [27, 0], [28, 0], [29, 0], [30, 0], [31, 0], [127, 0], [220, 0], [249, 0], [nil, 205]],
[[9, 17], [9, 18], [9, 19], [9, 20], [9, 21], [9, 22], [9, 23], [9, 7], [142, 17], [142, 18], [142, 19], [142, 20], [142, 21], [142, 22], [142, 23], [142, 7]],
[[144, 17], [144, 18], [144, 19], [144, 20], [144, 21], [144, 22], [144, 23], [144, 7], [145, 17], [145, 18], [145, 19], [145, 20], [145, 21], [145, 22], [145, 23], [145, 7]],
[[148, 17], [148, 18], [148, 19], [148, 20], [148, 21], [148, 22], [148, 23], [148, 7], [159, 17], [159, 18], [159, 19], [159, 20], [159, 21], [159, 22], [159, 23], [159, 7]],
[[171, 17], [171, 18], [171, 19], [171, 20], [171, 21], [171, 22], [171, 23], [171, 7], [206, 17], [206, 18], [206, 19], [206, 20], [206, 21], [206, 22], [206, 23], [206, 7]],
[[215, 17], [215, 18], [215, 19], [215, 20], [215, 21], [215, 22], [215, 23], [215, 7], [225, 17], [225, 18], [225, 19], [225, 20], [225, 21], [225, 22], [225, 23], [225, 7]],
[[236, 17], [236, 18], [236, 19], [236, 20], [236, 21], [236, 22], [236, 23], [236, 7], [237, 17], [237, 18], [237, 19], [237, 20], [237, 21], [237, 22], [237, 23], [237, 7]],
[[199, 25], [199, 26], [199, 27], [199, 6], [207, 25], [207, 26], [207, 27], [207, 6], [234, 25], [234, 26], [234, 27], [234, 6], [235, 25], [235, 26], [235, 27], [235, 6]],
[[192, 29], [192, 5], [193, 29], [193, 5], [200, 29], [200, 5], [201, 29], [201, 5], [202, 29], [202, 5], [205, 29], [205, 5], [210, 29], [210, 5], [213, 29], [213, 5]],
[[218, 29], [218, 5], [219, 29], [219, 5], [238, 29], [238, 5], [240, 29], [240, 5], [242, 29], [242, 5], [243, 29], [243, 5], [255, 29], [255, 5], [203, 0], [204, 0]],
[[211, 0], [212, 0], [214, 0], [221, 0], [222, 0], [223, 0], [241, 0], [244, 0], [245, 0], [246, 0], [247, 0], [248, 0], [250, 0], [251, 0], [252, 0], [253, 0]],
[[254, 0], [nil, 206], [nil, 207], [nil, 208], [nil, 209], [nil, 210], [nil, 211], [nil, 212], [nil, 213], [nil, 214], [nil, 215], [nil, 216], [nil, 217], [nil, 218], [nil, 219], [nil, 220]],
[[1, 17], [1, 18], [1, 19], [1, 20], [1, 21], [1, 22], [1, 23], [1, 7], [135, 17], [135, 18], [135, 19], [135, 20], [135, 21], [135, 22], [135, 23], [135, 7]],
[[137, 17], [137, 18], [137, 19], [137, 20], [137, 21], [137, 22], [137, 23], [137, 7], [138, 17], [138, 18], [138, 19], [138, 20], [138, 21], [138, 22], [138, 23], [138, 7]],
[[139, 17], [139, 18], [139, 19], [139, 20], [139, 21], [139, 22], [139, 23], [139, 7], [140, 17], [140, 18], [140, 19], [140, 20], [140, 21], [140, 22], [140, 23], [140, 7]],
[[141, 17], [141, 18], [141, 19], [141, 20], [141, 21], [141, 22], [141, 23], [141, 7], [143, 17], [143, 18], [143, 19], [143, 20], [143, 21], [143, 22], [143, 23], [143, 7]],
[[147, 17], [147, 18], [147, 19], [147, 20], [147, 21], [147, 22], [147, 23], [147, 7], [149, 17], [149, 18], [149, 19], [149, 20], [149, 21], [149, 22], [149, 23], [149, 7]],
[[150, 17], [150, 18], [150, 19], [150, 20], [150, 21], [150, 22], [150, 23], [150, 7], [151, 17], [151, 18], [151, 19], [151, 20], [151, 21], [151, 22], [151, 23], [151, 7]],
[[152, 17], [152, 18], [152, 19], [152, 20], [152, 21], [152, 22], [152, 23], [152, 7], [155, 17], [155, 18], [155, 19], [155, 20], [155, 21], [155, 22], [155, 23], [155, 7]],
[[157, 17], [157, 18], [157, 19], [157, 20], [157, 21], [157, 22], [157, 23], [157, 7], [158, 17], [158, 18], [158, 19], [158, 20], [158, 21], [158, 22], [158, 23], [158, 7]],
[[165, 17], [165, 18], [165, 19], [165, 20], [165, 21], [165, 22], [165, 23], [165, 7], [166, 17], [166, 18], [166, 19], [166, 20], [166, 21], [166, 22], [166, 23], [166, 7]],
[[168, 17], [168, 18], [168, 19], [168, 20], [168, 21], [168, 22], [168, 23], [168, 7], [174, 17], [174, 18], [174, 19], [174, 20], [174, 21], [174, 22], [174, 23], [174, 7]],
[[175, 17], [175, 18], [175, 19], [175, 20], [175, 21], [175, 22], [175, 23], [175, 7], [180, 17], [180, 18], [180, 19], [180, 20], [180, 21], [180, 22], [180, 23], [180, 7]],
[[182, 17], [182, 18], [182, 19], [182, 20], [182, 21], [182, 22], [182, 23], [182, 7], [183, 17], [183, 18], [183, 19], [183, 20], [183, 21], [183, 22], [183, 23], [183, 7]],
[[188, 17], [188, 18], [188, 19], [188, 20], [188, 21], [188, 22], [188, 23], [188, 7], [191, 17], [191, 18], [191, 19], [191, 20], [191, 21], [191, 22], [191, 23], [191, 7]],
[[197, 17], [197, 18], [197, 19], [197, 20], [197, 21], [197, 22], [197, 23], [197, 7], [231, 17], [231, 18], [231, 19], [231, 20], [231, 21], [231, 22], [231, 23], [231, 7]],
[[239, 17], [239, 18], [239, 19], [239, 20], [239, 21], [239, 22], [239, 23], [239, 7], [9, 25], [9, 26], [9, 27], [9, 6], [142, 25], [142, 26], [142, 27], [142, 6]],
[[144, 25], [144, 26], [144, 27], [144, 6], [145, 25], [145, 26], [145, 27], [145, 6], [148, 25], [148, 26], [148, 27], [148, 6], [159, 25], [159, 26], [159, 27], [159, 6]],
[[171, 25], [171, 26], [171, 27], [171, 6], [206, 25], [206, 26], [206, 27], [206, 6], [215, 25], [215, 26], [215, 27], [215, 6], [225, 25], [225, 26], [225, 27], [225, 6]],
[[236, 25], [236, 26], [236, 27], [236, 6], [237, 25], [237, 26], [237, 27], [237, 6], [199, 29], [199, 5], [207, 29], [207, 5], [234, 29], [234, 5], [235, 29], [235, 5]],
[[192, 0], [193, 0], [200, 0], [201, 0], [202, 0], [205, 0], [210, 0], [213, 0], [218, 0], [219, 0], [238, 0], [240, 0], [242, 0], [243, 0], [255, 0], [nil, 8]],
[[nil, 222], [nil, 223], [nil, 224], [nil, 225], [nil, 226], [nil, 227], [nil, 228], [nil, 229], [nil, 230], [nil, 231], [nil, 232], [nil, 233], [nil, 234], [nil, 235], [nil, 236], [nil, 237]],
[[129, 17], [129, 18], [129, 19], [129, 20], [129, 21], [129, 22], [129, 23], [129, 7], [132, 17], [132, 18], [132, 19], [132, 20], [132, 21], [132, 22], [132, 23], [132, 7]],
[[133, 17], [133, 18], [133, 19], [133, 20], [133, 21], [133, 22], [133, 23], [133, 7], [134, 17], [134, 18], [134, 19], [134, 20], [134, 21], [134, 22], [134, 23], [134, 7]],
[[136, 17], [136, 18], [136, 19], [136, 20], [136, 21], [136, 22], [136, 23], [136, 7], [146, 17], [146, 18], [146, 19], [146, 20], [146, 21], [146, 22], [146, 23], [146, 7]],
[[154, 17], [154, 18], [154, 19], [154, 20], [154, 21], [154, 22], [154, 23], [154, 7], [156, 17], [156, 18], [156, 19], [156, 20], [156, 21], [156, 22], [156, 23], [156, 7]],
[[160, 17], [160, 18], [160, 19], [160, 20], [160, 21], [160, 22], [160, 23], [160, 7], [163, 17], [163, 18], [163, 19], [163, 20], [163, 21], [163, 22], [163, 23], [163, 7]],
[[164, 17], [164, 18], [164, 19], [164, 20], [164, 21], [164, 22], [164, 23], [164, 7], [169, 17], [169, 18], [169, 19], [169, 20], [169, 21], [169, 22], [169, 23], [169, 7]],
[[170, 17], [170, 18], [170, 19], [170, 20], [170, 21], [170, 22], [170, 23], [170, 7], [173, 17], [173, 18], [173, 19], [173, 20], [173, 21], [173, 22], [173, 23], [173, 7]],
[[178, 17], [178, 18], [178, 19], [178, 20], [178, 21], [178, 22], [178, 23], [178, 7], [181, 17], [181, 18], [181, 19], [181, 20], [181, 21], [181, 22], [181, 23], [181, 7]],
[[185, 17], [185, 18], [185, 19], [185, 20], [185, 21], [185, 22], [185, 23], [185, 7], [186, 17], [186, 18], [186, 19], [186, 20], [186, 21], [186, 22], [186, 23], [186, 7]],
[[187, 17], [187, 18], [187, 19], [187, 20], [187, 21], [187, 22], [187, 23], [187, 7], [189, 17], [189, 18], [189, 19], [189, 20], [189, 21], [189, 22], [189, 23], [189, 7]],
[[190, 17], [190, 18], [190, 19], [190, 20], [190, 21], [190, 22], [190, 23], [190, 7], [196, 17], [196, 18], [196, 19], [196, 20], [196, 21], [196, 22], [196, 23], [196, 7]],
[[198, 17], [198, 18], [198, 19], [198, 20], [198, 21], [198, 22], [198, 23], [198, 7], [228, 17], [228, 18], [228, 19], [228, 20], [228, 21], [228, 22], [228, 23], [228, 7]],
[[232, 17], [232, 18], [232, 19], [232, 20], [232, 21], [232, 22], [232, 23], [232, 7], [233, 17], [233, 18], [233, 19], [233, 20], [233, 21], [233, 22], [233, 23], [233, 7]],
[[1, 25], [1, 26], [1, 27], [1, 6], [135, 25], [135, 26], [135, 27], [135, 6], [137, 25], [137, 26], [137, 27], [137, 6], [138, 25], [138, 26], [138, 27], [138, 6]],
[[139, 25], [139, 26], [139, 27], [139, 6], [140, 25], [140, 26], [140, 27], [140, 6], [141, 25], [141, 26], [141, 27], [141, 6], [143, 25], [143, 26], [143, 27], [143, 6]],
[[147, 25], [147, 26], [147, 27], [147, 6], [149, 25], [149, 26], [149, 27], [149, 6], [150, 25], [150, 26], [150, 27], [150, 6], [151, 25], [151, 26], [151, 27], [151, 6]],
[[152, 25], [152, 26], [152, 27], [152, 6], [155, 25], [155, 26], [155, 27], [155, 6], [157, 25], [157, 26], [157, 27], [157, 6], [158, 25], [158, 26], [158, 27], [158, 6]],
[[165, 25], [165, 26], [165, 27], [165, 6], [166, 25], [166, 26], [166, 27], [166, 6], [168, 25], [168, 26], [168, 27], [168, 6], [174, 25], [174, 26], [174, 27], [174, 6]],
[[175, 25], [175, 26], [175, 27], [175, 6], [180, 25], [180, 26], [180, 27], [180, 6], [182, 25], [182, 26], [182, 27], [182, 6], [183, 25], [183, 26], [183, 27], [183, 6]],
[[188, 25], [188, 26], [188, 27], [188, 6], [191, 25], [191, 26], [191, 27], [191, 6], [197, 25], [197, 26], [197, 27], [197, 6], [231, 25], [231, 26], [231, 27], [231, 6]],
[[239, 25], [239, 26], [239, 27], [239, 6], [9, 29], [9, 5], [142, 29], [142, 5], [144, 29], [144, 5], [145, 29], [145, 5], [148, 29], [148, 5], [159, 29], [159, 5]],
[[171, 29], [171, 5], [206, 29], [206, 5], [215, 29], [215, 5], [225, 29], [225, 5], [236, 29], [236, 5], [237, 29], [237, 5], [199, 0], [207, 0], [234, 0], [235, 0]],
[[nil, 238], [nil, 239], [nil, 240], [nil, 241], [nil, 242], [nil, 243], [nil, 244], [nil, 245], [nil, 246], [nil, 247], [nil, 248], [nil, 249], [nil, 250], [nil, 251], [nil, 252], [nil, 253]],
[[10, 25], [10, 26], [10, 27], [10, 6], [13, 25], [13, 26], [13, 27], [13, 6], [22, 25], [22, 26], [22, 27], [22, 6], [256, 25], [256, 26], [256, 27], [256, 6]],
[[2, 17], [2, 18], [2, 19], [2, 20], [2, 21], [2, 22], [2, 23], [2, 7], [3, 17], [3, 18], [3, 19], [3, 20], [3, 21], [3, 22], [3, 23], [3, 7]],
[[4, 17], [4, 18], [4, 19], [4, 20], [4, 21], [4, 22], [4, 23], [4, 7], [5, 17], [5, 18], [5, 19], [5, 20], [5, 21], [5, 22], [5, 23], [5, 7]],
[[6, 17], [6, 18], [6, 19], [6, 20], [6, 21], [6, 22], [6, 23], [6, 7], [7, 17], [7, 18], [7, 19], [7, 20], [7, 21], [7, 22], [7, 23], [7, 7]],
[[8, 17], [8, 18], [8, 19], [8, 20], [8, 21], [8, 22], [8, 23], [8, 7], [11, 17], [11, 18], [11, 19], [11, 20], [11, 21], [11, 22], [11, 23], [11, 7]],
[[12, 17], [12, 18], [12, 19], [12, 20], [12, 21], [12, 22], [12, 23], [12, 7], [14, 17], [14, 18], [14, 19], [14, 20], [14, 21], [14, 22], [14, 23], [14, 7]],
[[15, 17], [15, 18], [15, 19], [15, 20], [15, 21], [15, 22], [15, 23], [15, 7], [16, 17], [16, 18], [16, 19], [16, 20], [16, 21], [16, 22], [16, 23], [16, 7]],
[[17, 17], [17, 18], [17, 19], [17, 20], [17, 21], [17, 22], [17, 23], [17, 7], [18, 17], [18, 18], [18, 19], [18, 20], [18, 21], [18, 22], [18, 23], [18, 7]],
[[19, 17], [19, 18], [19, 19], [19, 20], [19, 21], [19, 22], [19, 23], [19, 7], [20, 17], [20, 18], [20, 19], [20, 20], [20, 21], [20, 22], [20, 23], [20, 7]],
[[21, 17], [21, 18], [21, 19], [21, 20], [21, 21], [21, 22], [21, 23], [21, 7], [23, 17], [23, 18], [23, 19], [23, 20], [23, 21], [23, 22], [23, 23], [23, 7]],
[[24, 17], [24, 18], [24, 19], [24, 20], [24, 21], [24, 22], [24, 23], [24, 7], [25, 17], [25, 18], [25, 19], [25, 20], [25, 21], [25, 22], [25, 23], [25, 7]],
[[26, 17], [26, 18], [26, 19], [26, 20], [26, 21], [26, 22], [26, 23], [26, 7], [27, 17], [27, 18], [27, 19], [27, 20], [27, 21], [27, 22], [27, 23], [27, 7]],
[[28, 17], [28, 18], [28, 19], [28, 20], [28, 21], [28, 22], [28, 23], [28, 7], [29, 17], [29, 18], [29, 19], [29, 20], [29, 21], [29, 22], [29, 23], [29, 7]],
[[30, 17], [30, 18], [30, 19], [30, 20], [30, 21], [30, 22], [30, 23], [30, 7], [31, 17], [31, 18], [31, 19], [31, 20], [31, 21], [31, 22], [31, 23], [31, 7]],
[[127, 17], [127, 18], [127, 19], [127, 20], [127, 21], [127, 22], [127, 23], [127, 7], [220, 17], [220, 18], [220, 19], [220, 20], [220, 21], [220, 22], [220, 23], [220, 7]],
[[249, 17], [249, 18], [249, 19], [249, 20], [249, 21], [249, 22], [249, 23], [249, 7], [10, 29], [10, 5], [13, 29], [13, 5], [22, 29], [22, 5], [256, 29], [256, 5]],
[[54, 25], [54, 26], [54, 27], [54, 6], [55, 25], [55, 26], [55, 27], [55, 6], [56, 25], [56, 26], [56, 27], [56, 6], [57, 25], [57, 26], [57, 27], [57, 6]],
[[211, 17], [211, 18], [211, 19], [211, 20], [211, 21], [211, 22], [211, 23], [211, 7], [212, 17], [212, 18], [212, 19], [212, 20], [212, 21], [212, 22], [212, 23], [212, 7]],
[[214, 17], [214, 18], [214, 19], [214, 20], [214, 21], [214, 22], [214, 23], [214, 7], [221, 17], [221, 18], [221, 19], [221, 20], [221, 21], [221, 22], [221, 23], [221, 7]],
[[222, 17], [222, 18], [222, 19], [222, 20], [222, 21], [222, 22], [222, 23], [222, 7], [223, 17], [223, 18], [223, 19], [223, 20], [223, 21], [223, 22], [223, 23], [223, 7]],
[[241, 17], [241, 18], [241, 19], [241, 20], [241, 21], [241, 22], [241, 23], [241, 7], [244, 17], [244, 18], [244, 19], [244, 20], [244, 21], [244, 22], [244, 23], [244, 7]],
[[245, 17], [245, 18], [245, 19], [245, 20], [245, 21], [245, 22], [245, 23], [245, 7], [246, 17], [246, 18], [246, 19], [246, 20], [246, 21], [246, 22], [246, 23], [246, 7]],
[[247, 17], [247, 18], [247, 19], [247, 20], [247, 21], [247, 22], [247, 23], [247, 7], [248, 17], [248, 18], [248, 19], [248, 20], [248, 21], [248, 22], [248, 23], [248, 7]],
[[250, 17], [250, 18], [250, 19], [250, 20], [250, 21], [250, 22], [250, 23], [250, 7], [251, 17], [251, 18], [251, 19], [251, 20], [251, 21], [251, 22], [251, 23], [251, 7]],
[[252, 17], [252, 18], [252, 19], [252, 20], [252, 21], [252, 22], [252, 23], [252, 7], [253, 17], [253, 18], [253, 19], [253, 20], [253, 21], [253, 22], [253, 23], [253, 7]],
[[254, 17], [254, 18], [254, 19], [254, 20], [254, 21], [254, 22], [254, 23], [254, 7], [2, 25], [2, 26], [2, 27], [2, 6], [3, 25], [3, 26], [3, 27], [3, 6]],
[[4, 25], [4, 26], [4, 27], [4, 6], [5, 25], [5, 26], [5, 27], [5, 6], [6, 25], [6, 26], [6, 27], [6, 6], [7, 25], [7, 26], [7, 27], [7, 6]],
[[8, 25], [8, 26], [8, 27], [8, 6], [11, 25], [11, 26], [11, 27], [11, 6], [12, 25], [12, 26], [12, 27], [12, 6], [14, 25], [14, 26], [14, 27], [14, 6]],
[[15, 25], [15, 26], [15, 27], [15, 6], [16, 25], [16, 26], [16, 27], [16, 6], [17, 25], [17, 26], [17, 27], [17, 6], [18, 25], [18, 26], [18, 27], [18, 6]],
[[19, 25], [19, 26], [19, 27], [19, 6], [20, 25], [20, 26], [20, 27], [20, 6], [21, 25], [21, 26], [21, 27], [21, 6], [23, 25], [23, 26], [23, 27], [23, 6]],
[[24, 25], [24, 26], [24, 27], [24, 6], [25, 25], [25, 26], [25, 27], [25, 6], [26, 25], [26, 26], [26, 27], [26, 6], [27, 25], [27, 26], [27, 27], [27, 6]],
[[28, 25], [28, 26], [28, 27], [28, 6], [29, 25], [29, 26], [29, 27], [29, 6], [30, 25], [30, 26], [30, 27], [30, 6], [31, 25], [31, 26], [31, 27], [31, 6]],
[[127, 25], [127, 26], [127, 27], [127, 6], [220, 25], [220, 26], [220, 27], [220, 6], [249, 25], [249, 26], [249, 27], [249, 6], [10, 0], [13, 0], [22, 0], [256, 0]],
[[192, 17], [192, 18], [192, 19], [192, 20], [192, 21], [192, 22], [192, 23], [192, 7], [193, 17], [193, 18], [193, 19], [193, 20], [193, 21], [193, 22], [193, 23], [193, 7]],
[[200, 17], [200, 18], [200, 19], [200, 20], [200, 21], [200, 22], [200, 23], [200, 7], [201, 17], [201, 18], [201, 19], [201, 20], [201, 21], [201, 22], [201, 23], [201, 7]],
[[202, 17], [202, 18], [202, 19], [202, 20], [202, 21], [202, 22], [202, 23], [202, 7], [205, 17], [205, 18], [205, 19], [205, 20], [205, 21], [205, 22], [205, 23], [205, 7]],
[[210, 17], [210, 18], [210, 19], [210, 20], [210, 21], [210, 22], [210, 23], [210, 7], [213, 17], [213, 18], [213, 19], [213, 20], [213, 21], [213, 22], [213, 23], [213, 7]],
[[218, 17], [218, 18], [218, 19], [218, 20], [218, 21], [218, 22], [218, 23], [218, 7], [219, 17], [219, 18], [219, 19], [219, 20], [219, 21], [219, 22], [219, 23], [219, 7]],
[[238, 17], [238, 18], [238, 19], [238, 20], [238, 21], [238, 22], [238, 23], [238, 7], [240, 17], [240, 18], [240, 19], [240, 20], [240, 21], [240, 22], [240, 23], [240, 7]],
[[242, 17], [242, 18], [242, 19], [242, 20], [242, 21], [242, 22], [242, 23], [242, 7], [243, 17], [243, 18], [243, 19], [243, 20], [243, 21], [243, 22], [243, 23], [243, 7]],
[[255, 17], [255, 18], [255, 19], [255, 20], [255, 21], [255, 22], [255, 23], [255, 7], [203, 25], [203, 26], [203, 27], [203, 6], [204, 25], [204, 26], [204, 27], [204, 6]],
[[211, 25], [211, 26], [211, 27], [211, 6], [212, 25], [212, 26], [212, 27], [212, 6], [214, 25], [214, 26], [214, 27], [214, 6], [221, 25], [221, 26], [221, 27], [221, 6]],
[[222, 25], [222, 26], [222, 27], [222, 6], [223, 25], [223, 26], [223, 27], [223, 6], [241, 25], [241, 26], [241, 27], [241, 6], [244, 25], [244, 26], [244, 27], [244, 6]],
[[245, 25], [245, 26], [245, 27], [245, 6], [246, 25], [246, 26], [246, 27], [246, 6], [247, 25], [247, 26], [247, 27], [247, 6], [248, 25], [248, 26], [248, 27], [248, 6]],
[[250, 25], [250, 26], [250, 27], [250, 6], [251, 25], [251, 26], [251, 27], [251, 6], [252, 25], [252, 26], [252, 27], [252, 6], [253, 25], [253, 26], [253, 27], [253, 6]],
[[254, 25], [254, 26], [254, 27], [254, 6], [2, 29], [2, 5], [3, 29], [3, 5], [4, 29], [4, 5], [5, 29], [5, 5], [6, 29], [6, 5], [7, 29], [7, 5]],
[[8, 29], [8, 5], [11, 29], [11, 5], [12, 29], [12, 5], [14, 29], [14, 5], [15, 29], [15, 5], [16, 29], [16, 5], [17, 29], [17, 5], [18, 29], [18, 5]],
[[19, 29], [19, 5], [20, 29], [20, 5], [21, 29], [21, 5], [23, 29], [23, 5], [24, 29], [24, 5], [25, 29], [25, 5], [26, 29], [26, 5], [27, 29], [27, 5]],
[[28, 29], [28, 5], [29, 29], [29, 5], [30, 29], [30, 5], [31, 29], [31, 5], [127, 29], [127, 5], [220, 29], [220, 5], [249, 29], [249, 5], [nil, 254], [nil, 255]],
[[10, 17], [10, 18], [10, 19], [10, 20], [10, 21], [10, 22], [10, 23], [10, 7], [13, 17], [13, 18], [13, 19], [13, 20], [13, 21], [13, 22], [13, 23], [13, 7]],
[[22, 17], [22, 18], [22, 19], [22, 20], [22, 21], [22, 22], [22, 23], [22, 7], [256, 17], [256, 18], [256, 19], [256, 20], [256, 21], [256, 22], [256, 23], [256, 7]],
].each { |arr| arr.each { |subarr| subarr.each(&:freeze) }.freeze }.freeze
end
end
end
module HTTP2
module Header
class EncodingContext
include Error
STATIC_TABLE = [
[':authority',                  ''],
[':method',                     'GET'],
[':method',                     'POST'],
[':path',                       '/'],
[':path',                       '/index.html'],
[':scheme',                     'http'],
[':scheme',                     'https'],
[':status',                     '200'],
[':status',                     '204'],
[':status',                     '206'],
[':status',                     '304'],
[':status',                     '400'],
[':status',                     '404'],
[':status',                     '500'],
['accept-charset',              ''],
['accept-encoding',             'gzip, deflate'],
['accept-language',             ''],
['accept-ranges',               ''],
['accept',                      ''],
['access-control-allow-origin', ''],
['age',                         ''],
['allow',                       ''],
['authorization',               ''],
['cache-control',               ''],
['content-disposition',         ''],
['content-encoding',            ''],
['content-language',            ''],
['content-length',              ''],
['content-location',            ''],
['content-range',               ''],
['content-type',                ''],
['cookie',                      ''],
['date',                        ''],
['etag',                        ''],
['expect',                      ''],
['expires',                     ''],
['from',                        ''],
['host',                        ''],
['if-match',                    ''],
['if-modified-since',           ''],
['if-none-match',               ''],
['if-range',                    ''],
['if-unmodified-since',         ''],
['last-modified',               ''],
['link',                        ''],
['location',                    ''],
['max-forwards',                ''],
['proxy-authenticate',          ''],
['proxy-authorization',         ''],
['range',                       ''],
['referer',                     ''],
['refresh',                     ''],
['retry-after',                 ''],
['server',                      ''],
['set-cookie',                  ''],
['strict-transport-security',   ''],
['transfer-encoding',           ''],
['user-agent',                  ''],
['vary',                        ''],
['via',                         ''],
['www-authenticate',            ''],
].each { |pair| pair.each(&:freeze).freeze }.freeze
attr_reader :table
attr_reader :options
def initialize(**options)
default_options = {
huffman:    :shorter,
index:      :all,
table_size: 4096,
}
@table = []
@options = default_options.merge(options)
@limit = @options[:table_size]
end
def dup
other = EncodingContext.new(@options)
t = @table
l = @limit
other.instance_eval do
@table = t.dup              # shallow copy
@limit = l
end
other
end
def dereference(index)
value = STATIC_TABLE[index] || @table[index - STATIC_TABLE.size]
fail CompressionError, 'Index too large' unless value
value
end
def process(cmd)
emit = nil
case cmd[:type]
when :changetablesize
self.table_size = cmd[:value]
when :indexed
idx = cmd[:name]
k, v = dereference(idx)
emit = [k, v]
when :incremental, :noindex, :neverindexed
if cmd[:name].is_a? Integer
k, v = dereference(cmd[:name])
cmd = cmd.dup
cmd[:index] ||= cmd[:name]
cmd[:value] ||= v
cmd[:name] = k
end
emit = [cmd[:name], cmd[:value]]
add_to_table(emit) if cmd[:type] == :incremental
else
fail CompressionError, "Invalid type: #{cmd[:type]}"
end
emit
end
def encode(headers)
commands = []
noindex = [:static, :never].include?(@options[:index])
headers.each do |field, value|
field = field.downcase
value = '/' if field == ':path' && value.empty?
cmd = addcmd(field, value)
cmd[:type] = :noindex if noindex && cmd[:type] == :incremental
commands << cmd
process(cmd)
end
commands
end
def addcmd(*header)
exact = nil
name_only = nil
if [:all, :static].include?(@options[:index])
STATIC_TABLE.each_index do |i|
if STATIC_TABLE[i] == header
exact ||= i
break
elsif STATIC_TABLE[i].first == header.first
name_only ||= i
end
end
end
if [:all].include?(@options[:index]) && !exact
@table.each_index do |i|
if @table[i] == header
exact ||= i + STATIC_TABLE.size
break
elsif @table[i].first == header.first
name_only ||= i + STATIC_TABLE.size
end
end
end
if exact
{ name: exact, type: :indexed }
elsif name_only
{ name: name_only, value: header.last, type: :incremental }
else
{ name: header.first, value: header.last, type: :incremental }
end
end
def table_size=(size)
@limit = size
size_check(nil)
end
def current_table_size
@table.inject(0) { |r, (k, v)| r + k.bytesize + v.bytesize + 32 }
end
private
def add_to_table(cmd)
return unless size_check(cmd)
@table.unshift(cmd)
end
def size_check(cmd)
cursize = current_table_size
cmdsize = cmd.nil? ? 0 : cmd[0].bytesize + cmd[1].bytesize + 32
while cursize + cmdsize > @limit
break if @table.empty?
e = @table.pop
cursize -= e[0].bytesize + e[1].bytesize + 32
end
cmdsize <= @limit
end
end
HEADREP = {
indexed:      { prefix: 7, pattern: 0x80 },
incremental:  { prefix: 6, pattern: 0x40 },
noindex:      { prefix: 4, pattern: 0x00 },
neverindexed: { prefix: 4, pattern: 0x10 },
changetablesize: { prefix: 5, pattern: 0x20 },
}.each_value(&:freeze).freeze
NAIVE    = { index: :never,  huffman: :never   }.freeze
LINEAR   = { index: :all,    huffman: :never   }.freeze
STATIC   = { index: :static, huffman: :never   }.freeze
SHORTER  = { index: :all,    huffman: :never   }.freeze
NAIVEH   = { index: :never,  huffman: :always  }.freeze
LINEARH  = { index: :all,    huffman: :always  }.freeze
STATICH  = { index: :static, huffman: :always  }.freeze
SHORTERH = { index: :all,    huffman: :shorter }.freeze
class Compressor
def initialize(**options)
@cc = EncodingContext.new(options)
end
def table_size=(size)
@cc.table_size = size
end
def integer(i, n)
limit = 2**n - 1
return [i].pack('C') if i < limit
bytes = []
bytes.push limit unless n.zero?
i -= limit
while (i >= 128)
bytes.push((i % 128) + 128)
i /= 128
end
bytes.push i
bytes.pack('C*')
end
def string(str)
plain, huffman = nil, nil
unless @cc.options[:huffman] == :always
plain = integer(str.bytesize, 7) << str.dup.force_encoding(Encoding::BINARY)
end
unless @cc.options[:huffman] == :never
huffman = Huffman.new.encode(str)
huffman = integer(huffman.bytesize, 7) << huffman
huffman.setbyte(0, huffman.ord | 0x80)
end
case @cc.options[:huffman]
when :always
huffman
when :never
plain
else
huffman.bytesize < plain.bytesize ? huffman : plain
end
end
def header(h, buffer = Buffer.new)
rep = HEADREP[h[:type]]
case h[:type]
when :indexed
buffer << integer(h[:name] + 1, rep[:prefix])
when :changetablesize
buffer << integer(h[:value], rep[:prefix])
else
if h[:name].is_a? Integer
buffer << integer(h[:name] + 1, rep[:prefix])
else
buffer << integer(0, rep[:prefix])
buffer << string(h[:name])
end
buffer << string(h[:value])
end
fb = buffer.ord | rep[:pattern]
buffer.setbyte(0, fb)
buffer
end
def encode(headers)
buffer = Buffer.new
pseudo_headers, regular_headers = headers.partition { |f, _| f.start_with? ':' }
headers = [*pseudo_headers, *regular_headers]
commands = @cc.encode(headers)
commands.each do |cmd|
buffer << header(cmd)
end
buffer
end
end
class Decompressor
def initialize(**options)
@cc = EncodingContext.new(options)
end
def table_size=(size)
@cc.table_size = size
end
def integer(buf, n)
limit = 2**n - 1
i = !n.zero? ? (buf.getbyte & limit) : 0
m = 0
while (byte = buf.getbyte)
i += ((byte & 127) << m)
m += 7
break if (byte & 128).zero?
end if (i == limit)
i
end
def string(buf)
huffman = (buf.readbyte(0) & 0x80) == 0x80
len = integer(buf, 7)
str = buf.read(len)
fail CompressionError, 'string too short' unless str.bytesize == len
str = Huffman.new.decode(Buffer.new(str)) if huffman
str.force_encoding(Encoding::UTF_8)
end
def header(buf)
peek = buf.readbyte(0)
header = {}
header[:type], type = HEADREP.find do |_t, desc|
mask = (peek >> desc[:prefix]) << desc[:prefix]
mask == desc[:pattern]
end
fail CompressionError unless header[:type]
header[:name] = integer(buf, type[:prefix])
case header[:type]
when :indexed
fail CompressionError if (header[:name]).zero?
header[:name] -= 1
when :changetablesize
header[:value] = header[:name]
else
if (header[:name]).zero?
header[:name] = string(buf)
else
header[:name] -= 1
end
header[:value] = string(buf)
end
header
end
def decode(buf)
list = []
decoding_pseudo_headers = true
until buf.empty?
next_header = @cc.process(header(buf))
next if next_header.nil?
is_pseudo_header = next_header.first.start_with? ':'
if !decoding_pseudo_headers && is_pseudo_header
fail ProtocolError, 'one or more pseudo headers encountered after regular headers'
end
decoding_pseudo_headers = is_pseudo_header
list << next_header
end
list
end
end
end
end
module HTTP2
class Framer
include Error
DEFAULT_MAX_FRAME_SIZE = 2**14
attr_accessor :max_frame_size
MAX_STREAM_ID = 0x7fffffff
MAX_WINDOWINC = 0x7fffffff
FRAME_TYPES = {
data:          0x0,
headers:       0x1,
priority:      0x2,
rst_stream:    0x3,
settings:      0x4,
push_promise:  0x5,
ping:          0x6,
goaway:        0x7,
window_update: 0x8,
continuation:  0x9,
altsvc:        0xa,
}.freeze
FRAME_TYPES_WITH_PADDING = [:data, :headers, :push_promise].freeze
FRAME_FLAGS = {
data: {
end_stream:  0,
padded: 3,
compressed: 5,
},
headers: {
end_stream:  0,
end_headers: 2,
padded: 3,
priority: 5,
},
priority:     {},
rst_stream:   {},
settings:     { ack: 0 },
push_promise: {
end_headers: 2,
padded: 3,
},
ping:         { ack: 0 },
goaway:       {},
window_update: {},
continuation: { end_headers: 2 },
altsvc: {},
}.each_value(&:freeze).freeze
DEFINED_SETTINGS = {
settings_header_table_size:      1,
settings_enable_push:            2,
settings_max_concurrent_streams: 3,
settings_initial_window_size:    4,
settings_max_frame_size:         5,
settings_max_header_list_size:   6,
}.freeze
DEFINED_ERRORS = {
no_error:           0,
protocol_error:     1,
internal_error:     2,
flow_control_error: 3,
settings_timeout:   4,
stream_closed:      5,
frame_size_error:   6,
refused_stream:     7,
cancel:             8,
compression_error:  9,
connect_error:      10,
enhance_your_calm:  11,
inadequate_security: 12,
http_1_1_required:  13,
}.freeze
RBIT  = 0x7fffffff
RBYTE = 0x0fffffff
EBIT  = 0x80000000
UINT32 = 'N'.freeze
UINT16 = 'n'.freeze
UINT8  = 'C'.freeze
HEADERPACK = (UINT8 + UINT16 + UINT8 + UINT8 + UINT32).freeze
FRAME_LENGTH_HISHIFT = 16
FRAME_LENGTH_LOMASK  = 0xFFFF
private_constant :RBIT, :RBYTE, :EBIT, :HEADERPACK, :UINT32, :UINT16, :UINT8
def initialize
@max_frame_size = DEFAULT_MAX_FRAME_SIZE
end
def common_header(frame)
header = []
unless FRAME_TYPES[frame[:type]]
fail CompressionError, "Invalid frame type (#{frame[:type]})"
end
if frame[:length] > @max_frame_size
fail CompressionError, "Frame size is too large: #{frame[:length]}"
end
if frame[:length] < 0
fail CompressionError, "Frame size is invalid: #{frame[:length]}"
end
if frame[:stream] > MAX_STREAM_ID
fail CompressionError, "Stream ID (#{frame[:stream]}) is too large"
end
if frame[:type] == :window_update && frame[:increment] > MAX_WINDOWINC
fail CompressionError, "Window increment (#{frame[:increment]}) is too large"
end
header << (frame[:length] >> FRAME_LENGTH_HISHIFT)
header << (frame[:length] & FRAME_LENGTH_LOMASK)
header << FRAME_TYPES[frame[:type]]
header << frame[:flags].reduce(0) do |acc, f|
position = FRAME_FLAGS[frame[:type]][f]
unless position
fail CompressionError, "Invalid frame flag (#{f}) for #{frame[:type]}"
end
acc | (1 << position)
end
header << frame[:stream]
header.pack(HEADERPACK) # 8+16,8,8,32
end
def read_common_header(buf)
frame = {}
len_hi, len_lo, type, flags, stream = buf.slice(0, 9).unpack(HEADERPACK)
frame[:length] = (len_hi << FRAME_LENGTH_HISHIFT) | len_lo
frame[:type], _ = FRAME_TYPES.find { |_t, pos| type == pos }
if frame[:type]
frame[:flags] = FRAME_FLAGS[frame[:type]].each_with_object([]) do |(name, pos), acc|
acc << name if (flags & (1 << pos)) > 0
end
end
frame[:stream] = stream & RBIT
frame
end
def generate(frame)
bytes  = Buffer.new
length = 0
frame[:flags] ||= []
frame[:stream] ||= 0
case frame[:type]
when :data
bytes << frame[:payload]
length += frame[:payload].bytesize
when :headers
if frame[:weight] || frame[:stream_dependency] || !frame[:exclusive].nil?
unless frame[:weight] && frame[:stream_dependency] && !frame[:exclusive].nil?
fail CompressionError, "Must specify all of priority parameters for #{frame[:type]}"
end
frame[:flags] += [:priority] unless frame[:flags].include? :priority
end
if frame[:flags].include? :priority
bytes << [(frame[:exclusive] ? EBIT : 0) | (frame[:stream_dependency] & RBIT)].pack(UINT32)
bytes << [frame[:weight] - 1].pack(UINT8)
length += 5
end
bytes << frame[:payload]
length += frame[:payload].bytesize
when :priority
unless frame[:weight] && frame[:stream_dependency] && !frame[:exclusive].nil?
fail CompressionError, "Must specify all of priority parameters for #{frame[:type]}"
end
bytes << [(frame[:exclusive] ? EBIT : 0) | (frame[:stream_dependency] & RBIT)].pack(UINT32)
bytes << [frame[:weight] - 1].pack(UINT8)
length += 5
when :rst_stream
bytes << pack_error(frame[:error])
length += 4
when :settings
if (frame[:stream]).nonzero?
fail CompressionError, "Invalid stream ID (#{frame[:stream]})"
end
frame[:payload].each do |(k, v)|
if k.is_a? Integer
DEFINED_SETTINGS.value?(k) || next
else
k = DEFINED_SETTINGS[k]
fail CompressionError, "Unknown settings ID for #{k}" if k.nil?
end
bytes << [k].pack(UINT16)
bytes << [v].pack(UINT32)
length += 6
end
when :push_promise
bytes << [frame[:promise_stream] & RBIT].pack(UINT32)
bytes << frame[:payload]
length += 4 + frame[:payload].bytesize
when :ping
if frame[:payload].bytesize != 8
fail CompressionError, "Invalid payload size (#{frame[:payload].size} != 8 bytes)"
end
bytes << frame[:payload]
length += 8
when :goaway
bytes << [frame[:last_stream] & RBIT].pack(UINT32)
bytes << pack_error(frame[:error])
length += 8
if frame[:payload]
bytes << frame[:payload]
length += frame[:payload].bytesize
end
when :window_update
bytes << [frame[:increment] & RBIT].pack(UINT32)
length += 4
when :continuation
bytes << frame[:payload]
length += frame[:payload].bytesize
when :altsvc
bytes << [frame[:max_age], frame[:port]].pack(UINT32 + UINT16)
length += 6
if frame[:proto]
fail CompressionError, 'Proto too long' if frame[:proto].bytesize > 255
bytes << [frame[:proto].bytesize].pack(UINT8)
bytes << frame[:proto].force_encoding(Encoding::BINARY)
length += 1 + frame[:proto].bytesize
else
bytes << [0].pack(UINT8)
length += 1
end
if frame[:host]
fail CompressionError, 'Host too long' if frame[:host].bytesize > 255
bytes << [frame[:host].bytesize].pack(UINT8)
bytes << frame[:host].force_encoding(Encoding::BINARY)
length += 1 + frame[:host].bytesize
else
bytes << [0].pack(UINT8)
length += 1
end
if frame[:origin]
bytes << frame[:origin]
length += frame[:origin].bytesize
end
end
if frame[:padding]
unless FRAME_TYPES_WITH_PADDING.include?(frame[:type])
fail CompressionError, "Invalid padding flag for #{frame[:type]}"
end
padlen = frame[:padding]
if padlen <= 0 || padlen > 256 || padlen + length > @max_frame_size
fail CompressionError, "Invalid padding #{padlen}"
end
length += padlen
bytes.prepend([padlen -= 1].pack(UINT8))
frame[:flags] << :padded
bytes << "\0" * padlen
end
frame[:length] = length
bytes.prepend(common_header(frame))
end
def parse(buf)
return nil if buf.size < 9
frame = read_common_header(buf)
return nil if buf.size < 9 + frame[:length]
fail ProtocolError, 'payload too large' if frame[:length] > DEFAULT_MAX_FRAME_SIZE
buf.read(9)
payload = buf.read(frame[:length])
return nil if frame[:type].nil?
padlen = 0
if FRAME_TYPES_WITH_PADDING.include?(frame[:type])
padded = frame[:flags].include?(:padded)
if padded
padlen = payload.read(1).unpack(UINT8).first
frame[:padding] = padlen + 1
fail ProtocolError, 'padding too long' if padlen > payload.bytesize
payload.slice!(-padlen, padlen) if padlen > 0
frame[:length] -= frame[:padding]
frame[:flags].delete(:padded)
end
end
case frame[:type]
when :data
frame[:payload] = payload.read(frame[:length])
when :headers
if frame[:flags].include? :priority
e_sd = payload.read_uint32
frame[:stream_dependency] = e_sd & RBIT
frame[:exclusive] = (e_sd & EBIT) != 0
frame[:weight] = payload.getbyte + 1
end
frame[:payload] = payload.read(frame[:length])
when :priority
e_sd = payload.read_uint32
frame[:stream_dependency] = e_sd & RBIT
frame[:exclusive] = (e_sd & EBIT) != 0
frame[:weight] = payload.getbyte + 1
when :rst_stream
frame[:error] = unpack_error payload.read_uint32
when :settings
frame[:payload] = []
unless (frame[:length] % 6).zero?
fail ProtocolError, 'Invalid settings payload length'
end
if (frame[:stream]).nonzero?
fail ProtocolError, "Invalid stream ID (#{frame[:stream]})"
end
(frame[:length] / 6).times do
id  = payload.read(2).unpack(UINT16).first
val = payload.read_uint32
name, _ = DEFINED_SETTINGS.find { |_name, v| v == id }
frame[:payload] << [name, val] if name
end
when :push_promise
frame[:promise_stream] = payload.read_uint32 & RBIT
frame[:payload] = payload.read(frame[:length])
when :ping
frame[:payload] = payload.read(frame[:length])
when :goaway
frame[:last_stream] = payload.read_uint32 & RBIT
frame[:error] = unpack_error payload.read_uint32
size = frame[:length] - 8 # for last_stream and error
frame[:payload] = payload.read(size) if size > 0
when :window_update
frame[:increment] = payload.read_uint32 & RBIT
when :continuation
frame[:payload] = payload.read(frame[:length])
when :altsvc
frame[:max_age], frame[:port] = payload.read(6).unpack(UINT32 + UINT16)
len = payload.getbyte
frame[:proto] = payload.read(len) if len > 0
len = payload.getbyte
frame[:host] = payload.read(len) if len > 0
frame[:origin] = payload.read(payload.size) if payload.size > 0
end
frame
end
private
def pack_error(e)
unless e.is_a? Integer
if DEFINED_ERRORS[e].nil?
fail CompressionError, "Unknown error ID for #{e}"
end
e = DEFINED_ERRORS[e]
end
[e].pack(UINT32)
end
def unpack_error(e)
name, _ = DEFINED_ERRORS.find { |_name, v| v == e }
name || error
end
end
end
module HTTP2
DEFAULT_FLOW_WINDOW = 65_535
DEFAULT_HEADER_SIZE = 4096
DEFAULT_MAX_CONCURRENT_STREAMS = 100
SPEC_DEFAULT_CONNECTION_SETTINGS = {
settings_header_table_size:       4096,
settings_enable_push:             1,                     # enabled for servers
settings_max_concurrent_streams:  Framer::MAX_STREAM_ID, # unlimited
settings_initial_window_size:     65_535,
settings_max_frame_size:          16_384,
settings_max_header_list_size:    2**31 - 1,             # unlimited
}.freeze
DEFAULT_CONNECTION_SETTINGS = {
settings_header_table_size:       4096,
settings_enable_push:             1,                     # enabled for servers
settings_max_concurrent_streams:  100,
settings_initial_window_size:     65_535,
settings_max_frame_size:          16_384,
settings_max_header_list_size:    2**31 - 1,             # unlimited
}.freeze
DEFAULT_WEIGHT    = 16
CONNECTION_PREFACE_MAGIC = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".freeze
class Connection
include FlowBuffer
include Emitter
include Error
attr_reader :state
attr_reader :local_window
attr_reader :remote_window
alias window local_window
attr_reader :local_settings
attr_reader :remote_settings
attr_reader :pending_settings
attr_reader :active_stream_count
def initialize(**settings)
@local_settings  = DEFAULT_CONNECTION_SETTINGS.merge(settings)
@remote_settings = SPEC_DEFAULT_CONNECTION_SETTINGS.dup
@compressor   = Header::Compressor.new(settings)
@decompressor = Header::Decompressor.new(settings)
@active_stream_count = 0
@streams = {}
@streams_recently_closed = {}
@pending_settings = []
@framer = Framer.new
@local_window_limit = @local_settings[:settings_initial_window_size]
@local_window = @local_window_limit
@remote_window_limit = @remote_settings[:settings_initial_window_size]
@remote_window = @remote_window_limit
@recv_buffer = Buffer.new
@send_buffer = []
@continuation = []
@error = nil
@h2c_upgrade = nil
@closed_since = nil
end
def closed?
@state == :closed
end
def new_stream(**args)
fail ConnectionClosed if @state == :closed
fail StreamLimitExceeded if @active_stream_count >= @remote_settings[:settings_max_concurrent_streams]
stream = activate_stream(id: @stream_id, **args)
@stream_id += 2
stream
end
def ping(payload, &blk)
send(type: :ping, stream: 0, payload: payload)
once(:ack, &blk) if blk
end
def goaway(error = :no_error, payload = nil)
last_stream = if (max = @streams.max)
max.first
else
0
end
send(type: :goaway, last_stream: last_stream,
error: error, payload: payload)
@state = :closed
@closed_since = Time.now
end
def window_update(increment)
@local_window += increment
send(type: :window_update, stream: 0, increment: increment)
end
def settings(payload)
payload = payload.to_a
connection_error if validate_settings(@local_role, payload)
@pending_settings << payload
send(type: :settings, stream: 0, payload: payload)
@pending_settings << payload
end
def receive(data)
@recv_buffer << data
if @state == :waiting_magic
if @recv_buffer.size < 24
if !CONNECTION_PREFACE_MAGIC.start_with? @recv_buffer
fail HandshakeError
else
return # maybe next time
end
elsif @recv_buffer.read(24) == CONNECTION_PREFACE_MAGIC
@state = :waiting_connection_preface
payload = @local_settings.reject { |k, v| v == SPEC_DEFAULT_CONNECTION_SETTINGS[k] }
settings(payload)
else
fail HandshakeError
end
end
while (frame = @framer.parse(@recv_buffer))
emit(:frame_received, frame)
unless @continuation.empty?
unless frame[:type] == :continuation && frame[:stream] == @continuation.first[:stream]
connection_error
end
@continuation << frame
return unless frame[:flags].include? :end_headers
payload = @continuation.map { |f| f[:payload] }.join
frame = @continuation.shift
@continuation.clear
frame.delete(:length)
frame[:payload] = Buffer.new(payload)
frame[:flags] << :end_headers
end
if connection_frame?(frame)
connection_management(frame)
else
case frame[:type]
when :headers
connection_error if frame[:stream].even? && self.is_a?(Server)
unless frame[:flags].include? :end_headers
@continuation << frame
return
end
decode_headers(frame)
return if @state == :closed
stream = @streams[frame[:stream]]
if stream.nil?
stream = activate_stream(
id:         frame[:stream],
weight:     frame[:weight] || DEFAULT_WEIGHT,
dependency: frame[:dependency] || 0,
exclusive:  frame[:exclusive] || false,
)
emit(:stream, stream)
end
stream << frame
when :push_promise
unless frame[:flags].include? :end_headers
@continuation << frame
return
end
decode_headers(frame)
return if @state == :closed
parent = @streams[frame[:stream]]
pid = frame[:promise_stream]
if @streams_recently_closed[frame[:stream]]
send(type: :rst_stream, stream: pid, error: :refused_stream)
return
end
connection_error(msg: 'missing parent ID') if parent.nil?
unless parent.state == :open || parent.state == :half_closed_local
if parent.closed == :local_rst
send(type: :rst_stream, stream: pid, error: :refused_stream)
else
connection_error
end
end
stream = activate_stream(id: pid, parent: parent)
emit(:promise, stream)
stream << frame
else
if (stream = @streams[frame[:stream]])
stream << frame
if frame[:type] == :data
update_local_window(frame)
calculate_window_update(@local_window_limit)
end
else
case frame[:type]
when :priority
stream = activate_stream(
id:         frame[:stream],
weight:     frame[:weight] || DEFAULT_WEIGHT,
dependency: frame[:dependency] || 0,
exclusive:  frame[:exclusive] || false,
)
emit(:stream, stream)
stream << frame
when :window_update
process_window_update(frame)
else
connection_error
end
end
end
end
end
rescue StandardError => e
raise if e.is_a?(Error::Error)
connection_error(e: e)
end
def <<(*args)
receive(*args)
end
private
def send(frame)
emit(:frame_sent, frame)
if frame[:type] == :data
send_data(frame, true)
else
if frame[:type] == :rst_stream && frame[:error] == :protocol_error
goaway(frame[:error])
else
frames = encode(frame)
frames.each { |f| emit(:frame, f) }
end
end
end
def encode(frame)
frames = if frame[:type] == :headers || frame[:type] == :push_promise
encode_headers(frame) # HEADERS and PUSH_PROMISE may create more than one frame
else
[frame]               # otherwise one frame
end
frames.map { |f| @framer.generate(f) }
end
def connection_frame?(frame)
(frame[:stream]).zero? ||
frame[:type] == :settings ||
frame[:type] == :ping ||
frame[:type] == :goaway
end
def connection_management(frame)
case @state
when :waiting_connection_preface
@state = :connected
connection_settings(frame)
when :connected
case frame[:type]
when :settings
connection_settings(frame)
when :window_update
@remote_window += frame[:increment]
send_data(nil, true)
when :ping
if frame[:flags].include? :ack
emit(:ack, frame[:payload])
else
send(type: :ping, stream: 0,
flags: [:ack], payload: frame[:payload])
end
when :goaway
@state = :closed
@closed_since = Time.now
emit(:goaway, frame[:last_stream], frame[:error], frame[:payload])
when :altsvc
if frame[:origin] && !frame[:origin].empty?
emit(frame[:type], frame)
end
when :blocked
emit(frame[:type], frame)
else
connection_error
end
when :closed
connection_error if (Time.now - @closed_since) > 15
else
connection_error
end
end
def validate_settings(role, settings)
settings.each do |key, v|
case key
when :settings_header_table_size
when :settings_enable_push
case role
when :server
return ProtocolError.new("invalid #{key} value") unless v.zero?
when :client
unless v.zero? || v == 1
return ProtocolError.new("invalid #{key} value")
end
end
when :settings_max_concurrent_streams
when :settings_initial_window_size
unless v <= 0x7fffffff
return FlowControlError.new("invalid #{key} value")
end
when :settings_max_frame_size
unless v >= 16_384 && v <= 16_777_215
return ProtocolError.new("invalid #{key} value")
end
when :settings_max_header_list_size
end
end
nil
end
def connection_settings(frame)
connection_error unless frame[:type] == :settings && (frame[:stream]).zero?
settings, side = if frame[:flags].include?(:ack)
[@pending_settings.shift, :local]
else
connection_error(check) if validate_settings(@remote_role, frame[:payload])
[frame[:payload], :remote]
end
settings.each do |key, v|
case side
when :local
@local_settings[key] = v
when :remote
@remote_settings[key] = v
end
case key
when :settings_max_concurrent_streams
when :settings_initial_window_size
case side
when :local
@local_window = @local_window - @local_window_limit + v
@streams.each do |_id, stream|
stream.emit(:local_window, stream.local_window - @local_window_limit + v)
end
@local_window_limit = v
when :remote
@remote_window = @remote_window - @remote_window_limit + v
@streams.each do |_id, stream|
stream.emit(:window, stream.remote_window - @remote_window_limit + v)
end
@remote_window_limit = v
end
when :settings_header_table_size
case side
when :local
@compressor.table_size = v
when :remote
@decompressor.table_size = v
end
when :settings_enable_push
when :settings_max_frame_size
end
end
case side
when :local
emit(:settings_ack, frame, @pending_settings.size)
when :remote
unless @state == :closed || @h2c_upgrade == :start
send(type: :settings, stream: 0, payload: [], flags: [:ack])
end
end
end
def decode_headers(frame)
if frame[:payload].is_a? Buffer
frame[:payload] = @decompressor.decode(frame[:payload])
end
rescue CompressionError => e
connection_error(:compression_error, e: e)
rescue ProtocolError => e
connection_error(:protocol_error, e: e)
rescue StandardError => e
connection_error(:internal_error, e: e)
end
def encode_headers(frame)
payload = frame[:payload]
payload = @compressor.encode(payload) unless payload.is_a? Buffer
frames = []
while payload.bytesize > 0
cont = frame.dup
cont[:type] = :continuation
cont[:flags] = []
cont[:payload] = payload.slice!(0, @remote_settings[:settings_max_frame_size])
frames << cont
end
if frames.empty?
frames = [frame]
else
frames.first[:type]  = frame[:type]
frames.first[:flags] = frame[:flags] - [:end_headers]
frames.last[:flags] << :end_headers
end
frames
rescue StandardError => e
connection_error(:compression_error, e: e)
nil
end
def activate_stream(id: nil, **args)
connection_error(msg: 'Stream ID already exists') if @streams.key?(id)
stream = Stream.new({ connection: self, id: id }.merge(args))
stream.once(:active) { @active_stream_count += 1 }
stream.once(:close) do
@active_stream_count -= 1
@streams_recently_closed[id] = Time.now
to_delete = @streams_recently_closed.select { |_, v| (Time.now - v) > 15 }
to_delete.each do |stream_id|
@streams.delete stream_id
@streams_recently_closed.delete stream_id
end
end
stream.on(:promise, &method(:promise)) if self.is_a? Server
stream.on(:frame,   &method(:send))
@streams[id] = stream
end
def connection_error(error = :protocol_error, msg: nil, e: nil)
goaway(error) unless @state == :closed || @state == :new
@state, @error = :closed, error
klass = error.to_s.split('_').map(&:capitalize).join
msg ||= e && e.message
backtrace = (e && e.backtrace) || []
fail Error.const_get(klass), msg, backtrace
end
alias error connection_error
def manage_state(_)
yield
end
end
end
module HTTP2
class Client < Connection
def initialize(**settings)
@stream_id    = 1
@state        = :waiting_connection_preface
@local_role   = :client
@remote_role  = :server
super
end
def send(frame)
send_connection_preface
super(frame)
end
def receive(frame)
send_connection_preface
super(frame)
end
def upgrade
fail ProtocolError unless @stream_id == 1
send_connection_preface
new_stream(state: :half_closed_local)
end
def send_connection_preface
return unless @state == :waiting_connection_preface
@state = :connected
emit(:frame, CONNECTION_PREFACE_MAGIC)
payload = @local_settings.reject { |k, v| v == SPEC_DEFAULT_CONNECTION_SETTINGS[k] }
settings(payload)
end
def self.settings_header(**settings)
frame = Framer.new.generate(type: :settings, stream: 0, payload: settings)
Base64.urlsafe_encode64(frame[9..-1])
end
end
end
module Base64
module_function
def encode64(bin)
[bin].pack("m")
end
def decode64(str)
str.unpack1("m")
end
def strict_encode64(bin)
[bin].pack("m0")
end
def strict_decode64(str)
str.unpack1("m0")
end
def urlsafe_encode64(bin, padding: true)
str = strict_encode64(bin).tr("+/", "-_")
str = str.delete("=") unless padding
str
end
def urlsafe_decode64(str)
str = str.tr("-_", "+/")
if !str.end_with?("=") && str.length % 4 != 0
str = str.ljust((str.length + 3) & ~3, "=")
end
strict_decode64(str)
end
end
module HTTP2
class Server < Connection
def initialize(**settings)
@stream_id    = 2
@state        = :waiting_magic
@local_role   = :server
@remote_role  = :client
super
end
def upgrade(settings, headers, body)
@h2c_upgrade = :start
receive(CONNECTION_PREFACE_MAGIC)
buf = HTTP2::Buffer.new Base64.urlsafe_decode64(settings.to_s)
header = @framer.common_header(
length: buf.bytesize,
type: :settings,
stream: 0,
flags: [],
)
buf.prepend(header)
receive(buf)
stream = activate_stream(id: 1)
emit(:stream, stream)
headers_frame = {
type:       :headers,
stream:     1,
weight:     DEFAULT_WEIGHT,
dependency: 0,
exclusive:  false,
payload: headers,
}
if body.empty?
headers_frame.merge!(flags: [:end_stream])
stream << headers_frame
else
stream << headers_frame
stream << { type: :data, stream: 1, payload: body, flags: [:end_stream] }
end
@h2c_upgrade = :finished
@state = :waiting_magic
end
private
def promise(*args, &callback)
parent, headers, flags = *args
promise = new_stream(parent: parent)
promise.send(
type: :push_promise,
flags: flags,
stream: parent.id,
promise_stream: promise.id,
payload: headers.to_a,
)
callback.call(promise)
end
end
end
module HTTP2
class Stream
include FlowBuffer
include Emitter
include Error
attr_reader :id
attr_reader :state
attr_reader :parent
attr_reader :weight
attr_reader :dependency
attr_reader :local_window
attr_reader :remote_window
alias window local_window
attr_reader :closed
def initialize(connection:, id:, weight: 16, dependency: 0, exclusive: false, parent: nil, state: :idle)
@connection = connection
@id = id
@weight = weight
@dependency = dependency
process_priority(weight: weight, stream_dependency: dependency, exclusive: exclusive)
@local_window_max_size = connection.local_settings[:settings_initial_window_size]
@local_window  = connection.local_settings[:settings_initial_window_size]
@remote_window = connection.remote_settings[:settings_initial_window_size]
@parent = parent
@state  = state
@error  = false
@closed = false
@send_buffer = []
on(:window) { |v| @remote_window = v }
on(:local_window) { |v| @local_window_max_size = @local_window = v }
end
def closed?
@state == :closed
end
def receive(frame)
transition(frame, false)
case frame[:type]
when :data
update_local_window(frame)
emit(:data, frame[:payload]) unless frame[:ignore]
calculate_window_update(@local_window_max_size)
when :headers
emit(:headers, frame[:payload]) unless frame[:ignore]
when :push_promise
emit(:promise_headers, frame[:payload]) unless frame[:ignore]
when :priority
process_priority(frame)
when :window_update
process_window_update(frame)
when :altsvc
if !frame[:origin] || frame[:origin].empty?
emit(frame[:type], frame)
end
when :blocked
emit(frame[:type], frame)
end
complete_transition(frame)
end
alias << receive
def send(frame)
process_priority(frame) if frame[:type] == :priority
case frame[:type]
when :data
send_data(frame)
when :window_update
manage_state(frame) do
@local_window += frame[:increment]
emit(:frame, frame)
end
else
manage_state(frame) do
emit(:frame, frame)
end
end
end
def headers(headers, end_headers: true, end_stream: false)
flags = []
flags << :end_headers if end_headers
flags << :end_stream  if end_stream
send(type: :headers, flags: flags, payload: headers)
end
def promise(headers, end_headers: true, &block)
fail ArgumentError, 'must provide callback' unless block_given?
flags = end_headers ? [:end_headers] : []
emit(:promise, self, headers, flags, &block)
end
def reprioritize(weight: 16, dependency: 0, exclusive: false)
stream_error if @id.even?
send(type: :priority, weight: weight, stream_dependency: dependency, exclusive: exclusive)
end
def data(payload, end_stream: true)
max_size = @connection.remote_settings[:settings_max_frame_size]
if payload.bytesize > max_size
payload = chunk_data(payload, max_size) do |chunk|
send(type: :data, flags: [], payload: chunk)
end
end
flags = []
flags << :end_stream if end_stream
send(type: :data, flags: flags, payload: payload)
end
def chunk_data(payload, max_size)
total = payload.bytesize
cursor = 0
while (total - cursor) > max_size
yield payload.byteslice(cursor, max_size)
cursor += max_size
end
payload.byteslice(cursor, total - cursor)
end
def close(error = :stream_closed)
send(type: :rst_stream, error: error)
end
def cancel
send(type: :rst_stream, error: :cancel)
end
def refuse
send(type: :rst_stream, error: :refused_stream)
end
def window_update(increment)
return if @state == :closed || @state == :remote_closed
send(type: :window_update, increment: increment)
end
private
def transition(frame, sending)
case @state
when :idle
if sending
case frame[:type]
when :push_promise then event(:reserved_local)
when :headers
if end_stream?(frame)
event(:half_closed_local)
else
event(:open)
end
when :rst_stream then event(:local_rst)
when :priority then process_priority(frame)
else stream_error
end
else
case frame[:type]
when :push_promise then event(:reserved_remote)
when :headers
if end_stream?(frame)
event(:half_closed_remote)
else
event(:open)
end
when :priority then process_priority(frame)
else stream_error(:protocol_error)
end
end
when :reserved_local
@state = if sending
case frame[:type]
when :headers     then event(:half_closed_remote)
when :rst_stream  then event(:local_rst)
else stream_error
end
else
case frame[:type]
when :rst_stream then event(:remote_rst)
when :priority, :window_update then @state
else stream_error
end
end
when :reserved_remote
@state = if sending
case frame[:type]
when :rst_stream then event(:local_rst)
when :priority, :window_update then @state
else stream_error
end
else
case frame[:type]
when :headers then event(:half_closed_local)
when :rst_stream then event(:remote_rst)
else stream_error
end
end
when :open
if sending
case frame[:type]
when :data, :headers, :continuation
event(:half_closed_local) if end_stream?(frame)
when :rst_stream then event(:local_rst)
end
else
case frame[:type]
when :data, :headers, :continuation
event(:half_closed_remote) if end_stream?(frame)
when :rst_stream then event(:remote_rst)
end
end
when :half_closed_local
if sending
case frame[:type]
when :rst_stream
event(:local_rst)
when :priority
process_priority(frame)
when :window_update
else
stream_error
end
else
case frame[:type]
when :data, :headers, :continuation
event(:remote_closed) if end_stream?(frame)
when :rst_stream then event(:remote_rst)
when :priority
process_priority(frame)
when :window_update
end
end
when :half_closed_remote
if sending
case frame[:type]
when :data, :headers, :continuation
event(:local_closed) if end_stream?(frame)
when :rst_stream then event(:local_rst)
end
else
case frame[:type]
when :rst_stream then event(:remote_rst)
when :priority
process_priority(frame)
when :window_update
else
stream_error(:stream_closed)
end
end
when :closed
if sending
case frame[:type]
when :rst_stream then # ignore
when :priority   then
process_priority(frame)
else
stream_error(:stream_closed) unless (frame[:type] == :rst_stream)
end
else
if frame[:type] == :priority
process_priority(frame)
else
case @closed
when :remote_rst, :remote_closed
case frame[:type]
when :rst_stream, :window_update # nop here
else
stream_error(:stream_closed)
end
when :local_rst, :local_closed
frame[:ignore] = true if frame[:type] != :window_update
end
end
end
end
end
def event(newstate)
case newstate
when :open
@state = newstate
emit(:active)
when :reserved_local, :reserved_remote
@state = newstate
emit(:reserved)
when :half_closed_local, :half_closed_remote
@closed = newstate
emit(:active) unless @state == :open
@state = :half_closing
when :local_closed, :remote_closed, :local_rst, :remote_rst
@closed = newstate
@state  = :closing
end
@state
end
def complete_transition(frame)
case @state
when :closing
@state = :closed
emit(:close, frame[:error])
when :half_closing
@state = @closed
emit(:half_close)
end
end
def process_priority(frame)
@weight = frame[:weight]
@dependency = frame[:stream_dependency]
emit(
:priority,
weight:     frame[:weight],
dependency: frame[:stream_dependency],
exclusive:  frame[:exclusive],
)
end
def end_stream?(frame)
case frame[:type]
when :data, :headers, :continuation
frame[:flags].include?(:end_stream)
else false
end
end
def stream_error(error = :internal_error, msg: nil)
@error = error
close(error) if @state != :closed
klass = error.to_s.split('_').map(&:capitalize).join
fail Error.const_get(klass), msg
end
alias error stream_error
def manage_state(frame)
transition(frame, true)
frame[:stream] ||= @id
yield
complete_transition(frame)
end
end
end
module NetHttp2
DRAFT               = 'h2'
PROXY_SETTINGS_KEYS = [:proxy_addr, :proxy_port, :proxy_user, :proxy_pass]
class Client
include Callbacks
attr_reader :uri
def initialize(url, options={})
@uri             = URI.parse(url)
@connect_timeout = options[:connect_timeout] || 60
@ssl_context     = add_npn_to_context(options[:ssl_context] || OpenSSL::SSL::SSLContext.new)
PROXY_SETTINGS_KEYS.each do |key|
instance_variable_set("@#{key}", options[key]) if options[key]
end
@is_ssl = (@uri.scheme == 'https')
@mutex = Mutex.new
init_vars
end
def call(method, path, options={})
request = prepare_request(method, path, options)
ensure_open
new_stream.call_with request
end
def call_async(request)
ensure_open
stream = new_monitored_stream_for request
stream.async_call_with request
end
def prepare_request(method, path, options={})
NetHttp2::Request.new(method, @uri, path, options)
end
def ssl?
@is_ssl
end
def close
exit_thread(@socket_thread)
init_vars
end
def join
while !@streams.empty? do
sleep 0.05
end
end
def remote_settings
h2.remote_settings
end
def stream_count
@streams.length
end
private
def init_vars
@mutex.synchronize do
@socket.close if @socket && !@socket.closed?
@h2              = nil
@socket          = nil
@socket_thread   = nil
@first_data_sent = false
@streams         = {}
end
end
def new_stream
@mutex.synchronize { NetHttp2::Stream.new(h2_stream: h2.new_stream) }
rescue StandardError => e
close
raise e
end
def new_monitored_stream_for(request)
stream = new_stream
@streams[stream.id] = true
request.on(:close) { @streams.delete(stream.id) }
stream
end
def ensure_open
@mutex.synchronize do
return if @socket_thread
@socket = new_socket
@socket_thread = Thread.new do
begin
socket_loop
rescue EOFError
init_vars
callback_or_raise SocketError.new('Socket was remotely closed')
rescue Exception => e
init_vars
callback_or_raise e
end
end.tap { |t| t.abort_on_exception = true }
end
end
def callback_or_raise(exception)
if callback_events.keys.include?(:error)
emit(:error, exception)
else
raise exception
end
end
def socket_loop
ensure_sent_before_receiving
loop do
begin
data_received = @socket.read_nonblock(1024)
h2 << data_received
rescue IO::WaitReadable
IO.select([@socket])
retry
rescue IO::WaitWritable
IO.select(nil, [@socket])
retry
end
end
end
def new_socket
options = {
ssl: ssl?, ssl_context: @ssl_context, connect_timeout: @connect_timeout
}
PROXY_SETTINGS_KEYS.each { |k| options[k] = instance_variable_get("@#{k}") }
NetHttp2::Socket.create(@uri, options)
end
def ensure_sent_before_receiving
while !@first_data_sent
sleep 0.01
end
end
def h2
@h2 ||= HTTP2::Client.new.tap do |h2|
h2.on(:frame) do |bytes|
@mutex.synchronize do
@socket.write(bytes)
@socket.flush
@first_data_sent = true
end
end
end
end
def add_npn_to_context(ctx)
ctx.npn_protocols = [DRAFT]
ctx.npn_select_cb = lambda do |protocols|
DRAFT if protocols.include?(DRAFT)
end
ctx
end
def exit_thread(thread)
return unless thread
thread.exit
thread.join
end
end
end
module NetHttp2
class Response
attr_reader :headers, :body
def initialize(options={})
@headers = options[:headers]
@body    = options[:body]
end
def status
@headers[':status'] if @headers
end
def ok?
status == '200'
end
end
end
class PStore
RDWR_ACCESS = {mode: IO::RDWR | IO::CREAT | IO::BINARY, encoding: Encoding::ASCII_8BIT}.freeze
RD_ACCESS = {mode: IO::RDONLY | IO::BINARY, encoding: Encoding::ASCII_8BIT}.freeze
WR_ACCESS = {mode: IO::WRONLY | IO::CREAT | IO::TRUNC | IO::BINARY, encoding: Encoding::ASCII_8BIT}.freeze
class Error < StandardError
end
attr_accessor :ultra_safe
def initialize(file, thread_safe = false)
dir = File::dirname(file)
unless File::directory? dir
raise PStore::Error, format("directory %s does not exist", dir)
end
if File::exist? file and not File::readable? file
raise PStore::Error, format("file %s not readable", file)
end
@filename = file
@abort = false
@ultra_safe = false
@thread_safe = thread_safe
@lock = Thread::Mutex.new
end
def in_transaction
raise PStore::Error, "not in transaction" unless @lock.locked?
end
def in_transaction_wr
in_transaction
raise PStore::Error, "in read-only transaction" if @rdonly
end
private :in_transaction, :in_transaction_wr
def [](name)
in_transaction
@table[name]
end
def fetch(name, default=PStore::Error)
in_transaction
unless @table.key? name
if default == PStore::Error
raise PStore::Error, format("undefined root name `%s'", name)
else
return default
end
end
@table[name]
end
def []=(name, value)
in_transaction_wr
@table[name] = value
end
def delete(name)
in_transaction_wr
@table.delete name
end
def roots
in_transaction
@table.keys
end
def root?(name)
in_transaction
@table.key? name
end
def path
@filename
end
def commit
in_transaction
@abort = false
throw :pstore_abort_transaction
end
def abort
in_transaction
@abort = true
throw :pstore_abort_transaction
end
def transaction(read_only = false)  # :yields:  pstore
value = nil
if !@thread_safe
raise PStore::Error, "nested transaction" unless @lock.try_lock
else
begin
@lock.lock
rescue ThreadError
raise PStore::Error, "nested transaction"
end
end
begin
@rdonly = read_only
@abort = false
file = open_and_lock_file(@filename, read_only)
if file
begin
@table, checksum, original_data_size = load_data(file, read_only)
catch(:pstore_abort_transaction) do
value = yield(self)
end
if !@abort && !read_only
save_data(checksum, original_data_size, file)
end
ensure
file.close
end
else
@table = {}
catch(:pstore_abort_transaction) do
value = yield(self)
end
end
ensure
@lock.unlock
end
value
end
private
CHECKSUM_ALGO = %w[SHA512 SHA384 SHA256 SHA1 RMD160 MD5].each do |algo|
begin
break Digest(algo)
rescue LoadError
end
end
EMPTY_STRING = ""
EMPTY_MARSHAL_DATA = Marshal.dump({})
EMPTY_MARSHAL_CHECKSUM = CHECKSUM_ALGO.digest(EMPTY_MARSHAL_DATA)
def open_and_lock_file(filename, read_only)
if read_only
begin
file = File.new(filename, RD_ACCESS)
begin
file.flock(File::LOCK_SH)
return file
rescue
file.close
raise
end
rescue Errno::ENOENT
return nil
end
else
file = File.new(filename, RDWR_ACCESS)
file.flock(File::LOCK_EX)
return file
end
end
def load_data(file, read_only)
if read_only
begin
table = load(file)
raise Error, "PStore file seems to be corrupted." unless table.is_a?(Hash)
rescue EOFError
table = {}
end
table
else
data = file.read
if data.empty?
table = {}
checksum = empty_marshal_checksum
size = empty_marshal_data.bytesize
else
table = load(data)
checksum = CHECKSUM_ALGO.digest(data)
size = data.bytesize
raise Error, "PStore file seems to be corrupted." unless table.is_a?(Hash)
end
data.replace(EMPTY_STRING)
[table, checksum, size]
end
end
def on_windows?
is_windows = RUBY_PLATFORM =~ /mswin|mingw|bccwin|wince/
self.class.__send__(:define_method, :on_windows?) do
is_windows
end
is_windows
end
def save_data(original_checksum, original_file_size, file)
new_data = dump(@table)
if new_data.bytesize != original_file_size || CHECKSUM_ALGO.digest(new_data) != original_checksum
if @ultra_safe && !on_windows?
save_data_with_atomic_file_rename_strategy(new_data, file)
else
save_data_with_fast_strategy(new_data, file)
end
end
new_data.replace(EMPTY_STRING)
end
def save_data_with_atomic_file_rename_strategy(data, file)
temp_filename = "#{@filename}.tmp.#{Process.pid}.#{rand 1000000}"
temp_file = File.new(temp_filename, WR_ACCESS)
begin
temp_file.flock(File::LOCK_EX)
temp_file.write(data)
temp_file.flush
File.rename(temp_filename, @filename)
rescue
File.unlink(temp_file) rescue nil
raise
ensure
temp_file.close
end
end
def save_data_with_fast_strategy(data, file)
file.rewind
file.write(data)
file.truncate(data.bytesize)
end
def dump(table) 
Marshal::dump(table)
end
def load(content) 
Marshal::load(content)
end
def empty_marshal_data
EMPTY_MARSHAL_DATA
end
def empty_marshal_checksum
EMPTY_MARSHAL_CHECKSUM
end
end
require("./escape")
class CGI
module Util; end
include Util
extend Util
end
module CGI::Util
@@accept_charset="UTF-8" unless defined?(@@accept_charset)
def escape(string)
encoding = string.encoding
string.b.gsub(/([^ a-zA-Z0-9_.\-~]+)/) do |m|
'%' + m.unpack('H2' * m.bytesize).join('%').upcase
end.tr(' ', '+').force_encoding(encoding)
end
def unescape(string,encoding=@@accept_charset)
str=string.tr('+', ' ').b.gsub(/((?:%[0-9a-fA-F]{2})+)/) do |m|
[m.delete('%')].pack('H*')
end.force_encoding(encoding)
str.valid_encoding? ? str : str.force_encoding(string.encoding)
end
TABLE_FOR_ESCAPE_HTML__ = {
"'" => '&#39;',
'&' => '&amp;',
'"' => '&quot;',
'<' => '&lt;',
'>' => '&gt;',
}
def escapeHTML(string)
enc = string.encoding
unless enc.ascii_compatible?
if enc.dummy?
origenc = enc
enc = Encoding::Converter.asciicompat_encoding(enc)
string = enc ? string.encode(enc) : string.b
end
table = Hash[TABLE_FOR_ESCAPE_HTML__.map {|pair|pair.map {|s|s.encode(enc)}}]
string = string.gsub(/#{"['&\"<>]".encode(enc)}/, table)
string.encode!(origenc) if origenc
return string
end
string.gsub(/['&\"<>]/, TABLE_FOR_ESCAPE_HTML__)
end
begin

rescue LoadError
end
def unescapeHTML(string)
enc = string.encoding
unless enc.ascii_compatible?
if enc.dummy?
origenc = enc
enc = Encoding::Converter.asciicompat_encoding(enc)
string = enc ? string.encode(enc) : string.b
end
string = string.gsub(Regexp.new('&(apos|amp|quot|gt|lt|#[0-9]+|#x[0-9A-Fa-f]+);'.encode(enc))) do
case $1.encode(Encoding::US_ASCII)
when 'apos'                then "'".encode(enc)
when 'amp'                 then '&'.encode(enc)
when 'quot'                then '"'.encode(enc)
when 'gt'                  then '>'.encode(enc)
when 'lt'                  then '<'.encode(enc)
when /\A#0*(\d+)\z/        then $1.to_i.chr(enc)
when /\A#x([0-9a-f]+)\z/i  then $1.hex.chr(enc)
end
end
string.encode!(origenc) if origenc
return string
end
return string unless string.include? '&'
charlimit = case enc
when Encoding::UTF_8; 0x10ffff
when Encoding::ISO_8859_1; 256
else 128
end
string.gsub(/&(apos|amp|quot|gt|lt|\#[0-9]+|\#[xX][0-9A-Fa-f]+);/) do
match = $1.dup
case match
when 'apos'                then "'"
when 'amp'                 then '&'
when 'quot'                then '"'
when 'gt'                  then '>'
when 'lt'                  then '<'
when /\A#0*(\d+)\z/
n = $1.to_i
if n < charlimit
n.chr(enc)
else
"&##{$1};"
end
when /\A#x([0-9a-f]+)\z/i
n = $1.hex
if n < charlimit
n.chr(enc)
else
"&#x#{$1};"
end
else
"&#{match};"
end
end
end
alias escape_html escapeHTML
alias unescape_html unescapeHTML
def escapeElement(string, *elements)
elements = elements[0] if elements[0].kind_of?(Array)
unless elements.empty?
string.gsub(/<\/?(?:#{elements.join("|")})(?!\w)(?:.|\n)*?>/i) do
CGI::escapeHTML($&)
end
else
string
end
end
def unescapeElement(string, *elements)
elements = elements[0] if elements[0].kind_of?(Array)
unless elements.empty?
string.gsub(/&lt;\/?(?:#{elements.join("|")})(?!\w)(?:.|\n)*?&gt;/i) do
unescapeHTML($&)
end
else
string
end
end
alias escape_element escapeElement
alias unescape_element unescapeElement
RFC822_DAYS = %w[ Sun Mon Tue Wed Thu Fri Sat ]
RFC822_MONTHS = %w[ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ]
def rfc1123_date(time)
t = time.clone.gmtime
return format("%s, %.2d %s %.4d %.2d:%.2d:%.2d GMT",
RFC822_DAYS[t.wday], t.day, RFC822_MONTHS[t.month-1], t.year,
t.hour, t.min, t.sec)
end
def pretty(string, shift = "  ")
lines = string.gsub(/(?!\A)<.*?>/m, "\n\\0").gsub(/<.*?>(?!\n)/m, "\\0\n")
end_pos = 0
while end_pos = lines.index(/^<\/(\w+)/, end_pos)
element = $1.dup
start_pos = lines.rindex(/^\s*<#{element}/i, end_pos)
lines[start_pos ... end_pos] = "__" + lines[start_pos ... end_pos].gsub(/\n(?!\z)/, "\n" + shift) + "__"
end
lines.gsub(/^((?:#{Regexp::quote(shift)})*)__(?=<\/?\w)/, '\1')
end
alias h escapeHTML
end
##
class Delegator < BasicObject
kernel = ::Kernel.dup
kernel.class_eval do
alias __raise__ raise
[:to_s, :inspect, :=~, :!~, :===, :<=>, :hash].each do |m|
undef_method m
end
private_instance_methods.each do |m|
if /\Ablock_given\?\z|iterator\?\z|\A__.*__\z/ =~ m
next
end
undef_method m
end
end
include kernel
def self.const_missing(n)
::Object.const_get(n)
end
##
def initialize(obj)
__setobj__(obj)
end
def method_missing(m, *args, &block)
r = true
target = self.__getobj__ {r = false}
if r && target.respond_to?(m)
target.__send__(m, *args, &block)
elsif ::Kernel.respond_to?(m, true)
::Kernel.instance_method(m).bind(self).(*args, &block)
else
super(m, *args, &block)
end
end
def respond_to_missing?(m, include_private)
r = true
target = self.__getobj__ {r = false}
r &&= target.respond_to?(m, include_private)
if r && include_private && !target.respond_to?(m, false)
warn "delegator does not forward private method \##{m}", uplevel: 3
return false
end
r
end
def methods(all=true)
__getobj__.methods(all) | super
end
def public_methods(all=true)
__getobj__.public_methods(all) | super
end
def protected_methods(all=true)
__getobj__.protected_methods(all) | super
end
def ==(obj)
return true if obj.equal?(self)
self.__getobj__ == obj
end
def !=(obj)
return false if obj.equal?(self)
__getobj__ != obj
end
def eql?(obj)
return true if obj.equal?(self)
obj.eql?(__getobj__)
end
def !
!__getobj__
end
def __getobj__
__raise__ ::NotImplementedError, "need to define `__getobj__'"
end
def __setobj__(obj)
__raise__ ::NotImplementedError, "need to define `__setobj__'"
end
def marshal_dump
ivars = instance_variables.reject {|var| /\A@delegate_/ =~ var}
[
:__v2__,
ivars, ivars.map {|var| instance_variable_get(var)},
__getobj__
]
end
def marshal_load(data)
version, vars, values, obj = data
if version == :__v2__
vars.each_with_index {|var, i| instance_variable_set(var, values[i])}
__setobj__(obj)
else
__setobj__(data)
end
end
def initialize_clone(obj)
self.__setobj__(obj.__getobj__.clone)
end
def initialize_dup(obj)
self.__setobj__(obj.__getobj__.dup)
end
private :initialize_clone, :initialize_dup
##
##
##
##
##
[:trust, :untrust, :taint, :untaint, :freeze].each do |method|
define_method method do
__getobj__.send(method)
super()
end
end
@delegator_api = self.public_instance_methods
def self.public_api
@delegator_api
end
end
##
class SimpleDelegator < Delegator
def __getobj__
unless defined?(@delegate_sd_obj)
return yield if block_given?
__raise__ ::ArgumentError, "not delegated"
end
@delegate_sd_obj
end
def __setobj__(obj)
__raise__ ::ArgumentError, "cannot delegate to self" if self.equal?(obj)
@delegate_sd_obj = obj
end
end
def Delegator.delegating_block(mid)
lambda do |*args, &block|
target = self.__getobj__
target.__send__(mid, *args, &block)
end
end
def DelegateClass(superclass)
klass = Class.new(Delegator)
methods = superclass.instance_methods
methods -= ::Delegator.public_api
methods -= [:to_s, :inspect, :=~, :!~, :===]
klass.module_eval do
def __getobj__
unless defined?(@delegate_dc_obj)
return yield if block_given?
__raise__ ::ArgumentError, "not delegated"
end
@delegate_dc_obj
end
def __setobj__(obj) 
__raise__ ::ArgumentError, "cannot delegate to self" if self.equal?(obj)
@delegate_dc_obj = obj
end
methods.each do |method|
define_method(method, Delegator.delegating_block(method))
end
end
klass.define_singleton_method :public_instance_methods do |all=true|
super(all) - superclass.protected_instance_methods
end
klass.define_singleton_method :protected_instance_methods do |all=true|
super(all) | superclass.protected_instance_methods
end
return klass
end
module RbConfig
RUBY_VERSION.start_with?("2.6.") or
raise "ruby lib version (2.6.0) doesn't match executable version (#{RUBY_VERSION})"
TOPDIR = File.dirname(__FILE__).chomp!("/lib/ruby/2.6.0/i386-mingw32")
DESTDIR = TOPDIR && TOPDIR[/\A[a-z]:/i] || '' unless defined? DESTDIR
CONFIG = {}
CONFIG["DESTDIR"] = DESTDIR
CONFIG["MAJOR"] = "2"
CONFIG["MINOR"] = "6"
CONFIG["TEENY"] = "0"
CONFIG["PATCHLEVEL"] = "0"
CONFIG["INSTALL"] = '/usr/bin/install -c'
CONFIG["EXEEXT"] = ".exe"
CONFIG["prefix"] = (TOPDIR || DESTDIR + "/mingw32")
CONFIG["ruby_install_name"] = "$(RUBY_BASE_NAME)"
CONFIG["RUBY_INSTALL_NAME"] = "$(RUBY_BASE_NAME)"
CONFIG["RUBY_SO_NAME"] = "msvcrt-$(RUBY_BASE_NAME)$(MAJOR)$(MINOR)0"
CONFIG["exec"] = "exec"
CONFIG["ruby_pc"] = "ruby-2.6.pc"
CONFIG["CC_WRAPPER"] = ""
CONFIG["PACKAGE"] = "ruby"
CONFIG["BUILTIN_TRANSSRCS"] = " enc/trans/newline.c"
CONFIG["MANTYPE"] = "doc"
CONFIG["vendorarchhdrdir"] = "$(vendorhdrdir)/$(sitearch)"
CONFIG["sitearchhdrdir"] = "$(sitehdrdir)/$(sitearch)"
CONFIG["rubyarchhdrdir"] = "$(rubyhdrdir)/$(arch)"
CONFIG["vendorhdrdir"] = "$(rubyhdrdir)/vendor_ruby"
CONFIG["sitehdrdir"] = "$(rubyhdrdir)/site_ruby"
CONFIG["rubyhdrdir"] = "$(includedir)/$(RUBY_VERSION_NAME)"
CONFIG["RUBY_SEARCH_PATH"] = ""
CONFIG["UNIVERSAL_INTS"] = ""
CONFIG["UNIVERSAL_ARCHNAMES"] = ""
CONFIG["configure_args"] = " '--prefix=/mingw32' '--build=i686-w64-mingw32' '--host=i686-w64-mingw32' '--target=i686-w64-mingw32' '--without-ext=pty,syslog' 'LDFLAGS=-pipe -s' 'build_alias=i686-w64-mingw32' 'host_alias=i686-w64-mingw32' 'target_alias=i686-w64-mingw32' 'CFLAGS=-march=i686 -mtune=generic -O2 -pipe' 'CPPFLAGS=-D_FORTIFY_SOURCE=2 -D__USE_MINGW_ANSI_STDIO=1 -DFD_SETSIZE=2048' 'CXXFLAGS=-march=i686 -mtune=generic -O2 -pipe'"
CONFIG["CONFIGURE"] = "configure"
CONFIG["vendorarchdir"] = "$(vendorlibdir)/$(sitearch)"
CONFIG["vendorlibdir"] = "$(vendordir)/$(ruby_version)"
CONFIG["vendordir"] = "$(rubylibprefix)/vendor_ruby"
CONFIG["sitearchdir"] = "$(sitelibdir)/$(sitearch)"
CONFIG["sitelibdir"] = "$(sitedir)/$(ruby_version)"
CONFIG["sitedir"] = "$(rubylibprefix)/site_ruby"
CONFIG["rubyarchdir"] = "$(rubylibdir)/$(arch)"
CONFIG["rubylibdir"] = "$(rubylibprefix)/$(ruby_version)"
CONFIG["ruby_version"] = "2.6.0"
CONFIG["sitearch"] = "i386-msvcrt"
CONFIG["arch"] = "i386-mingw32"
CONFIG["sitearchincludedir"] = "$(includedir)/$(sitearch)"
CONFIG["archincludedir"] = "$(includedir)/$(arch)"
CONFIG["sitearchlibdir"] = "$(libdir)/$(sitearch)"
CONFIG["archlibdir"] = "$(libdir)/$(arch)"
CONFIG["libdirname"] = "libdir"
CONFIG["RUBY_EXEC_PREFIX"] = ""
CONFIG["RUBY_LIB_VERSION"] = ""
CONFIG["RUBY_LIB_VERSION_STYLE"] = "3\t/* full */"
CONFIG["RI_BASE_NAME"] = "ri"
CONFIG["ridir"] = "$(datarootdir)/$(RI_BASE_NAME)"
CONFIG["rubysitearchprefix"] = "$(rubylibprefix)/$(sitearch)"
CONFIG["rubyarchprefix"] = "$(rubylibprefix)/$(arch)"
CONFIG["MAKEFILES"] = "Makefile GNUmakefile"
CONFIG["PLATFORM_DIR"] = "win32"
CONFIG["THREAD_MODEL"] = "win32"
CONFIG["SYMBOL_PREFIX"] = "_"
CONFIG["EXPORT_PREFIX"] = " "
CONFIG["COMMON_HEADERS"] = "winsock2.h windows.h"
CONFIG["COMMON_MACROS"] = ""
CONFIG["COMMON_LIBS"] = "m"
CONFIG["MAINLIBS"] = "-lgmp -lshell32 -lws2_32 -liphlpapi -limagehlp -lshlwapi "
CONFIG["ENABLE_SHARED"] = "yes"
CONFIG["DLDSHARED"] = "$(CC) -shared"
CONFIG["DLDLIBS"] = ""
CONFIG["SOLIBS"] = "$(MAINLIBS)"
CONFIG["LIBRUBYARG_SHARED"] = "-l$(RUBY_SO_NAME)"
CONFIG["LIBRUBYARG_STATIC"] = "-l$(RUBY_SO_NAME)-static $(MAINLIBS)"
CONFIG["LIBRUBYARG"] = "$(LIBRUBYARG_SHARED)"
CONFIG["LIBRUBY"] = "lib$(RUBY_SO_NAME).dll.a"
CONFIG["LIBRUBY_ALIASES"] = ""
CONFIG["LIBRUBY_SONAME"] = "lib$(RUBY_SO_NAME).$(SOEXT).$(RUBY_API_VERSION)"
CONFIG["LIBRUBY_SO"] = "$(RUBY_SO_NAME).dll"
CONFIG["LIBRUBY_A"] = "lib$(RUBY_SO_NAME)-static.a"
CONFIG["RUBYW_INSTALL_NAME"] = "$(RUBYW_BASE_NAME)"
CONFIG["rubyw_install_name"] = "$(RUBYW_INSTALL_NAME)"
CONFIG["EXTDLDFLAGS"] = ""
CONFIG["EXTLDFLAGS"] = "-static-libgcc"
CONFIG["strict_warnflags"] = ""
CONFIG["warnflags"] = "-Wall -Wextra -Wdeclaration-after-statement -Wdeprecated-declarations -Wduplicated-cond -Wimplicit-function-declaration -Wimplicit-int -Wmisleading-indentation -Wpointer-arith -Wrestrict -Wwrite-strings -Wimplicit-fallthrough=0 -Wmissing-noreturn -Wno-cast-function-type -Wno-constant-logical-operand -Wno-long-long -Wno-missing-field-initializers -Wno-overlength-strings -Wno-packed-bitfield-compat -Wno-parentheses-equality -Wno-self-assign -Wno-tautological-compare -Wno-unused-parameter -Wno-unused-value -Wsuggest-attribute=format -Wsuggest-attribute=noreturn -Wunused-variable"
CONFIG["debugflags"] = "-ggdb3"
CONFIG["optflags"] = "-O3 -fno-omit-frame-pointer"
CONFIG["NULLCMD"] = ":"
CONFIG["ENABLE_DEBUG_ENV"] = ""
CONFIG["DLNOBJ"] = "dln.o"
CONFIG["INSTALL_STATIC_LIBRARY"] = "no"
CONFIG["MJIT_SUPPORT"] = "yes"
CONFIG["EXECUTABLE_EXTS"] = ".exe .com .cmd .bat"
CONFIG["ARCHFILE"] = ""
CONFIG["LIBRUBY_RELATIVE"] = "yes"
CONFIG["EXTOUT"] = ".ext"
CONFIG["PREP"] = "miniruby$(EXEEXT)"
CONFIG["CROSS_COMPILING"] = "no"
CONFIG["TEST_RUNNABLE"] = "yes"
CONFIG["rubylibprefix"] = "$(libdir)/$(RUBY_BASE_NAME)"
CONFIG["setup"] = "Setup"
CONFIG["ENCSTATIC"] = ""
CONFIG["EXTSTATIC"] = ""
CONFIG["STRIP"] = "strip"
CONFIG["SOEXT"] = "dll"
CONFIG["TRY_LINK"] = ""
CONFIG["PRELOADENV"] = ""
CONFIG["LIBPATHENV"] = "PATH"
CONFIG["RPATHFLAG"] = ""
CONFIG["LIBPATHFLAG"] = " -L%s"
CONFIG["LINK_SO"] = ""
CONFIG["ASMEXT"] = "S"
CONFIG["LIBEXT"] = "a"
CONFIG["DLEXT2"] = ""
CONFIG["DLEXT"] = "so"
CONFIG["LDSHAREDXX"] = "$(CXX) -shared"
CONFIG["LDSHARED"] = "$(CC) -shared"
CONFIG["CCDLFLAGS"] = ""
CONFIG["STATIC"] = ""
CONFIG["ARCH_FLAG"] = ""
CONFIG["DLDFLAGS"] = "-pipe -s -Wl,--enable-auto-image-base,--enable-auto-import $(DEFFILE)"
CONFIG["ALLOCA"] = ""
CONFIG["MATHN"] = "yes"
CONFIG["dsymutil"] = ""
CONFIG["codesign"] = ""
CONFIG["POSTLINK"] = ":"
CONFIG["WERRORFLAG"] = "-Werror"
CONFIG["CHDIR"] = "cd"
CONFIG["RMALL"] = "rm -fr"
CONFIG["RMDIRS"] = "rmdir --ignore-fail-on-non-empty -p"
CONFIG["RMDIR"] = "rmdir --ignore-fail-on-non-empty"
CONFIG["CP"] = "cp"
CONFIG["RM"] = "rm -f"
CONFIG["PKG_CONFIG"] = "pkg-config"
CONFIG["DOXYGEN"] = ""
CONFIG["DOT"] = ""
CONFIG["MAKEDIRS"] = "/usr/bin/mkdir -p"
CONFIG["MKDIR_P"] = "/usr/bin/mkdir -p"
CONFIG["INSTALL_DATA"] = "$(INSTALL) -m 644"
CONFIG["INSTALL_SCRIPT"] = "$(INSTALL)"
CONFIG["INSTALL_PROGRAM"] = "$(INSTALL)"
CONFIG["SET_MAKE"] = ""
CONFIG["LN_S"] = "cp -pR"
CONFIG["NM"] = "nm"
CONFIG["DLLWRAP"] = "dllwrap"
CONFIG["WINDRES"] = "windres"
CONFIG["OBJCOPY"] = ":"
CONFIG["OBJDUMP"] = "objdump"
CONFIG["ASFLAGS"] = ""
CONFIG["AS"] = "as"
CONFIG["ARFLAGS"] = "rcD "
CONFIG["AR"] = "ar"
CONFIG["RANLIB"] = "ranlib"
CONFIG["try_header"] = ""
CONFIG["CC_VERSION_MESSAGE"] = "i686-w64-mingw32-gcc.exe (Rev1, Built by MSYS2 project) 7.4.0\nCopyright (C) 2017 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
CONFIG["CC_VERSION"] = "$(CC) --version"
CONFIG["CSRCFLAG"] = ""
CONFIG["COUTFLAG"] = "-o "
CONFIG["OUTFLAG"] = "-o "
CONFIG["CPPOUTFILE"] = "-o conftest.i"
CONFIG["GNU_LD"] = "yes"
CONFIG["LD"] = "ld"
CONFIG["GCC"] = "yes"
CONFIG["EGREP"] = "/usr/bin/grep -E"
CONFIG["GREP"] = "/usr/bin/grep"
CONFIG["CPP"] = "$(CC) -E"
CONFIG["CXXFLAGS"] = "-march=i686 -mtune=generic -O2 -pipe"
CONFIG["CXX"] = "i686-w64-mingw32-g++"
CONFIG["OBJEXT"] = "o"
CONFIG["CPPFLAGS"] = "-D_FORTIFY_SOURCE=2 -D__USE_MINGW_ANSI_STDIO=1 -DFD_SETSIZE=2048 -D_WIN32_WINNT=0x0600 -D__MINGW_USE_VC2005_COMPAT $(DEFS) $(cppflags)"
CONFIG["LDFLAGS"] = "-L. -pipe -s"
CONFIG["CFLAGS"] = "-march=i686 -mtune=generic -O2 -pipe"
CONFIG["CC"] = "i686-w64-mingw32-gcc"
CONFIG["target_os"] = "mingw32"
CONFIG["target_vendor"] = "w64"
CONFIG["target_cpu"] = "i386"
CONFIG["target"] = "i386-w64-mingw32"
CONFIG["host_os"] = "mingw32"
CONFIG["host_vendor"] = "w64"
CONFIG["host_cpu"] = "i686"
CONFIG["host"] = "i686-w64-mingw32"
CONFIG["RUBY_VERSION_NAME"] = "$(RUBY_BASE_NAME)-$(ruby_version)"
CONFIG["RUBYW_BASE_NAME"] = "rubyw"
CONFIG["RUBY_BASE_NAME"] = "ruby"
CONFIG["build_os"] = "mingw32"
CONFIG["build_vendor"] = "w64"
CONFIG["build_cpu"] = "i686"
CONFIG["build"] = "i686-w64-mingw32"
CONFIG["RUBY_API_VERSION"] = "$(MAJOR).$(MINOR)"
CONFIG["RUBY_PROGRAM_VERSION"] = "2.6.0"
CONFIG["HAVE_GIT"] = "yes"
CONFIG["GIT"] = "git"
CONFIG["cxxflags"] = "$(optflags) $(debugflags) $(warnflags)"
CONFIG["cppflags"] = ""
CONFIG["cflags"] = "$(optflags) $(debugflags) $(warnflags)"
CONFIG["target_alias"] = "i386-w64-mingw32"
CONFIG["host_alias"] = "i686-w64-mingw32"
CONFIG["build_alias"] = "i686-w64-mingw32"
CONFIG["LIBS"] = "-lshell32 -lws2_32 -liphlpapi -limagehlp -lshlwapi "
CONFIG["ECHO_T"] = ""
CONFIG["ECHO_N"] = "-n"
CONFIG["ECHO_C"] = ""
CONFIG["DEFS"] = "-D_FILE_OFFSET_BITS=64"
CONFIG["mandir"] = "$(datarootdir)/man"
CONFIG["localedir"] = "$(datarootdir)/locale"
CONFIG["libdir"] = "$(exec_prefix)/lib"
CONFIG["psdir"] = "$(docdir)"
CONFIG["pdfdir"] = "$(docdir)"
CONFIG["dvidir"] = "$(docdir)"
CONFIG["htmldir"] = "$(docdir)"
CONFIG["infodir"] = "$(datarootdir)/info"
CONFIG["docdir"] = "$(datarootdir)/doc/$(PACKAGE)"
CONFIG["oldincludedir"] = "/usr/include"
CONFIG["includedir"] = "$(prefix)/include"
CONFIG["localstatedir"] = "$(prefix)/var"
CONFIG["sharedstatedir"] = "$(prefix)/com"
CONFIG["sysconfdir"] = ""
CONFIG["datadir"] = "$(datarootdir)"
CONFIG["datarootdir"] = "$(prefix)/share"
CONFIG["libexecdir"] = "$(exec_prefix)/libexec"
CONFIG["sbindir"] = "$(exec_prefix)/sbin"
CONFIG["bindir"] = "$(exec_prefix)/bin"
CONFIG["exec_prefix"] = "$(prefix)"
CONFIG["PACKAGE_URL"] = ""
CONFIG["PACKAGE_BUGREPORT"] = ""
CONFIG["PACKAGE_STRING"] = ""
CONFIG["PACKAGE_VERSION"] = ""
CONFIG["PACKAGE_TARNAME"] = ""
CONFIG["PACKAGE_NAME"] = ""
CONFIG["PATH_SEPARATOR"] = ":"
CONFIG["SHELL"] = "/bin/sh"
CONFIG["UNICODE_VERSION"] = "11.0.0"
CONFIG["UNICODE_EMOJI_VERSION"] = "11.0"
CONFIG["archdir"] = "$(rubyarchdir)"
CONFIG["topdir"] = File.dirname(__FILE__)
MAKEFILE_CONFIG = {}
CONFIG.each{|k,v| MAKEFILE_CONFIG[k] = v.dup}
def RbConfig::expand(val, config = CONFIG)
newval = val.gsub(/\$\$|\$\(([^()]+)\)|\$\{([^{}]+)\}/) {
var = $&
if !(v = $1 || $2)
'$'
elsif key = config[v = v[/\A[^:]+(?=(?::(.*?)=(.*))?\z)/]]
pat, sub = $1, $2
config[v] = false
config[v] = RbConfig::expand(key, config)
key = key.gsub(/#{Regexp.quote(pat)}(?=\s|\z)/n) {sub} if pat
key
else
var
end
}
val.replace(newval) unless newval == val
val
end
CONFIG.each_value do |val|
RbConfig::expand(val)
end

def RbConfig.fire_update!(key, val, mkconf = MAKEFILE_CONFIG, conf = CONFIG)
return if (old = mkconf[key]) == val
mkconf[key] = val
keys = [key]
deps = []
begin
re = Regexp.new("\\$\\((?:%1$s)\\)|\\$\\{(?:%1$s)\\}" % keys.join('|'))
deps |= keys
keys.clear
mkconf.each {|k,v| keys << k if re =~ v}
end until keys.empty?
deps.each {|k| conf[k] = mkconf[k].dup}
deps.each {|k| expand(conf[k])}
deps
end
def RbConfig.ruby
File.join(
RbConfig::CONFIG["bindir"],
RbConfig::CONFIG["ruby_install_name"] + RbConfig::CONFIG["EXEEXT"]
)
end
end
CROSS_COMPILING = nil unless defined? CROSS_COMPILING
module FileUtils
VERSION = "1.1.0"
end
require("./etc")
begin

rescue LoadError
end
module FileUtils
def self.private_module_function(name)   #:nodoc:
module_function name
private_class_method name
end
def pwd
Dir.pwd
end
module_function :pwd
alias getwd pwd
module_function :getwd
def cd(dir, verbose: nil, &block) # :yield: dir
fu_output_message "cd #{dir}" if verbose
result = Dir.chdir(dir, &block)
fu_output_message 'cd -' if verbose and block
result
end
module_function :cd
alias chdir cd
module_function :chdir
def uptodate?(new, old_list)
return false unless File.exist?(new)
new_time = File.mtime(new)
old_list.each do |old|
if File.exist?(old)
return false unless new_time > File.mtime(old)
end
end
true
end
module_function :uptodate?
def remove_trailing_slash(dir)   #:nodoc:
dir == '/' ? dir : dir.chomp(?/)
end
private_module_function :remove_trailing_slash
def mkdir(list, mode: nil, noop: nil, verbose: nil)
list = fu_list(list)
fu_output_message "mkdir #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
return if noop
list.each do |dir|
fu_mkdir dir, mode
end
end
module_function :mkdir
def mkdir_p(list, mode: nil, noop: nil, verbose: nil)
list = fu_list(list)
fu_output_message "mkdir -p #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
return *list if noop
list.map {|path| remove_trailing_slash(path)}.each do |path|
begin
fu_mkdir path, mode
next
rescue SystemCallError
next if File.directory?(path)
end
stack = []
until path == stack.last   # dirname("/")=="/", dirname("C:/")=="C:/"
stack.push path
path = File.dirname(path)
end
stack.pop                 # root directory should exist
stack.reverse_each do |dir|
begin
fu_mkdir dir, mode
rescue SystemCallError
raise unless File.directory?(dir)
end
end
end
return *list
end
module_function :mkdir_p
alias mkpath    mkdir_p
alias makedirs  mkdir_p
module_function :mkpath
module_function :makedirs
def fu_mkdir(path, mode)   #:nodoc:
path = remove_trailing_slash(path)
if mode
Dir.mkdir path, mode
File.chmod mode, path
else
Dir.mkdir path
end
end
private_module_function :fu_mkdir
def rmdir(list, parents: nil, noop: nil, verbose: nil)
list = fu_list(list)
fu_output_message "rmdir #{parents ? '-p ' : ''}#{list.join ' '}" if verbose
return if noop
list.each do |dir|
Dir.rmdir(dir = remove_trailing_slash(dir))
if parents
begin
until (parent = File.dirname(dir)) == '.' or parent == dir
dir = parent
Dir.rmdir(dir)
end
rescue Errno::ENOTEMPTY, Errno::EEXIST, Errno::ENOENT
end
end
end
end
module_function :rmdir
def ln(src, dest, force: nil, noop: nil, verbose: nil)
fu_output_message "ln#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
return if noop
fu_each_src_dest0(src, dest) do |s,d|
remove_file d, true if force
File.link s, d
end
end
module_function :ln
alias link ln
module_function :link
def cp_lr(src, dest, noop: nil, verbose: nil,
dereference_root: true, remove_destination: false)
fu_output_message "cp -lr#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
return if noop
fu_each_src_dest(src, dest) do |s, d|
link_entry s, d, dereference_root, remove_destination
end
end
module_function :cp_lr
def ln_s(src, dest, force: nil, noop: nil, verbose: nil)
fu_output_message "ln -s#{force ? 'f' : ''} #{[src,dest].flatten.join ' '}" if verbose
return if noop
fu_each_src_dest0(src, dest) do |s,d|
remove_file d, true if force
File.symlink s, d
end
end
module_function :ln_s
alias symlink ln_s
module_function :symlink
def ln_sf(src, dest, noop: nil, verbose: nil)
ln_s src, dest, force: true, noop: noop, verbose: verbose
end
module_function :ln_sf
def link_entry(src, dest, dereference_root = false, remove_destination = false)
Entry_.new(src, nil, dereference_root).traverse do |ent|
destent = Entry_.new(dest, ent.rel, false)
File.unlink destent.path if remove_destination && File.file?(destent.path)
ent.link destent.path
end
end
module_function :link_entry
def cp(src, dest, preserve: nil, noop: nil, verbose: nil)
fu_output_message "cp#{preserve ? ' -p' : ''} #{[src,dest].flatten.join ' '}" if verbose
return if noop
fu_each_src_dest(src, dest) do |s, d|
copy_file s, d, preserve
end
end
module_function :cp
alias copy cp
module_function :copy
def cp_r(src, dest, preserve: nil, noop: nil, verbose: nil,
dereference_root: true, remove_destination: nil)
fu_output_message "cp -r#{preserve ? 'p' : ''}#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
return if noop
fu_each_src_dest(src, dest) do |s, d|
copy_entry s, d, preserve, dereference_root, remove_destination
end
end
module_function :cp_r
def copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
Entry_.new(src, nil, dereference_root).wrap_traverse(proc do |ent|
destent = Entry_.new(dest, ent.rel, false)
File.unlink destent.path if remove_destination && (File.file?(destent.path) || File.symlink?(destent.path))
ent.copy destent.path
end, proc do |ent|
destent = Entry_.new(dest, ent.rel, false)
ent.copy_metadata destent.path if preserve
end)
end
module_function :copy_entry
def copy_file(src, dest, preserve = false, dereference = true)
ent = Entry_.new(src, nil, dereference)
ent.copy_file dest
ent.copy_metadata dest if preserve
end
module_function :copy_file
def copy_stream(src, dest)
IO.copy_stream(src, dest)
end
module_function :copy_stream
def mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
fu_output_message "mv#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
return if noop
fu_each_src_dest(src, dest) do |s, d|
destent = Entry_.new(d, nil, true)
begin
if destent.exist?
if destent.directory?
raise Errno::EEXIST, d
end
end
begin
File.rename s, d
rescue Errno::EXDEV
copy_entry s, d, true
if secure
remove_entry_secure s, force
else
remove_entry s, force
end
end
rescue SystemCallError
raise unless force
end
end
end
module_function :mv
alias move mv
module_function :move
def rm(list, force: nil, noop: nil, verbose: nil)
list = fu_list(list)
fu_output_message "rm#{force ? ' -f' : ''} #{list.join ' '}" if verbose
return if noop
list.each do |path|
remove_file path, force
end
end
module_function :rm
alias remove rm
module_function :remove
def rm_f(list, noop: nil, verbose: nil)
rm list, force: true, noop: noop, verbose: verbose
end
module_function :rm_f
alias safe_unlink rm_f
module_function :safe_unlink
def rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
list = fu_list(list)
fu_output_message "rm -r#{force ? 'f' : ''} #{list.join ' '}" if verbose
return if noop
list.each do |path|
if secure
remove_entry_secure path, force
else
remove_entry path, force
end
end
end
module_function :rm_r
def rm_rf(list, noop: nil, verbose: nil, secure: nil)
rm_r list, force: true, noop: noop, verbose: verbose, secure: secure
end
module_function :rm_rf
alias rmtree rm_rf
module_function :rmtree
def remove_entry_secure(path, force = false)
unless fu_have_symlink?
remove_entry path, force
return
end
fullpath = File.expand_path(path)
st = File.lstat(fullpath)
unless st.directory?
File.unlink fullpath
return
end
parent_st = File.stat(File.dirname(fullpath))
unless parent_st.world_writable?
remove_entry path, force
return
end
unless parent_st.sticky?
raise ArgumentError, "parent directory is world writable, FileUtils#remove_entry_secure does not work; abort: #{path.inspect} (parent directory mode #{'%o' % parent_st.mode})"
end
euid = Process.euid
dot_file = fullpath + "/."
begin
File.open(dot_file) {|f|
unless fu_stat_identical_entry?(st, f.stat)
File.unlink fullpath
return
end
f.chown euid, -1
f.chmod 0700
}
rescue EISDIR # JRuby in non-native mode can't open files as dirs
File.lstat(dot_file).tap {|fstat|
unless fu_stat_identical_entry?(st, fstat)
File.unlink fullpath
return
end
File.chown euid, -1, dot_file
File.chmod 0700, dot_file
}
end
unless fu_stat_identical_entry?(st, File.lstat(fullpath))
File.unlink fullpath
return
end
root = Entry_.new(path)
root.preorder_traverse do |ent|
if ent.directory?
ent.chown euid, -1
ent.chmod 0700
end
end
root.postorder_traverse do |ent|
begin
ent.remove
rescue
raise unless force
end
end
rescue
raise unless force
end
module_function :remove_entry_secure
def fu_have_symlink?   #:nodoc:
File.symlink nil, nil
rescue NotImplementedError
return false
rescue TypeError
return true
end
private_module_function :fu_have_symlink?
def fu_stat_identical_entry?(a, b)   #:nodoc:
a.dev == b.dev and a.ino == b.ino
end
private_module_function :fu_stat_identical_entry?
def remove_entry(path, force = false)
Entry_.new(path).postorder_traverse do |ent|
begin
ent.remove
rescue
raise unless force
end
end
rescue
raise unless force
end
module_function :remove_entry
def remove_file(path, force = false)
Entry_.new(path).remove_file
rescue
raise unless force
end
module_function :remove_file
def remove_dir(path, force = false)
remove_entry path, force   # FIXME?? check if it is a directory
end
module_function :remove_dir
def compare_file(a, b)
return false unless File.size(a) == File.size(b)
File.open(a, 'rb') {|fa|
File.open(b, 'rb') {|fb|
return compare_stream(fa, fb)
}
}
end
module_function :compare_file
alias identical? compare_file
alias cmp compare_file
module_function :identical?
module_function :cmp
def compare_stream(a, b)
bsize = fu_stream_blksize(a, b)
if RUBY_VERSION > "2.4"
sa = String.new(capacity: bsize)
sb = String.new(capacity: bsize)
else
sa = String.new
sb = String.new
end
begin
a.read(bsize, sa)
b.read(bsize, sb)
return true if sa.empty? && sb.empty?
end while sa == sb
false
end
module_function :compare_stream
def install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil,
noop: nil, verbose: nil)
if verbose
msg = +"install -c"
msg << ' -p' if preserve
msg << ' -m ' << mode_to_s(mode) if mode
msg << " -o #{owner}" if owner
msg << " -g #{group}" if group
msg << ' ' << [src,dest].flatten.join(' ')
fu_output_message msg
end
return if noop
uid = fu_get_uid(owner)
gid = fu_get_gid(group)
fu_each_src_dest(src, dest) do |s, d|
st = File.stat(s)
unless File.exist?(d) and compare_file(s, d)
remove_file d, true
copy_file s, d
File.utime st.atime, st.mtime, d if preserve
File.chmod fu_mode(mode, st), d if mode
File.chown uid, gid, d if uid or gid
end
end
end
module_function :install
def user_mask(target)  #:nodoc:
target.each_char.inject(0) do |mask, chr|
case chr
when "u"
mask | 04700
when "g"
mask | 02070
when "o"
mask | 01007
when "a"
mask | 07777
else
raise ArgumentError, "invalid `who' symbol in file mode: #{chr}"
end
end
end
private_module_function :user_mask
def apply_mask(mode, user_mask, op, mode_mask)   #:nodoc:
case op
when '='
(mode & ~user_mask) | (user_mask & mode_mask)
when '+'
mode | (user_mask & mode_mask)
when '-'
mode & ~(user_mask & mode_mask)
end
end
private_module_function :apply_mask
def symbolic_modes_to_i(mode_sym, path)  #:nodoc:
mode = if File::Stat === path
path.mode
else
File.stat(path).mode
end
mode_sym.split(/,/).inject(mode & 07777) do |current_mode, clause|
target, *actions = clause.split(/([=+-])/)
raise ArgumentError, "invalid file mode: #{mode_sym}" if actions.empty?
target = 'a' if target.empty?
user_mask = user_mask(target)
actions.each_slice(2) do |op, perm|
need_apply = op == '='
mode_mask = (perm || '').each_char.inject(0) do |mask, chr|
case chr
when "r"
mask | 0444
when "w"
mask | 0222
when "x"
mask | 0111
when "X"
if FileTest.directory? path
mask | 0111
else
mask
end
when "s"
mask | 06000
when "t"
mask | 01000
when "u", "g", "o"
if mask.nonzero?
current_mode = apply_mask(current_mode, user_mask, op, mask)
end
need_apply = false
copy_mask = user_mask(chr)
(current_mode & copy_mask) / (copy_mask & 0111) * (user_mask & 0111)
else
raise ArgumentError, "invalid `perm' symbol in file mode: #{chr}"
end
end
if mode_mask.nonzero? || need_apply
current_mode = apply_mask(current_mode, user_mask, op, mode_mask)
end
end
current_mode
end
end
private_module_function :symbolic_modes_to_i
def fu_mode(mode, path)  #:nodoc:
mode.is_a?(String) ? symbolic_modes_to_i(mode, path) : mode
end
private_module_function :fu_mode
def mode_to_s(mode)  #:nodoc:
mode.is_a?(String) ? mode : "%o" % mode
end
private_module_function :mode_to_s
def chmod(mode, list, noop: nil, verbose: nil)
list = fu_list(list)
fu_output_message sprintf('chmod %s %s', mode_to_s(mode), list.join(' ')) if verbose
return if noop
list.each do |path|
Entry_.new(path).chmod(fu_mode(mode, path))
end
end
module_function :chmod
def chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
list = fu_list(list)
fu_output_message sprintf('chmod -R%s %s %s',
(force ? 'f' : ''),
mode_to_s(mode), list.join(' ')) if verbose
return if noop
list.each do |root|
Entry_.new(root).traverse do |ent|
begin
ent.chmod(fu_mode(mode, ent.path))
rescue
raise unless force
end
end
end
end
module_function :chmod_R
def chown(user, group, list, noop: nil, verbose: nil)
list = fu_list(list)
fu_output_message sprintf('chown %s %s',
(group ? "#{user}:#{group}" : user || ':'),
list.join(' ')) if verbose
return if noop
uid = fu_get_uid(user)
gid = fu_get_gid(group)
list.each do |path|
Entry_.new(path).chown uid, gid
end
end
module_function :chown
def chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
list = fu_list(list)
fu_output_message sprintf('chown -R%s %s %s',
(force ? 'f' : ''),
(group ? "#{user}:#{group}" : user || ':'),
list.join(' ')) if verbose
return if noop
uid = fu_get_uid(user)
gid = fu_get_gid(group)
list.each do |root|
Entry_.new(root).traverse do |ent|
begin
ent.chown uid, gid
rescue
raise unless force
end
end
end
end
module_function :chown_R
begin

rescue LoadError # rescue LoadError for miniruby
end
def fu_get_uid(user)   #:nodoc:
return nil unless user
case user
when Integer
user
when /\A\d+\z/
user.to_i
else
Etc.getpwnam(user) ? Etc.getpwnam(user).uid : nil
end
end
private_module_function :fu_get_uid
def fu_get_gid(group)   #:nodoc:
return nil unless group
case group
when Integer
group
when /\A\d+\z/
group.to_i
else
Etc.getgrnam(group) ? Etc.getgrnam(group).gid : nil
end
end
private_module_function :fu_get_gid
def touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
list = fu_list(list)
t = mtime
if verbose
fu_output_message "touch #{nocreate ? '-c ' : ''}#{t ? t.strftime('-t %Y%m%d%H%M.%S ') : ''}#{list.join ' '}"
end
return if noop
list.each do |path|
created = nocreate
begin
File.utime(t, t, path)
rescue Errno::ENOENT
raise if created
File.open(path, 'a') {
;
}
created = true
retry if t
end
end
end
module_function :touch
private
module StreamUtils_
private
case (defined?(::RbConfig) ? ::RbConfig::CONFIG['host_os'] : ::RUBY_PLATFORM)
when /mswin|mingw/
def fu_windows?; true end
else
def fu_windows?; false end
end
def fu_copy_stream0(src, dest, blksize = nil)   #:nodoc:
IO.copy_stream(src, dest)
end
def fu_stream_blksize(*streams)
streams.each do |s|
next unless s.respond_to?(:stat)
size = fu_blksize(s.stat)
return size if size
end
fu_default_blksize()
end
def fu_blksize(st)
s = st.blksize
return nil unless s
return nil if s == 0
s
end
def fu_default_blksize
1024
end
end
include StreamUtils_
extend StreamUtils_
class Entry_   #:nodoc: internal use only
include StreamUtils_
def initialize(a, b = nil, deref = false)
@prefix = @rel = @path = nil
if b
@prefix = a
@rel = b
else
@path = a
end
@deref = deref
@stat = nil
@lstat = nil
end
def inspect
"\#<#{self.class} #{path()}>"
end
def path
if @path
File.path(@path)
else
join(@prefix, @rel)
end
end
def prefix
@prefix || @path
end
def rel
@rel
end
def dereference?
@deref
end
def exist?
begin
lstat
true
rescue Errno::ENOENT
false
end
end
def file?
s = lstat!
s and s.file?
end
def directory?
s = lstat!
s and s.directory?
end
def symlink?
s = lstat!
s and s.symlink?
end
def chardev?
s = lstat!
s and s.chardev?
end
def blockdev?
s = lstat!
s and s.blockdev?
end
def socket?
s = lstat!
s and s.socket?
end
def pipe?
s = lstat!
s and s.pipe?
end
S_IF_DOOR = 0xD000
def door?
s = lstat!
s and (s.mode & 0xF000 == S_IF_DOOR)
end
def entries
opts = {}
opts[:encoding] = ::Encoding::UTF_8 if fu_windows?
Dir.children(path, opts)\
.map {|n| Entry_.new(prefix(), join(rel(), n.untaint)) }
end
def stat
return @stat if @stat
if lstat() and lstat().symlink?
@stat = File.stat(path())
else
@stat = lstat()
end
@stat
end
def stat!
return @stat if @stat
if lstat! and lstat!.symlink?
@stat = File.stat(path())
else
@stat = lstat!
end
@stat
rescue SystemCallError
nil
end
def lstat
if dereference?
@lstat ||= File.stat(path())
else
@lstat ||= File.lstat(path())
end
end
def lstat!
lstat()
rescue SystemCallError
nil
end
def chmod(mode)
if symlink?
File.lchmod mode, path() if have_lchmod?
else
File.chmod mode, path()
end
end
def chown(uid, gid)
if symlink?
File.lchown uid, gid, path() if have_lchown?
else
File.chown uid, gid, path()
end
end
def link(dest)
case
when directory?
if !File.exist?(dest) and descendant_directory?(dest, path)
raise ArgumentError, "cannot link directory %s to itself %s" % [path, dest]
end
begin
Dir.mkdir dest
rescue
raise unless File.directory?(dest)
end
else
File.link path(), dest
end
end
def copy(dest)
lstat
case
when file?
copy_file dest
when directory?
if !File.exist?(dest) and descendant_directory?(dest, path)
raise ArgumentError, "cannot copy directory %s to itself %s" % [path, dest]
end
begin
Dir.mkdir dest
rescue
raise unless File.directory?(dest)
end
when symlink?
File.symlink File.readlink(path()), dest
when chardev?
raise "cannot handle device file" unless File.respond_to?(:mknod)
mknod dest, ?c, 0666, lstat().rdev
when blockdev?
raise "cannot handle device file" unless File.respond_to?(:mknod)
mknod dest, ?b, 0666, lstat().rdev
when socket?
raise "cannot handle socket" unless File.respond_to?(:mknod)
mknod dest, nil, lstat().mode, 0
when pipe?
raise "cannot handle FIFO" unless File.respond_to?(:mkfifo)
mkfifo dest, 0666
when door?
raise "cannot handle door: #{path()}"
else
raise "unknown file type: #{path()}"
end
end
def copy_file(dest)
File.open(path()) do |s|
File.open(dest, 'wb', s.stat.mode) do |f|
IO.copy_stream(s, f)
end
end
end
def copy_metadata(path)
st = lstat()
if !st.symlink?
File.utime st.atime, st.mtime, path
end
mode = st.mode
begin
if st.symlink?
begin
File.lchown st.uid, st.gid, path
rescue NotImplementedError
end
else
File.chown st.uid, st.gid, path
end
rescue Errno::EPERM, Errno::EACCES
mode &= 01777
end
if st.symlink?
begin
File.lchmod mode, path
rescue NotImplementedError
end
else
File.chmod mode, path
end
end
def remove
if directory?
remove_dir1
else
remove_file
end
end
def remove_dir1
platform_support {
Dir.rmdir path().chomp(?/)
}
end
def remove_file
platform_support {
File.unlink path
}
end
def platform_support
return yield unless fu_windows?
first_time_p = true
begin
yield
rescue Errno::ENOENT
raise
rescue => err
if first_time_p
first_time_p = false
begin
File.chmod 0700, path()   # Windows does not have symlink
retry
rescue SystemCallError
end
end
raise err
end
end
def preorder_traverse
stack = [self]
while ent = stack.pop
yield ent
stack.concat ent.entries.reverse if ent.directory?
end
end
alias traverse preorder_traverse
def postorder_traverse
if directory?
entries().each do |ent|
ent.postorder_traverse do |e|
yield e
end
end
end
ensure
yield self
end
def wrap_traverse(pre, post)
pre.call self
if directory?
entries.each do |ent|
ent.wrap_traverse pre, post
end
end
post.call self
end
private
$fileutils_rb_have_lchmod = nil
def have_lchmod?
if $fileutils_rb_have_lchmod == nil
$fileutils_rb_have_lchmod = check_have_lchmod?
end
$fileutils_rb_have_lchmod
end
def check_have_lchmod?
return false unless File.respond_to?(:lchmod)
File.lchmod 0
return true
rescue NotImplementedError
return false
end
$fileutils_rb_have_lchown = nil
def have_lchown?
if $fileutils_rb_have_lchown == nil
$fileutils_rb_have_lchown = check_have_lchown?
end
$fileutils_rb_have_lchown
end
def check_have_lchown?
return false unless File.respond_to?(:lchown)
File.lchown nil, nil
return true
rescue NotImplementedError
return false
end
def join(dir, base)
return File.path(dir) if not base or base == '.'
return File.path(base) if not dir or dir == '.'
File.join(dir, base)
end
if File::ALT_SEPARATOR
DIRECTORY_TERM = "(?=[/#{Regexp.quote(File::ALT_SEPARATOR)}]|\\z)"
else
DIRECTORY_TERM = "(?=/|\\z)"
end
SYSCASE = File::FNM_SYSCASE.nonzero? ? "-i" : ""
def descendant_directory?(descendant, ascendant)
/\A(?#{SYSCASE}:#{Regexp.quote(ascendant)})#{DIRECTORY_TERM}/ =~ File.dirname(descendant)
end
end   # class Entry_
def fu_list(arg)   #:nodoc:
[arg].flatten.map {|path| File.path(path) }
end
private_module_function :fu_list
def fu_each_src_dest(src, dest)   #:nodoc:
fu_each_src_dest0(src, dest) do |s, d|
raise ArgumentError, "same file: #{s} and #{d}" if fu_same?(s, d)
yield s, d
end
end
private_module_function :fu_each_src_dest
def fu_each_src_dest0(src, dest)   #:nodoc:
if tmp = Array.try_convert(src)
tmp.each do |s|
s = File.path(s)
yield s, File.join(dest, File.basename(s))
end
else
src = File.path(src)
if File.directory?(dest)
yield src, File.join(dest, File.basename(src))
else
yield src, File.path(dest)
end
end
end
private_module_function :fu_each_src_dest0
def fu_same?(a, b)   #:nodoc:
File.identical?(a, b)
end
private_module_function :fu_same?
@fileutils_output = $stderr
@fileutils_label  = ''
def fu_output_message(msg)   #:nodoc:
@fileutils_output ||= $stderr
@fileutils_label  ||= ''
@fileutils_output.puts @fileutils_label + msg
end
private_module_function :fu_output_message
OPT_TABLE = {}    #:nodoc: internal use only
(private_instance_methods & methods(false)).inject(OPT_TABLE) {|tbl, name|
(tbl[name.to_s] = instance_method(name).parameters).map! {|t, n| n if t == :key}.compact!
tbl
}
def self.commands
OPT_TABLE.keys
end
def self.options
OPT_TABLE.values.flatten.uniq.map {|sym| sym.to_s }
end
def self.have_option?(mid, opt)
li = OPT_TABLE[mid.to_s] or raise ArgumentError, "no such method: #{mid}"
li.include?(opt)
end
def self.options_of(mid)
OPT_TABLE[mid.to_s].map {|sym| sym.to_s }
end
def self.collect_method(opt)
OPT_TABLE.keys.select {|m| OPT_TABLE[m].include?(opt) }
end
LOW_METHODS = singleton_methods(false) - collect_method(:noop).map(&:intern)
module LowMethods
private
def _do_nothing(*)end
::FileUtils::LOW_METHODS.map {|name| alias_method name, :_do_nothing}
end
METHODS = singleton_methods() - [:private_module_function,
:commands, :options, :have_option?, :options_of, :collect_method]
module Verbose
include FileUtils
@fileutils_output  = $stderr
@fileutils_label   = ''
names = ::FileUtils.collect_method(:verbose)
names.each do |name|
module_eval(<<-EOS, __FILE__, __LINE__ + 1)
def #{name}(*args, **options)
super(*args, **options, verbose: true)
end
EOS
end
private(*names)
extend self
class << self
public(*::FileUtils::METHODS)
end
end
module NoWrite
include FileUtils
include LowMethods
@fileutils_output  = $stderr
@fileutils_label   = ''
names = ::FileUtils.collect_method(:noop)
names.each do |name|
module_eval(<<-EOS, __FILE__, __LINE__ + 1)
def #{name}(*args, **options)
super(*args, **options, noop: true)
end
EOS
end
private(*names)
extend self
class << self
public(*::FileUtils::METHODS)
end
end
module DryRun
include FileUtils
include LowMethods
@fileutils_output  = $stderr
@fileutils_label   = ''
names = ::FileUtils.collect_method(:noop)
names.each do |name|
module_eval(<<-EOS, __FILE__, __LINE__ + 1)
def #{name}(*args, **options)
super(*args, **options, noop: true, verbose: true)
end
EOS
end
private(*names)
extend self
class << self
public(*::FileUtils::METHODS)
end
end
end
begin

rescue LoadError # rescue LoadError for miniruby
end
class Dir
@@systmpdir ||= defined?(Etc.systmpdir) ? Etc.systmpdir : '/tmp'
##
def self.tmpdir
if $SAFE > 0
@@systmpdir.dup
else
tmp = nil
[ENV['TMPDIR'], ENV['TMP'], ENV['TEMP'], @@systmpdir, '/tmp', '.'].each do |dir|
next if !dir
dir = File.expand_path(dir)
if stat = File.stat(dir) and stat.directory? and stat.writable? and
(!stat.world_writable? or stat.sticky?)
tmp = dir
break
end rescue nil
end
raise ArgumentError, "could not find a temporary directory" unless tmp
tmp
end
end
def self.mktmpdir(prefix_suffix=nil, *rest)
path = Tmpname.create(prefix_suffix || "d", *rest) {|n| mkdir(n, 0700)}
if block_given?
begin
yield path
ensure
stat = File.stat(File.dirname(path))
if stat.world_writable? and !stat.sticky?
raise ArgumentError, "parent directory is world writable but not sticky"
end
FileUtils.remove_entry path
end
else
path
end
end
module Tmpname
module_function
def tmpdir
Dir.tmpdir
end
def create(basename, tmpdir=nil, max_try: nil, **opts)
if $SAFE > 0 and tmpdir.tainted?
tmpdir = '/tmp'
else
tmpdir ||= tmpdir()
end
n = nil
prefix, suffix = basename
prefix = (String.try_convert(prefix) or
raise ArgumentError, "unexpected prefix: #{prefix.inspect}")
prefix = prefix.delete("#{File::SEPARATOR}#{File::ALT_SEPARATOR}")
suffix &&= (String.try_convert(suffix) or
raise ArgumentError, "unexpected suffix: #{suffix.inspect}")
suffix &&= suffix.delete("#{File::SEPARATOR}#{File::ALT_SEPARATOR}")
begin
t = Time.now.strftime("%Y%m%d")
path = "#{prefix}#{t}-#{$$}-#{rand(0x100000000).to_s(36)}"\
"#{n ? %[-#{n}] : ''}#{suffix||''}"
path = File.join(tmpdir, path)
yield(path, n, opts)
rescue Errno::EEXIST
n ||= 0
n += 1
retry if !max_try or n < max_try
raise "cannot generate temporary name using `#{basename}' under `#{tmpdir}'"
end
path
end
end
end
class Tempfile < DelegateClass(File)
def initialize(basename="", tmpdir=nil, mode: 0, **options)
warn "Tempfile.new doesn't call the given block.", uplevel: 1 if block_given?
@unlinked = false
@mode = mode|File::RDWR|File::CREAT|File::EXCL
::Dir::Tmpname.create(basename, tmpdir, options) do |tmpname, n, opts|
opts[:perm] = 0600
@tmpfile = File.open(tmpname, @mode, opts)
@opts = opts.freeze
end
ObjectSpace.define_finalizer(self, Remover.new(@tmpfile))
super(@tmpfile)
end
def open
_close
mode = @mode & ~(File::CREAT|File::EXCL)
@tmpfile = File.open(@tmpfile.path, mode, @opts)
__setobj__(@tmpfile)
end
def _close   
@tmpfile.close
end
protected :_close
def close(unlink_now=false)
_close
unlink if unlink_now
end
def close!
close(true)
end
def unlink
return if @unlinked
begin
File.unlink(@tmpfile.path)
rescue Errno::ENOENT
rescue Errno::EACCES
return
end
ObjectSpace.undefine_finalizer(self)
@unlinked = true
end
alias delete unlink
def path
@unlinked ? nil : @tmpfile.path
end
def size
if !@tmpfile.closed?
@tmpfile.size # File#size calls rb_io_flush_raw()
else
File.size(@tmpfile.path)
end
end
alias length size
def inspect
if closed?
"#<#{self.class}:#{path} (closed)>"
else
"#<#{self.class}:#{path}>"
end
end
class Remover
def initialize(tmpfile)
@pid = Process.pid
@tmpfile = tmpfile
end
def call(*args)
return if @pid != Process.pid
$stderr.puts "removing #{@tmpfile.path}..." if $DEBUG
@tmpfile.close
begin
File.unlink(@tmpfile.path)
rescue Errno::ENOENT
end
$stderr.puts "done" if $DEBUG
end
end
class << self
def open(*args)
tempfile = new(*args)
if block_given?
begin
yield(tempfile)
ensure
tempfile.close
end
else
tempfile
end
end
end
end
def Tempfile.create(basename="", tmpdir=nil, mode: 0, **options)
tmpfile = nil
Dir::Tmpname.create(basename, tmpdir, options) do |tmpname, n, opts|
mode |= File::RDWR|File::CREAT|File::EXCL
opts[:perm] = 0600
tmpfile = File.open(tmpname, mode, opts)
end
if block_given?
begin
yield tmpfile
ensure
unless tmpfile.closed?
if File.identical?(tmpfile, tmpfile.path)
unlinked = File.unlink tmpfile.path rescue nil
end
tmpfile.close
end
unless unlinked
begin
File.unlink tmpfile.path
rescue Errno::ENOENT
end
end
end
else
tmpfile
end
end
##
module Shellwords
def shellsplit(line)
words = []
field = String.new
line.scan(/\G\s*(?>([^\s\\\'\"]+)|'([^\']*)'|"((?:[^\"\\]|\\.)*)"|(\\.?)|(\S))(\s|\z)?/m) do
|word, sq, dq, esc, garbage, sep|
raise ArgumentError, "Unmatched double quote: #{line.inspect}" if garbage
field << (word || sq || (dq && dq.gsub(/\\([$`"\\\n])/, '\\1')) || esc.gsub(/\\(.)/, '\\1'))
if sep
words << field
field = String.new
end
end
words
end
alias shellwords shellsplit
module_function :shellsplit, :shellwords
class << self
alias split shellsplit
end
def shellescape(str)
str = str.to_s
return "''".dup if str.empty?
str = str.dup
str.gsub!(/([^A-Za-z0-9_\-.,:\/@\n])/, "\\\\\\1")
str.gsub!(/\n/, "'\n'")
return str
end
module_function :shellescape
class << self
alias escape shellescape
end
def shelljoin(array)
array.map { |arg| shellescape(arg) }.join(' ')
end
module_function :shelljoin
class << self
alias join shelljoin
end
end
class String
def shellsplit
Shellwords.split(self)
end
def shellescape
Shellwords.escape(self)
end
end
class Array
def shelljoin
Shellwords.join(self)
end
end
class CGI
module TagMaker
def nn_element(element, attributes = {})
s = nOE_element(element, attributes)
if block_given?
s << yield.to_s
end
s << "</#{element.upcase}>"
end
def nn_element_def(attributes = {}, &block)
nn_element(__callee__, attributes, &block)
end
def nOE_element(element, attributes = {})
attributes={attributes=>nil} if attributes.kind_of?(String)
s = "<#{element.upcase}".dup
attributes.each do|name, value|
next unless value
s << " "
s << CGI::escapeHTML(name.to_s)
if value != true
s << '="'
s << CGI::escapeHTML(value.to_s)
s << '"'
end
end
s << ">"
end
def nOE_element_def(attributes = {}, &block)
nOE_element(__callee__, attributes, &block)
end
def nO_element(element, attributes = {})
s = nOE_element(element, attributes)
if block_given?
s << yield.to_s
s << "</#{element.upcase}>"
end
s
end
def nO_element_def(attributes = {}, &block)
nO_element(__callee__, attributes, &block)
end
end # TagMaker
module HtmlExtension
def a(href = "") # :yield:
attributes = if href.kind_of?(String)
{ "HREF" => href }
else
href
end
super(attributes)
end
def base(href = "") # :yield:
attributes = if href.kind_of?(String)
{ "HREF" => href }
else
href
end
super(attributes)
end
def blockquote(cite = {})  # :yield:
attributes = if cite.kind_of?(String)
{ "CITE" => cite }
else
cite
end
super(attributes)
end
def caption(align = {}) # :yield:
attributes = if align.kind_of?(String)
{ "ALIGN" => align }
else
align
end
super(attributes)
end
def checkbox(name = "", value = nil, checked = nil)
attributes = if name.kind_of?(String)
{ "TYPE" => "checkbox", "NAME" => name,
"VALUE" => value, "CHECKED" => checked }
else
name["TYPE"] = "checkbox"
name
end
input(attributes)
end
def checkbox_group(name = "", *values)
if name.kind_of?(Hash)
values = name["VALUES"]
name = name["NAME"]
end
values.collect{|value|
if value.kind_of?(String)
checkbox(name, value) + value
else
if value[-1] == true || value[-1] == false
checkbox(name, value[0],  value[-1]) +
value[-2]
else
checkbox(name, value[0]) +
value[-1]
end
end
}.join
end
def file_field(name = "", size = 20, maxlength = nil)
attributes = if name.kind_of?(String)
{ "TYPE" => "file", "NAME" => name,
"SIZE" => size.to_s }
else
name["TYPE"] = "file"
name
end
attributes["MAXLENGTH"] = maxlength.to_s if maxlength
input(attributes)
end
def form(method = "post", action = script_name, enctype = "application/x-www-form-urlencoded")
attributes = if method.kind_of?(String)
{ "METHOD" => method, "ACTION" => action,
"ENCTYPE" => enctype }
else
unless method.has_key?("METHOD")
method["METHOD"] = "post"
end
unless method.has_key?("ENCTYPE")
method["ENCTYPE"] = enctype
end
method
end
if block_given?
body = yield
else
body = ""
end
if @output_hidden
body << @output_hidden.collect{|k,v|
"<INPUT TYPE=\"HIDDEN\" NAME=\"#{k}\" VALUE=\"#{v}\">"
}.join
end
super(attributes){body}
end
def hidden(name = "", value = nil)
attributes = if name.kind_of?(String)
{ "TYPE" => "hidden", "NAME" => name, "VALUE" => value }
else
name["TYPE"] = "hidden"
name
end
input(attributes)
end
def html(attributes = {}) # :yield:
if nil == attributes
attributes = {}
elsif "PRETTY" == attributes
attributes = { "PRETTY" => true }
end
pretty = attributes.delete("PRETTY")
pretty = "  " if true == pretty
buf = "".dup
if attributes.has_key?("DOCTYPE")
if attributes["DOCTYPE"]
buf << attributes.delete("DOCTYPE")
else
attributes.delete("DOCTYPE")
end
else
buf << doctype
end
buf << super(attributes)
if pretty
CGI::pretty(buf, pretty)
else
buf
end
end
def image_button(src = "", name = nil, alt = nil)
attributes = if src.kind_of?(String)
{ "TYPE" => "image", "SRC" => src, "NAME" => name,
"ALT" => alt }
else
src["TYPE"] = "image"
src["SRC"] ||= ""
src
end
input(attributes)
end
def img(src = "", alt = "", width = nil, height = nil)
attributes = if src.kind_of?(String)
{ "SRC" => src, "ALT" => alt }
else
src
end
attributes["WIDTH"] = width.to_s if width
attributes["HEIGHT"] = height.to_s if height
super(attributes)
end
def multipart_form(action = nil, enctype = "multipart/form-data")
attributes = if action == nil
{ "METHOD" => "post", "ENCTYPE" => enctype }
elsif action.kind_of?(String)
{ "METHOD" => "post", "ACTION" => action,
"ENCTYPE" => enctype }
else
unless action.has_key?("METHOD")
action["METHOD"] = "post"
end
unless action.has_key?("ENCTYPE")
action["ENCTYPE"] = enctype
end
action
end
if block_given?
form(attributes){ yield }
else
form(attributes)
end
end
def password_field(name = "", value = nil, size = 40, maxlength = nil)
attributes = if name.kind_of?(String)
{ "TYPE" => "password", "NAME" => name,
"VALUE" => value, "SIZE" => size.to_s }
else
name["TYPE"] = "password"
name
end
attributes["MAXLENGTH"] = maxlength.to_s if maxlength
input(attributes)
end
def popup_menu(name = "", *values)
if name.kind_of?(Hash)
values   = name["VALUES"]
size     = name["SIZE"].to_s if name["SIZE"]
multiple = name["MULTIPLE"]
name     = name["NAME"]
else
size = nil
multiple = nil
end
select({ "NAME" => name, "SIZE" => size,
"MULTIPLE" => multiple }){
values.collect{|value|
if value.kind_of?(String)
option({ "VALUE" => value }){ value }
else
if value[value.size - 1] == true
option({ "VALUE" => value[0], "SELECTED" => true }){
value[value.size - 2]
}
else
option({ "VALUE" => value[0] }){
value[value.size - 1]
}
end
end
}.join
}
end
def radio_button(name = "", value = nil, checked = nil)
attributes = if name.kind_of?(String)
{ "TYPE" => "radio", "NAME" => name,
"VALUE" => value, "CHECKED" => checked }
else
name["TYPE"] = "radio"
name
end
input(attributes)
end
def radio_group(name = "", *values)
if name.kind_of?(Hash)
values = name["VALUES"]
name = name["NAME"]
end
values.collect{|value|
if value.kind_of?(String)
radio_button(name, value) + value
else
if value[-1] == true || value[-1] == false
radio_button(name, value[0],  value[-1]) +
value[-2]
else
radio_button(name, value[0]) +
value[-1]
end
end
}.join
end
def reset(value = nil, name = nil)
attributes = if (not value) or value.kind_of?(String)
{ "TYPE" => "reset", "VALUE" => value, "NAME" => name }
else
value["TYPE"] = "reset"
value
end
input(attributes)
end
alias scrolling_list popup_menu
def submit(value = nil, name = nil)
attributes = if (not value) or value.kind_of?(String)
{ "TYPE" => "submit", "VALUE" => value, "NAME" => name }
else
value["TYPE"] = "submit"
value
end
input(attributes)
end
def text_field(name = "", value = nil, size = 40, maxlength = nil)
attributes = if name.kind_of?(String)
{ "TYPE" => "text", "NAME" => name, "VALUE" => value,
"SIZE" => size.to_s }
else
name["TYPE"] = "text"
name
end
attributes["MAXLENGTH"] = maxlength.to_s if maxlength
input(attributes)
end
def textarea(name = "", cols = 70, rows = 10)  # :yield:
attributes = if name.kind_of?(String)
{ "NAME" => name, "COLS" => cols.to_s,
"ROWS" => rows.to_s }
else
name
end
super(attributes)
end
end # HtmlExtension
module Html3
include TagMaker
def doctype
%|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">|
end
instance_method(:nn_element_def).tap do |m|
for element in %w[ A TT I B U STRIKE BIG SMALL SUB SUP EM STRONG
DFN CODE SAMP KBD VAR CITE FONT ADDRESS DIV CENTER MAP
APPLET PRE XMP LISTING DL OL UL DIR MENU SELECT TABLE TITLE
STYLE SCRIPT H1 H2 H3 H4 H5 H6 TEXTAREA FORM BLOCKQUOTE
CAPTION ]
define_method(element.downcase, m)
end
end
instance_method(:nOE_element_def).tap do |m|
for element in %w[ IMG BASE BASEFONT BR AREA LINK PARAM HR INPUT
ISINDEX META ]
define_method(element.downcase, m)
end
end
instance_method(:nO_element_def).tap do |m|
for element in %w[ HTML HEAD BODY P PLAINTEXT DT DD LI OPTION TR
TH TD ]
define_method(element.downcase, m)
end
end
end # Html3
module Html4
include TagMaker
def doctype
%|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">|
end
instance_method(:nn_element_def).tap do |m|
for element in %w[ TT I B BIG SMALL EM STRONG DFN CODE SAMP KBD
VAR CITE ABBR ACRONYM SUB SUP SPAN BDO ADDRESS DIV MAP OBJECT
H1 H2 H3 H4 H5 H6 PRE Q INS DEL DL OL UL LABEL SELECT OPTGROUP
FIELDSET LEGEND BUTTON TABLE TITLE STYLE SCRIPT NOSCRIPT
TEXTAREA FORM A BLOCKQUOTE CAPTION ]
define_method(element.downcase, m)
end
end
instance_method(:nOE_element_def).tap do |m|
for element in %w[ IMG BASE BR AREA LINK PARAM HR INPUT COL META ]
define_method(element.downcase, m)
end
end
instance_method(:nO_element_def).tap do |m|
for element in %w[ HTML BODY P DT DD LI OPTION THEAD TFOOT TBODY
COLGROUP TR TH TD HEAD ]
define_method(element.downcase, m)
end
end
end # Html4
module Html4Tr
include TagMaker
def doctype
%|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">|
end
instance_method(:nn_element_def).tap do |m|
for element in %w[ TT I B U S STRIKE BIG SMALL EM STRONG DFN
CODE SAMP KBD VAR CITE ABBR ACRONYM FONT SUB SUP SPAN BDO
ADDRESS DIV CENTER MAP OBJECT APPLET H1 H2 H3 H4 H5 H6 PRE Q
INS DEL DL OL UL DIR MENU LABEL SELECT OPTGROUP FIELDSET
LEGEND BUTTON TABLE IFRAME NOFRAMES TITLE STYLE SCRIPT
NOSCRIPT TEXTAREA FORM A BLOCKQUOTE CAPTION ]
define_method(element.downcase, m)
end
end
instance_method(:nOE_element_def).tap do |m|
for element in %w[ IMG BASE BASEFONT BR AREA LINK PARAM HR INPUT
COL ISINDEX META ]
define_method(element.downcase, m)
end
end
instance_method(:nO_element_def).tap do |m|
for element in %w[ HTML BODY P DT DD LI OPTION THEAD TFOOT TBODY
COLGROUP TR TH TD HEAD ]
define_method(element.downcase, m)
end
end
end # Html4Tr
module Html4Fr
include TagMaker
def doctype
%|<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">|
end
instance_method(:nn_element_def).tap do |m|
for element in %w[ FRAMESET ]
define_method(element.downcase, m)
end
end
instance_method(:nOE_element_def).tap do |m|
for element in %w[ FRAME ]
define_method(element.downcase, m)
end
end
end # Html4Fr
module Html5
include TagMaker
def doctype
%|<!DOCTYPE HTML>|
end
instance_method(:nn_element_def).tap do |m|
for element in %w[ SECTION NAV ARTICLE ASIDE HGROUP HEADER
FOOTER FIGURE FIGCAPTION S TIME U MARK RUBY BDI IFRAME
VIDEO AUDIO CANVAS DATALIST OUTPUT PROGRESS METER DETAILS
SUMMARY MENU DIALOG I B SMALL EM STRONG DFN CODE SAMP KBD
VAR CITE ABBR SUB SUP SPAN BDO ADDRESS DIV MAP OBJECT
H1 H2 H3 H4 H5 H6 PRE Q INS DEL DL OL UL LABEL SELECT
FIELDSET LEGEND BUTTON TABLE TITLE STYLE SCRIPT NOSCRIPT
TEXTAREA FORM A BLOCKQUOTE CAPTION ]
define_method(element.downcase, m)
end
end
instance_method(:nOE_element_def).tap do |m|
for element in %w[ IMG BASE BR AREA LINK PARAM HR INPUT COL META
COMMAND EMBED KEYGEN SOURCE TRACK WBR ]
define_method(element.downcase, m)
end
end
instance_method(:nO_element_def).tap do |m|
for element in %w[ HTML HEAD BODY P DT DD LI OPTION THEAD TFOOT TBODY
OPTGROUP COLGROUP RT RP TR TH TD ]
define_method(element.downcase, m)
end
end
end # Html5
class HTML3
include Html3
include HtmlExtension
end
class HTML4
include Html4
include HtmlExtension
end
class HTML4Tr
include Html4Tr
include HtmlExtension
end
class HTML4Fr
include Html4Tr
include Html4Fr
include HtmlExtension
end
class HTML5
include Html5
include HtmlExtension
end
end
#--
#++
class CGI
unless const_defined?(:Util)
module Util
@@accept_charset = "UTF-8"
end
include Util
extend Util
end
$CGI_ENV = ENV    # for FCGI support
CR  = "\015"
LF  = "\012"
EOL = CR + LF
REVISION = '$Id: core.rb 66189 2018-12-04 08:22:10Z kazu $' #:nodoc:
NEEDS_BINMODE = File::BINARY != 0
PATH_SEPARATOR = {'UNIX'=>'/', 'WINDOWS'=>'\\', 'MACINTOSH'=>':'}
HTTP_STATUS = {
"OK"                  => "200 OK",
"PARTIAL_CONTENT"     => "206 Partial Content",
"MULTIPLE_CHOICES"    => "300 Multiple Choices",
"MOVED"               => "301 Moved Permanently",
"REDIRECT"            => "302 Found",
"NOT_MODIFIED"        => "304 Not Modified",
"BAD_REQUEST"         => "400 Bad Request",
"AUTH_REQUIRED"       => "401 Authorization Required",
"FORBIDDEN"           => "403 Forbidden",
"NOT_FOUND"           => "404 Not Found",
"METHOD_NOT_ALLOWED"  => "405 Method Not Allowed",
"NOT_ACCEPTABLE"      => "406 Not Acceptable",
"LENGTH_REQUIRED"     => "411 Length Required",
"PRECONDITION_FAILED" => "412 Precondition Failed",
"SERVER_ERROR"        => "500 Internal Server Error",
"NOT_IMPLEMENTED"     => "501 Method Not Implemented",
"BAD_GATEWAY"         => "502 Bad Gateway",
"VARIANT_ALSO_VARIES" => "506 Variant Also Negotiates"
}
def env_table
ENV
end
def stdinput
$stdin
end
def stdoutput
$stdout
end
private :env_table, :stdinput, :stdoutput
def http_header(options='text/html')
if options.is_a?(String)
content_type = options
buf = _header_for_string(content_type)
elsif options.is_a?(Hash)
if options.size == 1 && options.has_key?('type')
content_type = options['type']
buf = _header_for_string(content_type)
else
buf = _header_for_hash(options.dup)
end
else
raise ArgumentError.new("expected String or Hash but got #{options.class}")
end
if defined?(MOD_RUBY)
_header_for_modruby(buf)
return ''
else
buf << EOL    # empty line of separator
return buf
end
end # http_header()
alias :header :http_header
def _header_for_string(content_type) #:nodoc:
buf = ''.dup
if nph?()
buf << "#{$CGI_ENV['SERVER_PROTOCOL'] || 'HTTP/1.0'} 200 OK#{EOL}"
buf << "Date: #{CGI.rfc1123_date(Time.now)}#{EOL}"
buf << "Server: #{$CGI_ENV['SERVER_SOFTWARE']}#{EOL}"
buf << "Connection: close#{EOL}"
end
buf << "Content-Type: #{content_type}#{EOL}"
if @output_cookies
@output_cookies.each {|cookie| buf << "Set-Cookie: #{cookie}#{EOL}" }
end
return buf
end # _header_for_string
private :_header_for_string
def _header_for_hash(options)  #:nodoc:
buf = ''.dup
## add charset to option['type']
options['type'] ||= 'text/html'
charset = options.delete('charset')
options['type'] += "; charset=#{charset}" if charset
## NPH
options.delete('nph') if defined?(MOD_RUBY)
if options.delete('nph') || nph?()
protocol = $CGI_ENV['SERVER_PROTOCOL'] || 'HTTP/1.0'
status = options.delete('status')
status = HTTP_STATUS[status] || status || '200 OK'
buf << "#{protocol} #{status}#{EOL}"
buf << "Date: #{CGI.rfc1123_date(Time.now)}#{EOL}"
options['server'] ||= $CGI_ENV['SERVER_SOFTWARE'] || ''
options['connection'] ||= 'close'
end
## common headers
status = options.delete('status')
buf << "Status: #{HTTP_STATUS[status] || status}#{EOL}" if status
server = options.delete('server')
buf << "Server: #{server}#{EOL}" if server
connection = options.delete('connection')
buf << "Connection: #{connection}#{EOL}" if connection
type = options.delete('type')
buf << "Content-Type: #{type}#{EOL}" #if type
length = options.delete('length')
buf << "Content-Length: #{length}#{EOL}" if length
language = options.delete('language')
buf << "Content-Language: #{language}#{EOL}" if language
expires = options.delete('expires')
buf << "Expires: #{CGI.rfc1123_date(expires)}#{EOL}" if expires
## cookie
if cookie = options.delete('cookie')
case cookie
when String, Cookie
buf << "Set-Cookie: #{cookie}#{EOL}"
when Array
arr = cookie
arr.each {|c| buf << "Set-Cookie: #{c}#{EOL}" }
when Hash
hash = cookie
hash.each_value {|c| buf << "Set-Cookie: #{c}#{EOL}" }
end
end
if @output_cookies
@output_cookies.each {|c| buf << "Set-Cookie: #{c}#{EOL}" }
end
## other headers
options.each do |key, value|
buf << "#{key}: #{value}#{EOL}"
end
return buf
end # _header_for_hash
private :_header_for_hash
def nph?  #:nodoc:
return /IIS\/(\d+)/.match($CGI_ENV['SERVER_SOFTWARE']) && $1.to_i < 5
end
def _header_for_modruby(buf)  #:nodoc:
request = Apache::request
buf.scan(/([^:]+): (.+)#{EOL}/o) do |name, value|
$stderr.printf("name:%s value:%s\n", name, value) if $DEBUG
case name
when 'Set-Cookie'
request.headers_out.add(name, value)
when /^status$/i
request.status_line = value
request.status = value.to_i
when /^content-type$/i
request.content_type = value
when /^content-encoding$/i
request.content_encoding = value
when /^location$/i
request.status = 302 if request.status == 200
request.headers_out[name] = value
else
request.headers_out[name] = value
end
end
request.send_http_header
return ''
end
private :_header_for_modruby
def out(options = "text/html") # :yield:
options = { "type" => options } if options.kind_of?(String)
content = yield
options["length"] = content.bytesize.to_s
output = stdoutput
output.binmode if defined? output.binmode
output.print http_header(options)
output.print content unless "HEAD" == env_table['REQUEST_METHOD']
end
def print(*options)
stdoutput.print(*options)
end
def CGI::parse(query)
params = {}
query.split(/[&;]/).each do |pairs|
key, value = pairs.split('=',2).collect{|v| CGI::unescape(v) }
next unless key
params[key] ||= []
params[key].push(value) if value
end
params.default=[].freeze
params
end
##MAX_CONTENT_LENGTH  = 2 * 1024 * 1024
MAX_MULTIPART_COUNT = 128
module QueryExtension
%w[ CONTENT_LENGTH SERVER_PORT ].each do |env|
define_method(env.delete_prefix('HTTP_').downcase) do
(val = env_table[env]) && Integer(val)
end
end
%w[ AUTH_TYPE CONTENT_TYPE GATEWAY_INTERFACE PATH_INFO
PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST
REMOTE_IDENT REMOTE_USER REQUEST_METHOD SCRIPT_NAME
SERVER_NAME SERVER_PROTOCOL SERVER_SOFTWARE
HTTP_ACCEPT HTTP_ACCEPT_CHARSET HTTP_ACCEPT_ENCODING
HTTP_ACCEPT_LANGUAGE HTTP_CACHE_CONTROL HTTP_FROM HTTP_HOST
HTTP_NEGOTIATE HTTP_PRAGMA HTTP_REFERER HTTP_USER_AGENT ].each do |env|
define_method(env.delete_prefix('HTTP_').downcase) do
env_table[env]
end
end
def raw_cookie
env_table["HTTP_COOKIE"]
end
def raw_cookie2
env_table["HTTP_COOKIE2"]
end
attr_accessor :cookies
attr_reader :params
attr_reader :files
def params=(hash)
@params.clear
@params.update(hash)
end
##
def read_multipart(boundary, content_length)
## read first boundary
stdin = stdinput
first_line = "--#{boundary}#{EOL}"
content_length -= first_line.bytesize
status = stdin.read(first_line.bytesize)
raise EOFError.new("no content body")  unless status
raise EOFError.new("bad content body") unless first_line == status
## parse and set params
params = {}
@files = {}
boundary_rexp = /--#{Regexp.quote(boundary)}(#{EOL}|--)/
boundary_size = "#{EOL}--#{boundary}#{EOL}".bytesize
buf = ''.dup
bufsize = 10 * 1024
max_count = MAX_MULTIPART_COUNT
n = 0
tempfiles = []
while true
(n += 1) < max_count or raise StandardError.new("too many parameters.")
## create body (StringIO or Tempfile)
body = create_body(bufsize < content_length)
tempfiles << body if defined?(Tempfile) && body.kind_of?(Tempfile)
class << body
if method_defined?(:path)
alias local_path path
else
def local_path
nil
end
end
attr_reader :original_filename, :content_type
end
## find head and boundary
head = nil
separator = EOL * 2
until head && matched = boundary_rexp.match(buf)
if !head && pos = buf.index(separator)
len  = pos + EOL.bytesize
head = buf[0, len]
buf  = buf[(pos+separator.bytesize)..-1]
else
if head && buf.size > boundary_size
len = buf.size - boundary_size
body.print(buf[0, len])
buf[0, len] = ''
end
c = stdin.read(bufsize < content_length ? bufsize : content_length)
raise EOFError.new("bad content body") if c.nil? || c.empty?
buf << c
content_length -= c.bytesize
end
end
## read to end of boundary
m = matched
len = m.begin(0)
s = buf[0, len]
if s =~ /(\r?\n)\z/
s = buf[0, len - $1.bytesize]
end
body.print(s)
buf = buf[m.end(0)..-1]
boundary_end = m[1]
content_length = -1 if boundary_end == '--'
## reset file cursor position
body.rewind
## original filename
/Content-Disposition:.* filename=(?:"(.*?)"|([^;\r\n]*))/i.match(head)
filename = $1 || $2 || ''.dup
filename = CGI.unescape(filename) if unescape_filename?()
body.instance_variable_set(:@original_filename, filename.taint)
## content type
/Content-Type: (.*)/i.match(head)
(content_type = $1 || ''.dup).chomp!
body.instance_variable_set(:@content_type, content_type.taint)
## query parameter name
/Content-Disposition:.* name=(?:"(.*?)"|([^;\r\n]*))/i.match(head)
name = $1 || $2 || ''
if body.original_filename.empty?
value=body.read.dup.force_encoding(@accept_charset)
body.close! if defined?(Tempfile) && body.kind_of?(Tempfile)
(params[name] ||= []) << value
unless value.valid_encoding?
if @accept_charset_error_block
@accept_charset_error_block.call(name,value)
else
raise InvalidEncoding,"Accept-Charset encoding error"
end
end
class << params[name].last;self;end.class_eval do
define_method(:read){self}
define_method(:original_filename){""}
define_method(:content_type){""}
end
else
(params[name] ||= []) << body
@files[name]=body
end
## break loop
break if content_length == -1
end
raise EOFError, "bad boundary end of body part" unless boundary_end =~ /--/
params.default = []
params
rescue Exception
if tempfiles
tempfiles.each {|t|
if t.path
t.close!
end
}
end
raise
end # read_multipart
private :read_multipart
def create_body(is_large)  #:nodoc:
if is_large

body = Tempfile.new('CGI', encoding: Encoding::ASCII_8BIT)
else
begin

body = StringIO.new("".b)
rescue LoadError

body = Tempfile.new('CGI', encoding: Encoding::ASCII_8BIT)
end
end
body.binmode if defined? body.binmode
return body
end
def unescape_filename?  #:nodoc:
user_agent = $CGI_ENV['HTTP_USER_AGENT']
return /Mac/i.match(user_agent) && /Mozilla/i.match(user_agent) && !/MSIE/i.match(user_agent)
end
def read_from_cmdline

string = unless ARGV.empty?
ARGV.join(' ')
else
if STDIN.tty?
STDERR.print(
%|(offline mode: enter name=value pairs on standard input)\n|
)
end
array = readlines rescue nil
if not array.nil?
array.join(' ').gsub(/\n/n, '')
else
""
end
end.gsub(/\\=/n, '%3D').gsub(/\\&/n, '%26')
words = Shellwords.shellwords(string)
if words.find{|x| /=/n.match(x) }
words.join('&')
else
words.join('+')
end
end
private :read_from_cmdline
def initialize_query()
if ("POST" == env_table['REQUEST_METHOD']) and
%r|\Amultipart/form-data.*boundary=\"?([^\";,]+)\"?|.match(env_table['CONTENT_TYPE'])
current_max_multipart_length = @max_multipart_length.respond_to?(:call) ? @max_multipart_length.call : @max_multipart_length
raise StandardError.new("too large multipart data.") if env_table['CONTENT_LENGTH'].to_i > current_max_multipart_length
boundary = $1.dup
@multipart = true
@params = read_multipart(boundary, Integer(env_table['CONTENT_LENGTH']))
else
@multipart = false
@params = CGI::parse(
case env_table['REQUEST_METHOD']
when "GET", "HEAD"
if defined?(MOD_RUBY)
Apache::request.args or ""
else
env_table['QUERY_STRING'] or ""
end
when "POST"
stdinput.binmode if defined? stdinput.binmode
stdinput.read(Integer(env_table['CONTENT_LENGTH'])) or ''
else
read_from_cmdline
end.dup.force_encoding(@accept_charset)
)
unless Encoding.find(@accept_charset) == Encoding::ASCII_8BIT
@params.each do |key,values|
values.each do |value|
unless value.valid_encoding?
if @accept_charset_error_block
@accept_charset_error_block.call(key,value)
else
raise InvalidEncoding,"Accept-Charset encoding error"
end
end
end
end
end
end
@cookies = CGI::Cookie::parse((env_table['HTTP_COOKIE'] or env_table['COOKIE']))
end
private :initialize_query
def multipart?
@multipart
end
def [](key)
params = @params[key]
return '' unless params
value = params[0]
if @multipart
if value
return value
elsif defined? StringIO
StringIO.new("".b)
else
Tempfile.new("CGI",encoding: Encoding::ASCII_8BIT)
end
else
str = if value then value.dup else "" end
str
end
end
def keys(*args)
@params.keys(*args)
end
def has_key?(*args)
@params.has_key?(*args)
end
alias key? has_key?
alias include? has_key?
end # QueryExtension
class InvalidEncoding < Exception; end
@@accept_charset="UTF-8" if false # needed for rdoc?
def self.accept_charset
@@accept_charset
end
def self.accept_charset=(accept_charset)
@@accept_charset=accept_charset
end
attr_reader :accept_charset
@@max_multipart_length= 128 * 1024 * 1024
def initialize(options = {}, &block) # :yields: name, value
@accept_charset_error_block = block_given? ? block : nil
@options={
:accept_charset=>@@accept_charset,
:max_multipart_length=>@@max_multipart_length
}
case options
when Hash
@options.merge!(options)
when String
@options[:tag_maker]=options
end
@accept_charset=@options[:accept_charset]
@max_multipart_length=@options[:max_multipart_length]
if defined?(MOD_RUBY) && !ENV.key?("GATEWAY_INTERFACE")
Apache.request.setup_cgi_env
end
extend QueryExtension
@multipart = false
initialize_query()  # set @params, @cookies
@output_cookies = nil
@output_hidden = nil
case @options[:tag_maker]
when "html3"

extend Html3
extend HtmlExtension
when "html4"

extend Html4
extend HtmlExtension
when "html4Tr"

extend Html4Tr
extend HtmlExtension
when "html4Fr"

extend Html4Tr
extend Html4Fr
extend HtmlExtension
when "html5"

extend Html5
extend HtmlExtension
end
end
end   # class CGI
class CGI
class Cookie < Array
@@accept_charset="UTF-8" unless defined?(@@accept_charset)
def initialize(name = "", *value)
@domain = nil
@expires = nil
if name.kind_of?(String)
@name = name
%r|^(.*/)|.match(ENV["SCRIPT_NAME"])
@path = ($1 or "")
@secure = false
@httponly = false
return super(value)
end
options = name
unless options.has_key?("name")
raise ArgumentError, "`name' required"
end
@name = options["name"]
value = Array(options["value"])
if options["path"]
@path = options["path"]
else
%r|^(.*/)|.match(ENV["SCRIPT_NAME"])
@path = ($1 or "")
end
@domain = options["domain"]
@expires = options["expires"]
@secure = options["secure"] == true
@httponly = options["httponly"] == true
super(value)
end
attr_accessor :name
attr_accessor :path
attr_accessor :domain
attr_accessor :expires
attr_reader :secure
attr_reader :httponly
def value
self
end
def value=(val)
replace(Array(val))
end
def secure=(val)
@secure = val if val == true or val == false
@secure
end
def httponly=(val)
@httponly = !!val
end
def to_s
val = collect{|v| CGI.escape(v) }.join("&")
buf = "#{@name}=#{val}".dup
buf << "; domain=#{@domain}" if @domain
buf << "; path=#{@path}"     if @path
buf << "; expires=#{CGI::rfc1123_date(@expires)}" if @expires
buf << "; secure"            if @secure
buf << "; HttpOnly"          if @httponly
buf
end
def self.parse(raw_cookie)
cookies = Hash.new([])
return cookies unless raw_cookie
raw_cookie.split(/;\s?/).each do |pairs|
name, values = pairs.split('=',2)
next unless name and values
name = CGI.unescape(name)
values ||= ""
values = values.split('&').collect{|v| CGI.unescape(v,@@accept_charset) }
if cookies.has_key?(name)
values = cookies[name].value + values
end
cookies[name] = Cookie.new(name, *values)
end
cookies
end
def inspect
"#<CGI::Cookie: #{self.to_s.inspect}>"
end
end # class Cookie
end
class CGI
end
CGI.autoload(:HtmlExtension, 'cgi/html')
module NetHttp2
class Request
include Callbacks
DEFAULT_TIMEOUT = 60
attr_reader :method, :uri, :path, :params, :body, :timeout
def initialize(method, uri, path, options={})
@method  = method
@uri     = uri
@path    = path
@params  = options[:params] || {}
@body    = options[:body]
@headers = options[:headers] || {}
@timeout = options[:timeout] || DEFAULT_TIMEOUT
@events = {}
end
def headers
@headers.merge!({
':scheme' => @uri.scheme,
':method' => @method.to_s.upcase,
':path'   => full_path,
})
@headers.merge!(':authority' => "#{@uri.host}:#{@uri.port}") unless @headers[':authority']
if @body
@headers.merge!('content-length' => @body.bytesize)
else
@headers.delete('content-length')
end
@headers.update(@headers) { |_k, v| v.to_s }
@headers.sort.to_h
end
def full_path
path = @path
path += "?#{to_query(@params)}" unless @params.empty?
path
end
private
def to_param(element)
if element.is_a?(TrueClass) || element.is_a?(FalseClass) || element.is_a?(NilClass)
element
elsif element.is_a?(Array)
element.collect(&:to_param).join '/'
else
element.to_s.strip
end
end
def to_query(element, namespace_or_key = nil)
if element.is_a?(Hash)
element.collect do |key, value|
unless (value.is_a?(Hash) || value.is_a?(Array)) && value.empty?
to_query(value, namespace_or_key ? "#{namespace_or_key}[#{key}]" : key)
end
end.compact.sort! * '&'
elsif element.is_a?(Array)
prefix = "#{namespace_or_key}[]"
if element.empty?
to_query(nil, prefix)
else
element.collect { |value| to_query(value, prefix) }.join '&'
end
else
"#{CGI.escape(to_param(namespace_or_key))}=#{CGI.escape(to_param(element).to_s)}"
end
end
end
end
module NetHttp2
module Socket
def self.create(uri, options)
return ssl_socket(uri, options) if options[:ssl]
return proxy_tcp_socket(uri, options) if options[:proxy_addr]
tcp_socket(uri, options)
end
def self.ssl_socket(uri, options)
tcp = if options[:proxy_addr]
proxy_tcp_socket(uri, options)
else
tcp_socket(uri, options)
end
socket            = OpenSSL::SSL::SSLSocket.new(tcp, options[:ssl_context])
socket.sync_close = true
socket.hostname   = options[:proxy_addr] || uri.host
socket.connect
socket
end
def self.tcp_socket(uri, options)
family   = ::Socket::AF_INET
address  = ::Socket.getaddrinfo(uri.host, nil, family).first[3]
sockaddr = ::Socket.pack_sockaddr_in(uri.port, address)
socket = ::Socket.new(family, ::Socket::SOCK_STREAM, 0)
socket.setsockopt(::Socket::IPPROTO_TCP, ::Socket::TCP_NODELAY, 1)
begin
socket.connect_nonblock(sockaddr)
rescue IO::WaitWritable
if IO.select(nil, [socket], nil, options[:connect_timeout])
begin
socket.connect_nonblock(sockaddr)
rescue Errno::EISCONN
rescue
socket.close
raise
end
else
socket.close
raise Errno::ETIMEDOUT
end
end
socket
end
def self.proxy_tcp_socket(uri, options)
proxy_addr = options[:proxy_addr]
proxy_port = options[:proxy_port]
proxy_user = options[:proxy_user]
proxy_pass = options[:proxy_pass]
proxy_uri = URI.parse("#{proxy_addr}:#{proxy_port}")
proxy_socket = tcp_socket(proxy_uri, options)
http_version = '1.1'
buf = "CONNECT #{uri.host}:#{uri.port} HTTP/#{http_version}\r\n"
buf << "Host: #{uri.host}:#{uri.port}\r\n"
if proxy_user
credential = ["#{proxy_user}:#{proxy_pass}"].pack('m')
credential.delete!("\r\n")
buf << "Proxy-Authorization: Basic #{credential}\r\n"
end
buf << "\r\n"
proxy_socket.write(buf)
validate_proxy_response!(proxy_socket)
proxy_socket
end
private
def self.validate_proxy_response!(socket)
result = ''
loop do
line = socket.gets
break if !line || line.strip.empty?
result << line
end
return if result =~ /HTTP\/\d(?:\.\d)?\s+2\d\d\s/
raise(StandardError, "Proxy connection failure:\n#{result}")
end
end
end
module NetHttp2
class Stream
def initialize(options={})
@h2_stream = options[:h2_stream]
@headers   = {}
@data      = ''
@request   = nil
@async     = false
@completed = false
@mutex     = Mutex.new
@cv        = ConditionVariable.new
listen_for_headers
listen_for_data
listen_for_close
end
def id
@h2_stream.id
end
def call_with(request)
@request = request
send_request_data
sync_respond
end
def async_call_with(request)
@request = request
@async   = true
send_request_data
end
def completed?
@completed
end
def async?
@async
end
private
def listen_for_headers
@h2_stream.on(:headers) do |hs_array|
hs = Hash[*hs_array.flatten]
if async?
@request.emit(:headers, hs)
else
@headers.merge!(hs)
end
end
end
def listen_for_data
@h2_stream.on(:data) do |data|
if async?
@request.emit(:body_chunk, data)
else
@data << data
end
end
end
def listen_for_close
@h2_stream.on(:close) do |data|
@completed = true
if async?
@request.emit(:close, data)
else
@mutex.synchronize { @cv.signal }
end
end
end
def send_request_data
headers = @request.headers
body    = @request.body
if body
@h2_stream.headers(headers, end_stream: false)
@h2_stream.data(body, end_stream: true)
else
@h2_stream.headers(headers, end_stream: true)
end
end
def sync_respond
wait_for_completed
NetHttp2::Response.new(headers: @headers, body: @data) if @completed
end
def wait_for_completed
@mutex.synchronize { @cv.wait(@mutex, @request.timeout) }
end
end
end
module NetHttp2
VERSION = '0.18.2'.freeze
end
module NetHttp2
raise "Cannot require NetHttp2, unsupported engine '#{RUBY_ENGINE}'" unless RUBY_ENGINE == "ruby"
end
require("./fiddle")
module Fiddle
class Function
attr_reader :abi
attr_reader :ptr
attr_reader :name
def to_i
ptr.to_i
end
end
end
module Fiddle
class Closure
attr_reader :ctype
attr_reader :args
class BlockCaller < Fiddle::Closure
def initialize ctype, args, abi = Fiddle::Function::DEFAULT, &block
super(ctype, args, abi)
@block = block
end
def call *args
@block.call(*args)
end
end
end
end
module Fiddle
if WINDOWS
def self.win32_last_error
Thread.current[:__FIDDLE_WIN32_LAST_ERROR__]
end
def self.win32_last_error= error
Thread.current[:__FIDDLE_WIN32_LAST_ERROR__] = error
end
end
def self.last_error
Thread.current[:__FIDDLE_LAST_ERROR__]
end
def self.last_error= error
Thread.current[:__DL2_LAST_ERROR__] = error
Thread.current[:__FIDDLE_LAST_ERROR__] = error
end
def dlopen library
Fiddle::Handle.new library
end
module_function :dlopen
RTLD_GLOBAL = Handle::RTLD_GLOBAL
RTLD_LAZY   = Handle::RTLD_LAZY  
RTLD_NOW    = Handle::RTLD_NOW   
end
require("./zlib")
if FileTest.exists?("screenreaderapi.dll") and FileTest.exists?("bass.dll")
$dlldir="."
elsif FileTest.exists?("..\\screenreaderapi.dll") and FileTest.exists?("..\\bass.dll")
$dlldir=".."
elsif FileTest.exists?("..\\..\\screenreaderapi.dll") and FileTest.exists?("..\\..\\bass.dll")
$dlldir="..\\.."
end
$kernel32 = Fiddle.dlopen('kernel32.dll')
$setcurrentdirectory = Fiddle::Function.new($kernel32['SetCurrentDirectory'], [Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$setdlldirectory = Fiddle::Function.new($kernel32['SetDllDirectory'], [Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$multibytetowidechar = Fiddle::Function.new($kernel32['MultiByteToWideChar'], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$widechartomultibyte = Fiddle::Function.new($kernel32['WideCharToMultiByte'], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$getprivateprofilestring = Fiddle::Function.new($kernel32['GetPrivateProfileStringW'], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$writeprivateprofilestring = Fiddle::Function.new($kernel32['WritePrivateProfileStringW'], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$createprocess = Fiddle::Function.new($kernel32['CreateProcess'], [Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, ], Fiddle::TYPE_INT)
$user32 = Fiddle.dlopen("user32")
$showwindow = Fiddle::Function.new($user32['ShowWindow'], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$getforegroundwindow = Fiddle::Function.new($user32['GetForegroundWindow'], [], Fiddle::TYPE_INT)
$getparent = Fiddle::Function.new($user32['GetParent'], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$iswindow = Fiddle::Function.new($user32['IsWindow'], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$findwindow = Fiddle::Function.new($user32['FindWindow'], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$getasynckeystate = Fiddle::Function.new($user32['GetAsyncKeyState'], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$shell32 = Fiddle.dlopen("shell32")
$shgetfolderpath = Fiddle::Function.new($shell32['SHGetFolderPathW'], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
$setdlldirectory.call($dlldir)
begin
begin
$eltenvc=Fiddle.dlopen("eltenvc")
rescue Exception
$eltenvc=Fiddle.dlopen("elten")
end
$cryptmessage = Fiddle::Function.new($eltenvc['CryptMessage'], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
rescue Exception
end
$screenreaderapi=Fiddle.dlopen("screenreaderapi")
$saystring = Fiddle::Function.new($screenreaderapi['sayStringW'], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$sapisaystring = Fiddle::Function.new($screenreaderapi['sapiSayStringW'], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$stopspeech = Fiddle::Function.new($screenreaderapi['stopSpeech'], [], Fiddle::TYPE_INT)
$sapistopspeech = Fiddle::Function.new($screenreaderapi['sapiStopSpeech'], [], Fiddle::TYPE_INT)
$sapisetvolume = Fiddle::Function.new($screenreaderapi['sapiSetVolume'], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$sapisetrate = Fiddle::Function.new($screenreaderapi['sapiSetRate'], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$sapisetvoice = Fiddle::Function.new($screenreaderapi['sapiSetVoice'], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
$sapigetvolume = Fiddle::Function.new($screenreaderapi['sapiGetVolume'], [], Fiddle::TYPE_INT)
$sapigetrate = Fiddle::Function.new($screenreaderapi['sapiGetRate'], [], Fiddle::TYPE_INT)
$sapigetvoice = Fiddle::Function.new($screenreaderapi['sapiGetVoice'], [], Fiddle::TYPE_INT)
$sapiisspeaking = Fiddle::Function.new($screenreaderapi['sapiIsSpeaking'], [], Fiddle::TYPE_INT)
module Bass
BASS = Fiddle.dlopen("bass")
BASS_GetVersion = Fiddle::Function.new(BASS["BASS_GetVersion"], [], Fiddle::TYPE_INT)
BASS_ErrorGetCode = Fiddle::Function.new(BASS["BASS_ErrorGetCode"], [], Fiddle::TYPE_INT)
BASS_Init = Fiddle::Function.new(BASS["BASS_Init"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
BASS_GetConfig = Fiddle::Function.new(BASS["BASS_GetConfig"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_SetConfig = Fiddle::Function.new(BASS["BASS_SetConfig"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_SetConfigPtr = Fiddle::Function.new(BASS["BASS_SetConfigPtr"], [Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
BASS_Free = Fiddle::Function.new(BASS["BASS_Free"], [], Fiddle::TYPE_INT)
BASS_Start = Fiddle::Function.new(BASS["BASS_Start"], [], Fiddle::TYPE_INT)
BASS_Stop = Fiddle::Function.new(BASS["BASS_Stop"], [], Fiddle::TYPE_INT)
BASS_Pause = Fiddle::Function.new(BASS["BASS_Pause"], [], Fiddle::TYPE_INT)
BASS_SetVolume = Fiddle::Function.new(BASS["BASS_SetVolume"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_GetVolume = Fiddle::Function.new(BASS["BASS_GetVolume"], [], Fiddle::TYPE_INT)
BASS_SampleLoad = Fiddle::Function.new(BASS["BASS_SampleLoad"], [Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_SampleCreate = Fiddle::Function.new(BASS["BASS_SampleCreate"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_SampleFree = Fiddle::Function.new(BASS["BASS_SampleFree"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_SampleGetChannel = Fiddle::Function.new(BASS["BASS_SampleGetChannel"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_SampleStop = Fiddle::Function.new(BASS["BASS_SampleStop"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_StreamCreateFile = Fiddle::Function.new(BASS["BASS_StreamCreateFile"], [Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_StreamCreateURL = Fiddle::Function.new(BASS["BASS_StreamCreateURL"], [Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_StreamFree = Fiddle::Function.new(BASS["BASS_StreamFree"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelFlags = Fiddle::Function.new(BASS["BASS_ChannelFlags"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelPlay = Fiddle::Function.new(BASS["BASS_ChannelPlay"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelStop = Fiddle::Function.new(BASS["BASS_ChannelStop"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelPause = Fiddle::Function.new(BASS["BASS_ChannelPause"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelGetData = Fiddle::Function.new(BASS["BASS_ChannelGetData"], [Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelGetLength = Fiddle::Function.new(BASS["BASS_ChannelGetLength"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelGetAttribute = Fiddle::Function.new(BASS["BASS_ChannelGetAttribute"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
BASS_ChannelSetAttribute = Fiddle::Function.new(BASS["BASS_ChannelSetAttribute"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelSlideAttribute = Fiddle::Function.new(BASS["BASS_ChannelSlideAttribute"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelIsSliding = Fiddle::Function.new(BASS["BASS_ChannelIsSliding"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelIsActive = Fiddle::Function.new(BASS["BASS_ChannelIsActive"], [Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelSeconds2Bytes = Fiddle::Function.new(BASS["BASS_ChannelSeconds2Bytes"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelBytes2Seconds = Fiddle::Function.new(BASS["BASS_ChannelBytes2Seconds"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelGetPosition = Fiddle::Function.new(BASS["BASS_ChannelGetPosition"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_ChannelSetPosition = Fiddle::Function.new(BASS["BASS_ChannelSetPosition"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
BASS_StreamGetFilePosition = Fiddle::Function.new(BASS["BASS_StreamGetFilePosition"], [Fiddle::TYPE_INT, Fiddle::TYPE_INT], Fiddle::TYPE_INT)
Errmsg = {
1 => "MEM", 2 => "FILEOPEN", 3 => "DRIVER", 4 => "BUFLOST", 5 => "HANDLE", 6 => "FORMAT", 7 => "POSITION", 8 => "INIT",
9 => "START", 14 => "ALREADY", 18 => "NOCHAN", 19 => "ILLTYPE", 20 => "ILLPARAM", 21 => "NO3D", 22 => "NOEAX", 23 => "DEVICE",
24 => "NOPLAY", 25 => "FREQ", 27 => "NOTFILE", 29 => "NOHW", 31 => "EMPTY", 32 => "NONET", 33 => "CREATE", 34 => "NOFX",
37 => "NOTAVAIL", 38 => "DECODE", 39 => "DX", 40 => "TIMEOUT", 41 => "FILEFORM", 42 => "SPEAKER", 43 => "VERSION", 44 => "CODEC",
45 => "ENDED", -1 => " UNKNOWN",
}
def self.init(hWnd, samplerate = 44100)
return if @init == true
@init = true
if (BASS_GetVersion.call >> 16) != 0x0204
raise("bass.dll 2.4")
end
if BASS_Init.call(-1, samplerate, 4, hWnd, nil) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
BASS_SetConfig.call(0, 1000)
BASS_SetConfig.call(1, 100)
BASS_SetConfig.call(11, 10000)
BASS_SetConfig.call(12, 10000)
BASS_SetConfig.call(15, 150)
BASS_SetConfig.call(21, 1)
BASS_SetConfig.call(24, 2)
end
def self.free
@init = false
if BASS_Free.call == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def self.loadSample(filename, max = 1)
return Sample.new(filename, max)
end
def self.loadStream(filename)
return Stream.new(filename, 0)
end
class Sample
attr_reader :ch
def initialize(filename, max = 1)
if filename[0..3] == "http"
return Bass::Stream.new(filename)
else
p @handle = BASS_SampleLoad.call(0, (filename), 0, 0, 0, max, 0x20000)
end
@ch = @handle
if @handle == 0
return Bass::Stream.new(filename)
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def free
if BASS_SampleFree.call(@handle) == 0
end
end
def play(option = {})
ch = BASS_SampleGetChannel.call(@handle, 0)
if ch == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
if option[:loop]
if BASS_ChannelFlags.call(ch, 4, 4) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if option[:pan]
if BASS_ChannelSetAttribute.call(ch, 3, [option[:pan]].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if option[:volume]
if BASS_ChannelSetAttribute.call(ch, 2, [option[:volume]].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if BASS_ChannelPlay.call(ch, 0) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
return ch
end
def setPan(ch, pan)
if BASS_ChannelSetAttribute.call(ch, 3, [pan].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def setVolume(ch, v)
if BASS_ChannelSetAttribute.call(ch, 2, [v].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def stop(ch = nil)
if ch == nil
if BASS_SampleStop.call(@handle) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
else
if BASS_ChannelStop.call(ch) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
end
end
class Stream
attr_reader :ch
def initialize(filename, pos = 0)
pos = pos.to_i
if filename[0..3] == "http"
@ch = BASS_StreamCreateURL.call((filename), pos, 0, 0, 0)
else
@ch = BASS_StreamCreateFile.call(0, filename, pos, 0, 0, 0, 0)
end
end
def free
if BASS_StreamFree.call(@ch) == 0
end
end
def play(option = {})
if option[:loop]
if BASS_ChannelFlags.call(@ch, 4, 4) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if option[:pan]
if BASS_ChannelSetAttribute.call(@ch, 3, [option[:pan]].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if option[:frequency]
if BASS_ChannelSetAttribute.call(@ch, 3, [option[:frequency]].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if option[:volume]
if BASS_ChannelSetAttribute.call(@ch, 2, [option[:volume]].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
if BASS_ChannelPlay.call(@ch, 0) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def pan=(pan)
if BASS_ChannelSetAttribute.call(@ch, 3, [pan].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def volume=(v)
if BASS_ChannelSetAttribute.call(@ch, 2, [v].pack("f").unpack("I")[0]) == -1
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def stop
if BASS_ChannelStop.call(@ch) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
def seek(pt, flags = 0)
print("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}") if Win32API.new("bass", "BASS_ChannelSetPosition", "iil", "i").call(@ch, 0, flags) == 0
end
end
def free
if BASS_SampleFree.call(@handle) == 0
end
end
def play
if BASS_ChannelPlay.call(@ch, 0) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
return ch
end
def stop(ch = nil)
if BASS_ChannelStop.call(ch) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
if BASS_Encode_Stop.call(@encoder) == 0
raise("BASS_ERROR_#{Errmsg[BASS_ErrorGetCode.call]}")
end
end
class Sound
attr_reader :channel
attr_reader :type
attr_reader :cls
include Bass
attr_reader :file
def initialize(file, type = 1, looper = false)
@file = file
@startposition = 0
ext = File.extname(file).downcase
type = 1 if file[0..3] == "http"
@type = type
case type
when 1
@cls = Bass.loadStream(file)
if @cls == nil or (@cl != nil and @cls.ch == nil)
end
else
@cls = Bass.loadSample(file)
end
return nil if @cls == nil
@channel = @cls.ch
@basefrequency = frequency
BASS_ChannelFlags.call(channel, 4, 4) if looper == true
end
def playing?
playing
end
def playing
if status == 1
return true
else
return false
end
end
def data(len = length(true))
buf = "\0" * len
BASS_ChannelGetData.call(@channel, len, len.size)
end
def status
@lastupdate = 0 if @lastupdate == nil
return 1 if @lastupdate < Time.now.to_i * 1000000 + Time.now.usec + 50000
BASS_ChannelIsActive.call(@channel)
end
def play
@cls.play
end
def stop
@cls.stop
end
def pause
BASS_ChannelPause.call(@channel)
end
def free
@cls.free if @closed != true and @cls != nil
@closed = true
end
def close
free
end
def closed
return true if @closed
return false
end
def frequency
frq = [0].pack("f")
BASS_ChannelGetAttribute.call(@channel, 1, frq)
return frq.unpack("f")[0].to_i
end
def frequency=(f)
frq = [f].pack("f").unpack("i")[0]
BASS_ChannelSetAttribute.call(@channel, 1, frq)
return frq
end
def pan
pn = [0].pack("f")
BASS_ChannelGetAttribute.call(@channel, 3, pn)
return pn.unpack("f")[0]
end
def pan=(n)
pn = [n].pack("f").unpack("i")[0]
BASS_ChannelSetAttribute.call(@channel, 3, pn)
return pn
end
def volume
vol = [0].pack("f")
BASS_ChannelGetAttribute.call(@channel, 2, vol)
return vol.unpack("f")[0]
end
def volume=(v)
vol = [v].pack("f").unpack("i")[0]
BASS_ChannelSetAttribute.call(@channel, 2, vol)
return vol
end
def length(bytes = false)
bts = BASS_ChannelGetLength.call(@channel, 0) + @startposition
return bts if bytes == true
return [BASS_ChannelBytes2Seconds.call(@channel, bts)].pack("i").unpack("f")[0] if @type == 0
return bts.to_f / (@basefrequency * 4)
end
def position(bytes = false, useold = true)
bts = BASS_ChannelGetPosition.call(@channel, 0)
bts += @startposition if useold == true
return bts if bytes == true
@basefrequency = frequency if @basefrequency == 0
return bts.to_f / (@basefrequency * 4)
end
def position=(val, bytes = false)
val = 0.15 if val < 0.15
return 0 if @closed
@posupdated = true
if @type == 100
@updating = true
val *= @basefrequency * 4 if bytes == false
attribs = []
for i in 1..4
attribs[i] = [0].pack("f")
BASS_ChannelGetAttribute.call(@channel, i, attribs[i])
attribs[i] = attribs[i].unpack("i")[0]
end
pl = playing
cmp = BASS_StreamGetFilePosition.call(@channel, 2).to_f / (length(true) - @startposition).to_f
cmp = 1 if cmp == 1.0 / 0.0
if val >= length(true)
if val <= length(true) - frequency
val = length(true) - frequency * 4
else
@updating = false
@omit = true
return
end
end
@cls.stop
@cls.free
@cls = Bass::Stream.new(@file, val * cmp)
@startposition = val
@channel = @cls.ch
for i in 1..attribs.size - 1
BASS_ChannelSetAttribute.call(@channel, i, attribs[i])
end
@cls.play if pl == true
@updating = false
else
val *= @basefrequency * 4 if bytes == false
val = 0 if val < 0
i = 0
for i in 1..50
if BASS_ChannelSetPosition.call(@channel, val, 0) > 0
break
else
val -= (val.to_f / 10000.0).to_i
sleep(0.001)
end
end
end
return val
end
def wait
ld = 0
while length(true) == -1
sleep(0.025)
ld += 1
break if (ld == 400 and position <= 0) or length(true) >= 0
end
while position(true) < length(true) - 128 or length(true) == 0 or position(true) == 0
sleep(0.05)
end
pos = position
l = length
return
while position <= 0.03
sleep(0.01)
end
BASS_ChannelFlags.call(@channel, 4, 4) if closed == false
loop do
sleep(0.01)
sleep(0.01) while @updating
BASS_ChannelFlags.call(@channel, 4, 4) if closed == false if @closed != true
return if @omit
@lastupdate = 0 if @lastupdate == nil
sleep(0.07) if @lastupdate < Time.now.to_i * 1000000 + Time.now.usec + 70000
@posupdated = false
if position(false, false) <= 0.07 and BASS_ChannelIsActive.call(@channel) == 1
break
end
end
return
end
end
end
def cryptmessage(msg)
buf="\0"*(msg.bytesize+18)
begin
$cryptmessage.call(msg,buf,buf.bytesize)
return buf
rescue Exception
return ""
end
end
def unicode(str)
buf="\0"*$multibytetowidechar.call(65001,0,str,str.bytesize,nil,0)*2
$multibytetowidechar.call(65001,0,str,str.bytesize,buf,buf.bytesize/2)
return buf    <<"\0"
end
def deunicode(str)
return "" if str==nil
str<<"\0\0"
buf="\0"*$widechartomultibyte.call(65001,0,str,-1,nil,0,0,nil)
$widechartomultibyte.call(65001,0,str,-1,buf,buf.bytesize,nil,nil)
return buf[0..buf.index("\0")-1]
end
def readini(file,group,key,default="")
r = "\0" * 16384
sz=$getprivateprofilestring.call(unicode(group),unicode(key),unicode(default),r,r.bytesize,unicode(file))
return deunicode(r[0..(sz*2)]).delete("\0")
end
def speech(text,method=0)
text = text.to_s
text = text.gsub("\004LINE\004") {"\r\n"}
$speech_lasttext = text
(($voice!=-1)?$sapisaystring:$saystring).call(unicode(text),method)
$speech_lasttime=Time.now.to_f
return text
end
def speech_stop
(($voice!=-1)?$sapistopspeech:$stopspeech).call
end
def speech_actived
($voice==-1)?false:(($sapiisspeaking.call==1)?true:false)
end
def speech_wait
sleep 0.01 while speech_actived
end
def run(file,hide=false)
env = 0
env = "Windows".split(File::PATH_SEPARATOR) << nil
env = env.pack('p*').unpack('L').first
startinfo = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
startinfo = [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0] if hide
startinfo = startinfo.pack('LLLLLLLLLLLLSSLLLL')
procinfo  = [0,0,0,0].pack('LLLL')
pr = $createprocess.call(0, (file), 0, 0, 0, 0, 0, 0, startinfo, procinfo)
procinfo[0,4].unpack('L').first # pid
return procinfo.unpack('llll')[0]
end
def getdirectory(type)
dr = "\0" * 520
$shgetfolderpath.call(0,type,0,0,dr)
fdr=deunicode(dr)
return fdr[0..fdr.index("\0")||-1]
end
def init
$http = NetHttp2::Client.new("https://elten-net.eu", connect_timeout: 5)
$http.on(:error) { |error|
init if error.is_a?(Errno::ECONNRESET) or error.is_a?(SocketError)
}
end
def erequest(mod, param, data=nil, &b)
init if $http==nil
tries=0
$lastrep||=Time.now.to_i
init if $lastrep<Time.now.to_i-10
begin
request = $http.prepare_request(:get, "/srv/#{mod}.php?#{param}")
body=""
request.on(:body_chunk) {|ch| body+=ch}
request.on(:close) {$lastrep=Time.now.to_i ;b.call(body)}
request.on(:error) {b.call(nil)}
$http.call_async request
rescue Exception
sleep(1)
init
sleep(0.5)
if tries<3
retry
else
b.call(nil)
end
end
end
def play(file)
if file[0..3]!="http"
f=$soundthemepath+"\\SE\\#{file}.ogg"
f="Audio/SE/#{file}.ogg" if FileTest.exists?(f)==false
else
f=file
end
$plid||=0
$players||=[]
$plid=($plid+1)%128
plid=$plid
$players[plid].close if $players[plid]!=nil
$players[plid]=Bass::Sound.new(f)
$players[plid].volume=($volume.to_f/100.0)
$players[plid].play
end
def bgplay(file)
begin
@bgplayer.close if @bgplayer
@bgplayer=Bass::Sound.new($soundthemespath+"\\SE\\#{file}.ogg",1,true)
@bgplayer.play
rescue Exception
end
end
def bgstop
if @bgplayer!=nil
@bgplayer.close
@bgplayer=nil
end
end
Encoding.default_internal=Encoding::UTF_8
$VERBOSE = nil
class Notification
attr_accessor :alert, :sound, :id
def initialize(alert=nil,sound=nil, id="nocat".rand(10**16).to_s)
@alert, @sound, @id =alert, sound, id
end
end
module Notifications
class <<self
def notifications
@notifications||={}
end
def notids
@notids||=[]
end
def join(alert,sound=nil,id='jn_'+rand(10**10).to_s)
push Notification.new(alert,sound,id)
end
def push(n)
if !notids.include?(n.id)
notifications[n.id]=n
notids.push(n.id)
return true
else
return false
end
end
def queue
arr=notifications.values.dup
notifications.clear
return arr
end
end
end
begin
$setcurrentdirectory.call("..") if FileTest.exists?("../elten.ini") and !FileTest.exists?("elten.ini")
$setcurrentdirectory.call("..\\..") if FileTest.exists?("../../elten.ini") and !FileTest.exists?("elten.ini")
$setdlldirectory.call(".")
$eltendata=getdirectory(26)+"\\elten"
$eltendata=".\\eltendata" if readini("elten.ini","Elten","Portable","0").to_i.to_i!=0
$configdata=$eltendata+"\\config"
$soundthemesdata=$eltendata+"\\soundthemes"
$bindata=$eltendata+"\\bin"
if !FileTest.exists?($configdata+"\\appid.dat")
$appid = ""
chars = ("A".."Z").to_a+("a".."z").to_a+("0".."9").to_a
64.times { $appid += chars[rand(chars.length)] }
IO.write($configdata+"\\appid.dat",$appid)
else
$appid=IO.read($configdata+"\\appid.dat")
end
if $*.include?("/autostart")
$name=readini($configdata+"\\login.ini","Login","Name","")
erequest("login","login=1\&name=#{$name}\&token=#{readini($configdata+"\\login.ini","Login","Token","")}\&version=#{readini("elten.ini","Elten","Version","")}+agent\&beta=#{readini("elten.ini","Elten","Beta","")}\&appid=#{$appid}\&crp=#{Base64.urlsafe_encode64(cryptmessage(JSON.generate({'name'=>$name,'time'=>Time.now.to_i})))}") {|ans|
if ans!=nil
d=ans.split("\r\n")
if d[0].to_i==0
$token=d[1]
system("start bin\\elten_tray.bin")
else
exit
end
end
}
sleep(0.1) while !$token
else
$name||=STDIN.gets.delete("\r\n")
$token||=STDIN.gets.delete("\r\n")
$hwnd||=STDIN.gets.delete("\r\n").to_i
end
Bass.init($hwnd||0)
$upd={}
$upd['version']=readini("./elten.ini","Elten","Version","0").to_f
$upd['alpha']=readini("./elten.ini","Elten","Alpha","0").to_i
$upd['beta']=readini("./elten.ini","Elten","Beta","0").to_i
$upd['isbeta']=readini("./elten.ini","Elten","IsBeta","0").to_i
$wn={}
$li=0
loop do
if ($li%20)==0
exit if $*.include?("/autostart") and $findwindow.call("RGSS PLAYER","ELTEN")!=0
if $hwnd
exit if !$iswindow.call($hwnd)
if ($phwnd=$getforegroundwindow.call)!=$hwnd and $getparent.call($phwnd)!=$hwnd
$shown=false
if $hidewindow == 1
if $tray != true and FileTest.exists?("bin/elten_tray.bin") and FileTest.exists?("temp/agent_disabletray.tmp") == false
play("minimize")
run("bin\\elten_tray.bin")
$showwindow.call($hwnd,0)
STDOUT.binmode.write((Marshal.dump({'func'=>'tray'})))
STDOUT.flush
$tray=true
end
end
else
$shown = true
$tray = false if FileTest.exists?("temp/agent_tray.tmp") == false
end
end
end
while STDIN.ready? and ($istream==nil||$istream.eof?)
data=Marshal.load(STDIN)
if data['func']=='srvproc'
erequest(data['mod'],data['param']) {|resp|
if resp==nil
data['resp']=resp
else
data['resp']=resp.force_encoding("utf-8")
end
STDOUT.binmode.write((Marshal.dump(data)))
STDOUT.flush
}
elsif data['func']=="chat_open"
$chat=true
elsif data['func']=="chat_close"
$chat = false
elsif data['func']=='relogin'
$name=data['name']
$token=data['token']
elsif data['func']=='msg_suppress'
$msg_suppress=true
end
end
$msg||=0
if $li==0
$lasttime||=Time.now.to_i
$lastvoice=$voice
$lastrate=$rate
$lastvolume=$volume
$voice=readini($configdata+"\\sapi.ini","Sapi","Voice","-1").to_i
$rate=readini($configdata+"\\sapi.ini","Sapi","Rate","50").to_i
$sapisetvoice.call($voice) if $voice>=0 and $lastvoice!=$voice
$sapisetrate.call(readini($configdata+"\\sapi.ini","Sapi","Rate","50").to_i) if $lastrate!=$rate
$hidewindow = readini($configdata + "\\interface.ini","Interface","HideWindow","0").to_i
$refreshtime = readini($configdata + "\\advanced.ini","Advanced","AgentRefreshTime","1").to_i
$volume = readini($configdata + "\\interface.ini","Interface","MainVolume","80").to_i
$soundthemespath = readini($configdata + "\\soundtheme.ini","SoundTheme","Path","")
if $soundthemespath.size > 0
$soundthemepath = $soundthemesdata + "\\" + $soundthemespath
else
$soundthemepath = "Audio"
end
pr="name=#{$name}\&token=#{$token}\&agent=1\&gz=1\&lasttime=#{$wnlasttime||0}"
pr+="\&shown=1" if $shown==true
pr+="\&chat=1" if $chat==true
pr+="\&upd=1" if ($updlasttime||0)<Time.now.to_i-60
erequest("wn_agent",pr) {|ans|
if ans!=nil
begin
rsp=JSON.load(Zlib.inflate(ans))
$wnlasttime=rsp['time'] if rsp['time'].is_a?(Integer)
$updlasttime=rsp['time'] if rsp['time'].is_a?(Integer) and rsp['upd']!=nil
$ag_msg||=rsp['msg'].to_i
if $ag_msg<(rsp['msg'].to_i||0)
$ag_msg=rsp['msg'].to_i
STDOUT.binmode.write((Marshal.dump({'func'=>'msg','msgs'=>$ag_msg})))
STDOUT.flush
end
begin
if rsp['upd'].is_a?(Hash)
if rsp['upd']['version'].to_f>$upd['version'].to_f
Notifications.join('Elten '+rsp['upd']['version'].to_s,'new','upd_'+rsp['upd']['version'].to_s)
elsif rsp['upd']['beta'].to_f>$upd['beta'].to_f and $upd['isbeta']==1
Notifications.join('Elten '+$upd['version'].to_s+" beta "+rsp['upd']['beta'].to_s,'new','upd_'+rsp['upd']['beta'].to_s)
end
end
end
if rsp['wn'].is_a?(Array)
rsp['wn'].each do |n|
Notifications.join(n['alert'],n['sound'],n['id'])
end
end
if (rsp['wn']||[]).size==0
$wn_agent||=2
else
$wn_agent||=1
end
rescue JSON::ParserError => e
end
end
}
q=Notifications.queue
if q.size>10
play 'new'
else
2.times {$getasynckeystate.call(0x11)}
if $wn_agent!=1
q.each do |n|
speech n.alert
play n.sound if n.sound!=nil
while speech_actived
speech_stop if $getasynckeystate.call(0x11)!=0 and $voice>=0 and Time.now.to_f-($speech_lasttime||0)>0.1
sleep 0.01
end
end
else
$wn_agent=2
end
end
end
sleep(0.02)
$li+=1
$li=0 if $li>=$refreshtime*50
$tm=$wnlasttime if $wnlasttime!=nil
$tm=Time.now.to_i if $synctime==0 or $tm==nil
tim=Time.at($tm)
m=tim.min
if $timelastsay!=tim.hour*60+tim.min
$saytimeperiod = readini($configdata + "\\interface.ini","Interface","SayTimePeriod","1").to_i
$saytimetype = readini($configdata + "\\interface.ini","Interface","SayTimeType","1").to_i
$synctime = readini($configdata + "\\advanced.ini","Advanced","SyncTime","1").to_i
if (($saytimeperiod>0 and m==0) or ($saytimeperiod>1 and m==30) or ($saytimeperiod>=2 and (m==15 or m==45)))
play("clock") if $saytimetype==1 or $saytimetype==3
speech(sprintf("%02d:%02d",tim.hour,tim.min)) if $saytimetype==1 or $saytimetype==2
end
alarms=[]
if FileTest.exists?($configdata+"\\alarms.dat")
alarms=Marshal.load(IO.binread($configdata+"\\alarms.dat"))
end
asc=nil
for i in 0..alarms.size-1
a=alarms[i]
if tim.hour==a[0] and tim.min==a[1]
asc=i
end
end
if asc != nil
a=alarms[asc]
if a[2]==0
alarms.delete_at(asc)
IO.binwrite($configdata+"\\alarms.dat",Marshal.dump(alarms))
end
@alarmplaying=true
bgplay("alarm")
IO.write("temp/agent_alarm.tmp",asc.to_s)
end
$timelastsay=tim.hour*60+tim.min
end
if @alarmplaying == true and FileTest.exists?("temp/agent_alarm.tmp") == false
@alarmplaying=false
bgstop
end
end
rescue Interrupt
rescue SystemExit
rescue Exception
STDOUT.binmode.write((Marshal.dump({'func'=>'error','msg'=>$!.to_s,'loc'=>$@.to_s})))
end
$sslsock.close if $sslsock!=nil and !$sslsock.closed?
